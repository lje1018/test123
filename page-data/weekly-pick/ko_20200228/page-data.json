{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20200228","result":{"data":{"post":{"html":"<h1 id=\"v8-엔진자바스크립트-nodejs-deno-webassembly-내부의-메모리-관리-시각화하기\" style=\"position:relative;\"><a href=\"#v8-%EC%97%94%EC%A7%84%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-nodejs-deno-webassembly-%EB%82%B4%EB%B6%80%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%8B%9C%EA%B0%81%ED%99%94%ED%95%98%EA%B8%B0\" aria-label=\"v8 엔진자바스크립트 nodejs deno webassembly 내부의 메모리 관리 시각화하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 엔진(자바스크립트, NodeJS, Deno, WebAssembly) 내부의 메모리 관리 시각화하기</h1>\n<blockquote>\n<p>원문 : <a href=\"https://deepu.tech/memory-management-in-v8/\">https://deepu.tech/memory-management-in-v8/</a></p>\n</blockquote>\n<p><strong><a href=\"https://twitter.com/deepu105\">트위터</a> 계정을 팔로우하고 글에서 개선할 내용이 있다면 알려달라.</strong></p>\n<hr>\n<p>이번 연재물에서는 메모리 관리 개념을 이해하고 현대 프로그래밍 언어에서 사용하는 메모리 관리 방법에 대해 자세히 살펴보고자 한다. 이 연재물이 메모리 관리 관점에서 언어마다 일어날 수 있는 일에 대한 통찰력을 줄 수 있길 바란다.</p>\n<hr>\n<p>이번 장에서는 NodeJS, Deno와 Electron과 같은 런타임 및  Chrome, Chromium, Brave, Opera, Microsoft Edge와 같은 웹 브라우저에서 사용되는 <a href=\"https://tc39.es/ecma262/\">ECMAScript</a>와 <a href=\"https://webassembly.github.io/spec/core/\">WebAssembly</a>를 위한 <a href=\"https://v8.dev/\">V8 엔진</a>의 메모리 관리 방법에 대해 살펴볼 것이다.</p>\n<p>자바스크립트는 인터프리터 언어기 때문에 코드를 해석하고 실행하는 엔진이 필요하다. V8 엔진은 자바스크립트를 해석하고 컴파일하여 기계어로 변환한다. V8은 C++로 작성되었으며 모든 C++ 애플리케이션에서 내장할 수 있다.</p>\n<p>이 연재물의 <a href=\"https://dev.to/deepu105/demystifying-memory-management-in-modern-programming-languages-ddd\">첫 번째 글</a>에서 이 글을 이해하는데 도움을 줄 스택 메모리와 힙 메모리의 차이점을 설명하고 있으므로, 먼저 읽고 오는 것을 추천한다.</p>\n<h2 id=\"v8-메모리-구조\" style=\"position:relative;\"><a href=\"#v8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"v8 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 메모리 구조</h2>\n<p>먼저, 우리는 V8 엔진의 메모리 구조를 살펴볼 것이다. 자바스크립트가 단일 스레드이기 때문에 V8은 자바스크립트 컨텍스트 당 한 개의 프로세스를 사용한다. 따라서 만약 서비스 워커를 사용한다면 워커 당 한 개의 새로운 V8 프로세스를 생성하게 될 것이다. 실행 중인 프로그램은 V8 프로세스에서 할당된 일정량의 메모리로 표현되고 이를 <strong>Resident Set</strong>이라고 한다. Resident Set은 아래와 같이 더 세부적으로 나누어진다.</p>\n<p><img src=\"https://miro.medium.com/max/1584/0*SM_Ja0xN9q54Lpqf.png\"></p>\n<p>Resident Set은 <a href=\"https://dev.to/deepu105/visualizing-memory-management-in-jvm-java-kotlin-scala-groovy-clojure-19le\">이전 글</a>에서 살펴본 JVM 메모리 구조와 조금 유사하다. 각 세그먼트마다 무엇이 다른지 함께 살펴보자.</p>\n<h3 id=\"힙-메모리\" style=\"position:relative;\"><a href=\"#%ED%9E%99-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"힙 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>힙 메모리</h3>\n<p>V8 엔진은 힙 메모리에 객체나 동적 데이터를 저장한다. 힙 메모리는 메모리 영역에서 가장 큰 블록이면서 <strong>가비지 컬렉션(GC)</strong>이 발생하는 곳이다. 힙 메모리 전체에서 가비지 컬렉션이 실행되는 것은 아니다. Young과 Old 영역에서만 실행된다. 힙 메모리는 다음과 같이 더 세부적으로 나눌 수 있다.</p>\n<ul>\n<li><strong>New 영역</strong>: New 영역 또는 <strong>\"Young 제너레이션\"</strong>은 새로 만들어진 모든 객체를 저장하고 이 객체들은 짧은 생명 주기를 가진다. 이 영역은 크기가 작고 JVM에서 S0와 S1과 같은 2개의 <strong>세미(semi) 영역</strong>을 가진다. 이 영역은 이후에 살펴볼 <strong>스캐벤져(Scavenger, 마이너 GC)</strong>가 관리한다. New 영역의 크기는 <code class=\"tui-language-text\">--min_semi_space_size</code>(초기값)와 <code class=\"tui-language-text\">--max_semi_space_size</code>(최대값) V8 엔진의 플래그 값을 사용해 조정할 수 있다.</li>\n<li>\n<p><strong>Old 영역</strong>: Old 영역 또는 <strong>\"Old 제너레이션\"</strong>은 마이너 GC가 두 번 발생할 동안 \"New 영역\"에서 살아남은 객체들이 이동하는 영역이다. 이 영역은 이후에 살펴볼 <strong>메이저 GC(Mark-Sweep 및 Mark-Compact)</strong>가 관리한다. Old 영역의 크기는  V8 엔진의 플래그 값 <code class=\"tui-language-text\">--initial_old_space_size</code>(초기값)와 <code class=\"tui-language-text\">max_old_space_size</code>(최대값)을 사용해 조정할 수 있다. 이 영역은 다시 2개의 영역으로 나누어진다.</p>\n<ul>\n<li><strong>Old 포인터 영역</strong>: 살아남은 객체들을 가지며, 이 객체들은 다른 객체를 참조한다.</li>\n<li><strong>Old 데이터 영역</strong>: 데이터만 가진 객체들(다른 객체를 참조하지 않는다)을 가진다. 문자열, 박싱(boxing)된 숫자, 실수형(double)로 언박싱(unboxing)된 배열은 마이너 GC가 두 번 발생하면서 \"New 영역\"에서 살아남아 이 영역으로 이동한다.</li>\n</ul>\n</li>\n<li><strong>라지 오브젝트 영역</strong>: 다른 영역의 제한된 크기보다 큰 객체들이 살고 있는 영역이다. 각 객체는 자체 <a href=\"https://en.wikipedia.org/wiki/Mmap\">mmap</a> 메모리 영역을 갖는다. 라지 오브젝트들은 가비지 컬렉터로 이동하지 않는다.</li>\n<li><strong>코드 영역</strong>: <strong>실시간(JIT)</strong> 컴파일러가 컴파일된 코드들을 저장하는 곳이다. 유일하게 실행 가능한 메모리가 있는 영역이다. (코드들은 \"라지 오브젝트 영역\"에 할당될 수도 있고 실행도 가능하다) </li>\n<li><strong>셀 영역, 속성 셀 영역, 맵 영역</strong>: 이 영역들은 각각 <code class=\"tui-language-text\">Cells</code>, <code class=\"tui-language-text\">PropertyCells</code>, <code class=\"tui-language-text\">Maps</code>을 포함한다. 각 영역은 모두 같은 크기의 객체들을 포함하며, 어떤 종류의 객체를 참조하는지에 대한 제약이 있어서 수집을 단순하게 만든다.</li>\n</ul>\n<p>각 영역은 페이지들로 구성되어 있다. 페이지는 운영 체제에서 <code class=\"tui-language-text\">mmap</code>(또는 Windows에서 <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile\"><code class=\"tui-language-text\">MapViewOfFile</code></a>)로 할당된 연속된 메모리 청크를 의미한다. 각 페이지 크기는  라지 오브젝트 영역을 제외하고 1MB를 차지한다.</p>\n<h3 id=\"스택\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D\" aria-label=\"스택 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택</h3>\n<p>스택은 메모리 영역이고 V8 프로세스마다 하나의 스택을 가진다. 스택은 메서드와 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장되는 곳이다. 스택 메모리의 크기 제한은 <code class=\"tui-language-text\">--stack_size</code> V8 플래그 값을 사용해 설정할 수 있다.</p>\n<hr>\n<h3 id=\"v8-메모리-사용-스택-vs-힙\" style=\"position:relative;\"><a href=\"#v8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9-%EC%8A%A4%ED%83%9D-vs-%ED%9E%99\" aria-label=\"v8 메모리 사용 스택 vs 힙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 메모리 사용 (스택 vs 힙)</h3>\n<p>이제 메모리가 어떻게 구성되어 있는지 명확하게 알았으니, 프로그램이 실행될 때 가장 중요한 부분이 어떻게 사용되는지에 대해 살펴보자.</p>\n<p>아래와 같은 자바스크립트 프로그램을 사용하는데, 이 코드는 최적화되어 있지 않으므로 불필요한 중간 변수들과 같은 문제는 무시하고 스택과 힙 메모리 사용을 시각화하는 데 집중하기로 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Employee</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> salary<span class=\"token punctuation\">,</span> sales</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>salary <span class=\"token operator\">=</span> salary<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sales <span class=\"token operator\">=</span> sales<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">BONUS_PERCENTAGE</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getBonusPercentage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">salary</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> percentage <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>salary <span class=\"token operator\">*</span> <span class=\"token constant\">BONUS_PERCENTAGE</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> percentage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">findEmployeeBonus</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">salary<span class=\"token punctuation\">,</span> noOfSales</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> bonusPercentage <span class=\"token operator\">=</span> <span class=\"token function\">getBonusPercentage</span><span class=\"token punctuation\">(</span>salary<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> bonus <span class=\"token operator\">=</span> bonusPercentage <span class=\"token operator\">*</span> noOfSales<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> bonus<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> john <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Employee</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"John\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njohn<span class=\"token punctuation\">.</span>bonus <span class=\"token operator\">=</span> <span class=\"token function\">findEmployeeBonus</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">.</span>salary<span class=\"token punctuation\">,</span> john<span class=\"token punctuation\">.</span>sales<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">.</span>bonus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>아래 슬라이드를 클릭한 후 화살표 키를 사용해서 앞/뒤로 움직이면, 위 프로그램이 실행되는 순서와 스택 및 힙 메모리가 사용되는 방법을 이해할 수 있다.</p>\n<blockquote>\n<p><a href=\"https://speakerdeck.com/deepu105/v8-memory-usage-stack-and-heap\">V8 메모리 사용에 대한 슬라이드</a></p>\n</blockquote>\n<p>이 슬라이드에서 확인할 수 있는 것은</p>\n<ul>\n<li><strong>전역 스코프</strong>는 스택에서 \"전역 프레임\"에 보관된다. </li>\n<li>모든 함수 호출은 프레임 블록으로 스택 메모리에 추가된다.</li>\n<li>반환 값과 인자를 포함한 모든 지역 변수들은 스택에서 함수 프레임 블록 안에 저장된다.</li>\n<li><code class=\"tui-language-text\">int</code>와 <code class=\"tui-language-text\">string</code>과 같은 모든 원시 타입 값은 스택에 바로 저장된다. 이는 전역 스코프에서도 적용되며, 자바스크립트에서 문자열은 원시 타입에 해당한다.</li>\n<li><code class=\"tui-language-text\">Employee</code>와 <code class=\"tui-language-text\">Function</code>과 같은 객체 타입의 값은 힙에서 생성되고 스택 포인터를 사용해 힙에서 스택을 참조한다. 함수들은 자바스크립트에서 객체이다. 전역 스코프에도 적용된다.</li>\n<li>현재 함수에서 호출된 함수들은 스택의 최상단에 추가된다.</li>\n<li>함수 프레임이 반환(역자주: 함수가 종료)될 때 스택에서 제거된다.</li>\n<li>주요 프로세스가 완료될 때 힙에 있는 객체들은 어떤 포인터도 가지고 있지 않고 혼자 남게 된다.</li>\n<li>명시적으로 복사하지 않으면, 다른 객체 내의 모든 객체 참조들은 참조 포인터를 사용해 연결된다.</li>\n</ul>\n<p>보다시피 스택은 자동으로 관리되고 V8 엔진 자체가 아닌 운영 체제가 수행하므로 걱정하지 않아도 된다. 반면에 힙은 운영 체제에 의해 자동으로 관리되지 않고 가장 큰 메모리 영역과 동적 데이터를 보유하고 있기 때문에, 시간이 지남에 따라 프로그램의 메모리가 기하급수적으로 증가할 수 있다. 또한 시간이 지나면서 조각화되어 애플리케이션 속도를 느리게 만든다.</p>\n<p>힙에서 포인터와 데이터를 구분하는 것은 가비지 컬렉션에서 중요하며 이를 처리하기 위해, V8 엔진은 <strong>\"태그된 포인터(Tagged pointers)\"</strong> 접근 방식을 사용한다. 태그된 포인터는 각 단어의 끝에 포인터 또는 데이터인지를 나타내는 비트 값을 저장하는 방식이다.</p>\n<p>이 접근 방식은 제한적인 컴파일러 지원이 필요하지만, 굉장히 효율적이면서 구현하기 쉽다.</p>\n<h2 id=\"v8-메모리-관리-가비지-컬렉션\" style=\"position:relative;\"><a href=\"#v8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\" aria-label=\"v8 메모리 관리 가비지 컬렉션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 메모리 관리: 가비지 컬렉션</h2>\n<p>V8 엔진이 메모리를 할당하는 방식을 알았으니, 이제는 애플리케이션 성능에서 매우 중요한 부분인 힙 메모리가 어떻게 자동으로 관리되는지에 대해 살펴보자.</p>\n<p>프로그램이 사용 가능한 것보다 더 많은 메모리를 힙에 할당하려고 할 때 <strong>메모리 부족 오류</strong>가 발생한다. 힙이 잘못 관리되면 메모리 누수가 발생할 수 있다.</p>\n<p>V8 엔진은 가비지 컬렉션을 사용해 힙 메모리를 관리한다. 간단하게 말하면, 가비지 컬렉션은 참조 없는 객체들이 사용하는 메모리를 비워서 새로운 객체를 생성하기 위한 공간을 만드는 역할을 한다. 참조 없는 객체(orphan object)란, 스택으로부터 (다른 객체 내부의 참조를 통해) 더 이상 직접 혹은 간접적으로 참조되지 않는 객체를 말한다.</p>\n<blockquote>\n<p><strong>Orinoco</strong>는 가비지 컬렉션에 병렬(parallel), 인크리멘탈(incremental) 및 동시(concurrent) 기술을 사용하여 메인 스레드를 방해하지 않도록 하는 V8 GC 프로젝트의 코드명이다.</p>\n</blockquote>\n<p>V8 엔진의 가비지 컬렉터의 역할은 V8 프로세스에서 재사용하기 위해 사용되지 않은 메모리를 회수하는 것이다.</p>\n<p>V8 가비지 컬렉터는 세대적이다(힙 메모리 내의 객체들은 수명에 따라 그룹화되고 다른 단계에서 제거된다). 다음은 V8 엔진의 가비지 컬렉션에서 사용되는 2단계와 3개의 알고리즘에 대한 설명이다.</p>\n<h3 id=\"마이너-gc-scavenger\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%9D%B4%EB%84%88-gc-scavenger\" aria-label=\"마이너 gc scavenger permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마이너 GC (Scavenger)</h3>\n<p>마이너 GC는 New 영역(또는 Young 제너레이션)을 작고 깨끗하게 유지시킨다. 객체들은 New 영역에 할당되고 크기가 매우 작다(상황에 따라 1~8MB를 차지한다). \"New 영역\"에 대한 할당 비용은 매우 저렴하다. 새 객체에 대한 공간을 예약하려고 할 때마다 증가하는 할당 포인터가 있기 때문이다. 이 할당 포인터가 New 영역의 마지막에 도달하면, 마이너 GC가 발생한다. 이 과정을 <strong>스캐벤저(Scavenger)</strong>라고 하며, <a href=\"https://en.wikipedia.org/wiki/Cheney&#x27;s_algorithm\">Cheney의 알고리즘</a>을 사용해 구현되었다. 스캐벤저는 매우 자주 발생하고 병렬 헬퍼 스레드를 사용하며, 굉장히 빠르다.</p>\n<p>마이너 GC 과정을 살펴보자.</p>\n<p>New 영역은 크기가 같은 2개의 세미 영역으로 나뉜다. <strong>To 영역</strong>과 <strong>From 영역</strong>이다. 대부분의 할당은 To 영역에서 만들어진다(항상 Old 영역에서 할당된 실행 코드와 같은 특정 종류의 객체 제외). To 영역이 가득 차면 마이너 GC가 발생한다.</p>\n<p>아래 슬라이드에서 화살표를 따라가 보면서 마이너 GC 과정을 살펴보자.</p>\n<blockquote>\n<p><a href=\"https://speakerdeck.com/deepu105/v8-minor-gc\">V8 마이너 GC에 대한 슬라이드</a></p>\n</blockquote>\n<ol>\n<li>시작할 때 To 영역에 객체가 이미 있다고 가정해보자(01~06 블록은 사용된 메모리로 표시됨).</li>\n<li>새 객체(07 블록)를 생성한다.</li>\n<li>V8은 To 영역에서 필요한 메모리를 가져오려고 시도하지만, 객체들을 모두 수용할 수 없기 때문에 V8은 마이너 GC를 발생시킨다.</li>\n<li>마이너 GC는 객체들을 To 영역에서 From 영역으로 이동시킨다. 이제 모든 객체는 From 영역에 있고 To 영역은 비워진다.</li>\n<li>마이너 GC는 스택 포인터(GC 루트)부터 From 영역까지 객체 그래프를 재귀적으로 순회하면서 메모리를 사용한 객체들을 찾는다. 이 객체들은 To 영역의 페이지로 이동된다. 이 객체들을 참조하는 객체들은 To 영역의 페이지로 이동되고 포인터들은 갱신된다. From 영역의 모든 객체들을 찾을 때까지 이 과정이 반복된다. 마지막 객체까지 찾으면 To 영역은 자동으로 압축되어 조각화를 줄인다.</li>\n<li>이제 From 영역에 남아있는 객체는 가비지이므로 마이너 GC는 From 영역을 비운다.</li>\n<li>새 객체는 To 영역 메모리에 할당된다.</li>\n<li>어느 정도 시간이 지나 \"To 영역\"에 더 많은 객체가 생겼다고 가정해보자(07~09 블록은 사용된 메모리로 표시됨).</li>\n<li>애플리케이션이 새 객체(10 블록)을 생성한다.</li>\n<li>V8은 To 영역에서 필요한 메모리를 가져오려고 시도하지만, 객체들을 모두 수용할 수 없기 때문에 V8은 두 번째 마이너 GC를 발생시킨다. </li>\n<li>위 과정은 반복되고 두 번째 마이너 GC에서 생존한 객체들은 \"Old 영역\"으로 이동한다.  첫 번째 마이너 GC에서 생존한 객체들은 \"To 영역\"으로 이동하고 남아있는 객체들은 \"From 영역\"에서 제거된다.</li>\n<li>새 객체는 \"To 영역\"에 할당된다.</li>\n</ol>\n<p>마이너 GC가 Young 제너레이션에서 공간을 회수하고 깨끗하게 유지하는 방법에 대해 살펴보았다. 마이너 GC는 stop-the-world 프로세스지만, 굉장히 빠르고 효율적이므로 무시할 수 있다. 이 프로세스는 \"New 영역\"의 참조를 위해 \"Old 영역\"에서 객체들을 찾지 않기 때문에, \"Old 영역\"에서 \"New 영역\"까지 모든 포인터의 레지스터를 사용한다. 이것은 <strong><a href=\"https://www.memorymanagement.org/glossary/w.html#term-write-barrier\">Write barrier</a></strong>라고 하는 프로세스를 통해 저장 버퍼에 기록된다.</p>\n<h3 id=\"메이저-gc\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%9D%B4%EC%A0%80-gc\" aria-label=\"메이저 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메이저 GC</h3>\n<p>메이저 GC는 Old 제너레이션 영역을 작고 깨끗하게 유지시킨다. 메이저 CG는 V8에서 Old 영역의 메모리가 충분하지 않다고 판단될 때 발생한다. Old 영역은 동적으로 계산된 크기에 기반하며, 마이너 GC 주기에서 채워진다. 스캐벤저 알고리즘은 작은 데이터 크기에는 적합하지만 Old 영역과 같이 큰 힙 메모리에는 적합하지 않다. 메모리 오버헤드가 있기 때문에 메이저 GC는 <strong>Mark-Sweep-Compact</strong> 알고리즘을 사용하여 처리된다. 메이저 GC는 <strong>Tri-color(흰색-회색-검은색)</strong> 마킹 시스템을 사용한다. 따라서 메이저 GC는 세 단계의 프로세스를 거치며, 세 번째 단계는 조각화 휴리스틱(fragmentation heuristic)에 따라 실행된다.</p>\n<p><img src=\"https://miro.medium.com/max/1080/0*5cyzEpak2KthNN0U.gif\"></p>\n<ul>\n<li><strong>마킹(Marking)</strong>: 두 알고리즘의 공통적인 첫 번째 단계로, 가비지 컬렉터가 어떤 객체가 사용중인지 식별한다. 사용중이거나 GC 루트(스택 포인터)에 재귀적으로 도달할 수 있는 객체들은 활성 상태로 표시된다. 마킹은 기술적으로 힙 메모리를 방향 그래프(directed graph)로 간주해 깊이 우선 탐색(depth first search)를 수행한다.</li>\n<li><strong>스위핑(Sweeping)</strong>: 가비지 컬렉터가 힙 메모리를 순회하면서 활성 상태로 표시되지 않은 객체들의 메모리 주소를 기록한다. 이 공간은 이제 사용 가능한 목록(free-list)에서 사용 가능하다고 표시되며 다른 객체들을 저장하는 데 사용될 수 있다.</li>\n<li><strong>압축(Compacting)</strong>: 스위핑이 일어난 다음, 필요하다면 모든 활성 상태의 객체들이 함께 이동될 것이다. 압축 단계는 조각화를 줄이고 새 객체들에 대한 메모리 할당 성능을 증가시킨다.</li>\n</ul>\n<p>또한 메이저 GC는 GC를 수행하는 동안 애플리케이션 실행을 멈추므로 stop-the-world GC라고도 한다. 이를 피하기 위해  V8에서는 다음과 같은 기술을 사용한다.</p>\n<p><img src=\"https://miro.medium.com/max/1584/1*1FzmXNI6mIXKdOEi-mbTOw.png\"></p>\n<ul>\n<li><strong>인크리멘탈 GC(Incremental GC)</strong>: GC는 여러 개의 인크리멘탈 단계로 수행된다.</li>\n<li><strong>동시 마킹(Concurrent marking)</strong>: 마킹은 자바스크립트 메인 스레드에 영향을 주지 않고 다중 헬프 스레드를 사용해 동시에 수행된다. Write barrier는 헬퍼들이 동시에 마킹하는 동안 자바스크립트가 생성한 객체 간 참조를 추적하는 데 사용된다.</li>\n<li><strong>동시 스위핑/압축(Concurrent sweeping/compacting)</strong>: 스위핑과 압축은 자바스크립트 메인 스레드에 영향을 주지 않고 헬퍼 스레드에서 동시에 수행된다.</li>\n<li><strong>레이지 스위핑(Lazy sweeping)</strong>: 레이지 스위핑은 메모리가 필요할 때까지 페이지에서 가비지 삭제를 지연시킨다.</li>\n</ul>\n<p>메이저 GC 과정을 살펴보자.</p>\n<ol>\n<li>많은 마이너 GC 주기를 거치고 Old 영역이 거의 다 찼으며 V8이 \"메이저 GC\"를 발생시킨다고 가정해보자.</li>\n<li>메이저 GC는 스택 포인터에서 시작해 재귀적으로 객체 그래프를 순회하면서, Old 영역 내 메모리를 사용한 객체와 남아있는 객체를 가비지로 표시한다.</li>\n<li>동시 마킹이 완료되거나 메모리 제한에 도달하면 GC는 메인 스레드를 사용하여 마킹의 마지막 단계를 수행한다. 이 때 일시 정지 시간이 발생한다.</li>\n<li>메이저 GC는 동시 스위프 스레드를 사용해 모든 참조 없는 객체들의 메모리를 사용 가능한 상태로 표시한다. 또한 조각화를 피하기 위해 관련 메모리 블록을 동일한 페이지로 이동하도록 병렬 압축 작업도 발생한다. 포인터들은 이 세 단계를 통해 갱신된다.</li>\n</ol>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>이번 글에서는 V8 엔진의 메모리 구조와 관리 방법에 대해서 소개했다. <a href=\"v8.dev\">v8.dev</a>에서 더 많은 고급 개념들을 배울 수 있다. 그러나 대부분의 자바스크립트/웹 어셈블리 개발자에게는 이 정도의 정보만으로 충분할 것이다. 오늘 다룬 내용을 숙지하여 메모리 누수 문제를 예방하고 더 나은 프로그램을 작성하는 데 도움이 되기를 바란다.</p>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<ul>\n<li><a href=\"https://v8.dev/blog/trash-talk\">https://v8.dev/blog/trash-talk</a></li>\n<li><a href=\"http://jayconrod.com\">http://jayconrod.com</a></li>\n<li><a href=\"https://blog.codeship.com\">https://blog.codeship.com</a></li>\n<li><a href=\"https://developer.mozilla.org\">https://developer.mozilla.org</a></li>\n<li><a href=\"https://blog.sessionstack.com\">https://blog.sessionstack.com</a></li>\n</ul>\n<p>당신이 V8 엔진 내부에 대해 재미를 느꼈으면 좋겠고 시리즈의 다음 글을 계속 지켜봐 주길 바란다.</p>\n<p>이번 글이 좋았다면 추천 또는 코멘트를 남겨달라.</p>\n<p><a href=\"https://twitter.com/deepu105\">트위터</a>와 <a href=\"https://www.linkedin.com/in/deepu05/\">링크드 인</a>에서 필자를 팔로우할 수 있다.</p>\n<p><em>이 글은 2020년 1월 26일에 <a href=\"https://deepu.tech/memory-management-in-v8/\">블로그</a>와 <a href=\"https://dev.to\">https://dev.to</a>에 게시되었다.</em></p>","frontmatter":{"id":"ko_20200228","title":"V8 엔진(자바스크립트, NodeJS, Deno, WebAssembly) 내부의 메모리 관리 시각화하기","description":"이번 장에서는 NodeJS, Deno와 Electron과 같은 런타임 및 Chrome, Chromium, Brave, Opera, Microsoft Edge와 같은 웹 브라우저에서 사용되는 ECMAScript와 WebAssembly를 위한 V8 엔진의 메모리 관리 방법에 대해 살펴볼 것이다.","date":"2020.02.28","author":"류선임","tags":["ecmascript","nodejs","WebAssembly","browser"],"thumbnail":"https://i.imgur.com/kSgatSL.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20200228","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}