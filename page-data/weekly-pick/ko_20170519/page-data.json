{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20170519","result":{"data":{"post":{"html":"<h1 id=\"redux-saga---websocketsocketio-이벤트-처리\" style=\"position:relative;\"><a href=\"#redux-saga---websocketsocketio-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC\" aria-label=\"redux saga   websocketsocketio 이벤트 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux Saga - WebSocket(socket.io) 이벤트 처리</h1>\n<p><a href=\"https://facebook.github.io/react/\">React</a>(이하 리액트), <a href=\"https://github.com/reactjs/redux\">Redux</a>(이하 리덕스) 생태계에서 소켓과 같은 외부 이벤트 처리는 개발에 많은 고민을 안겨준다. 똑같은 외부 이벤트가 발생하더라도 앱의 상태에 따라 다르게 처리하고 싶을 수도 있고, 무시하고 싶을 수도 있으며, 앱의 상태와 관계없이 항상 처리하고 싶을 수도 있다. 특히 외부 이벤트가 리덕스의 액션과 연결되는 경우 리덕스의 미들웨어를 통해 액션이 Dispatch 됐다는 것을 알아야 한다. 때문에 단순한 리덕스 스토어의 API만으로는 모든 서비스 로직을 처리하기가 상당히 까다롭다.</p>\n<p>외부 이벤트 처리와 관련한 것 중 가장 자주 볼 수 있는 경우가 바로 소켓과의 연결이다. 리덕스 생태계에서는 <a href=\"https://github.com/markerikson/redux-ecosystem-links/blob/master/middleware-sockets-adapters.md\">소켓과 리덕스가 잘 어울릴 수 있도록 하는 많은 라이브러리</a>가 있지만, 이 글에서는 <a href=\"https://github.com/redux-saga/redux-saga/\">Redux-Saga</a>(이하 리덕스 사가 또는 사가)를 활용한 소켓 이벤트 처리를 알아보려 한다.</p>\n<h2 id=\"미리-알아야-할-것\" style=\"position:relative;\"><a href=\"#%EB%AF%B8%EB%A6%AC-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B2%83\" aria-label=\"미리 알아야 할 것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>미리 알아야 할 것</h2>\n<ul>\n<li><a href=\"http://redux.js.org/\">리덕스</a> - 리덕스 사가는 리덕스의 미들웨어다. 이전에 작성한 <a href=\"/test123/weekly-pick/ko_20170331/\">Redux 분석하기</a> 글도 시간이 된다면 참고하자.</li>\n<li><a href=\"https://redux-saga.js.org/\">리덕스 사가</a> - 이 글은 사가의 API를 활용하는 글이기 때문에 사가에 대한 기본적인 이해가 필요하다. 번역 글인 <a href=\"https://github.com/reactkr/learn-react-in-korean/blob/master/translated/deal-with-async-process-by-redux-saga.md\">\"redux-saga로 비동기처리와 분투하다.\"</a>도 시간이 된다면 참고해보자. (아직은 리덕스-사가에 대한 한글로 작성된 글이 많이 없는 것 같다.)</li>\n</ul>\n<h2 id=\"소켓-이벤트-채널-만들기\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%BC%93-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B1%84%EB%84%90-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"소켓 이벤트 채널 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소켓 이벤트 채널 만들기</h2>\n<p>리덕스 사가에서는 기본적으로 <a href=\"https://redux-saga.js.org/docs/advanced/Channels.html\">채널, 액션 채널, 이벤트 채널</a>이라는 API를 제공한다. 소켓 이벤트를 연결하기 위해서는 <a href=\"https://redux-saga.js.org/docs/api/#eventchannelsubscribe-buffer-matcher\">이벤트 채널 API</a>를 활용해볼 수 있다.</p>\n<p>먼저 간단하게 소켓 이벤트 채널을 만들어주는 팩토리 함수를 만들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// createSocketChannel.js</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> eventChannel<span class=\"token punctuation\">,</span> buffers <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"redux-saga\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> socket <span class=\"token keyword\">from</span> <span class=\"token string\">\"../../../mySocket\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">defaultMatcher</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createSocketChannel</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">eventType<span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">,</span> matcher</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">eventChannel</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">emit</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">emitter</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">message</span> <span class=\"token operator\">=></span> <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      socket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span>eventType<span class=\"token punctuation\">,</span> emitter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        socket<span class=\"token punctuation\">.</span><span class=\"token function\">off</span><span class=\"token punctuation\">(</span>eventType<span class=\"token punctuation\">,</span> emitter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    buffer <span class=\"token operator\">||</span> buffers<span class=\"token punctuation\">.</span><span class=\"token function\">none</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    matcher <span class=\"token operator\">||</span> defaultMatcher\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">closeChannel</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">channel</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    channel<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이벤트 채널 API를 정말 간단하게 wrapping만 해도 소켓 채널 팩토리를 만들 수 있다. 그리고 이벤트 채널을 만들 때는 항상 unsubscribe 함수를 반환해야 하는 점은 잊지 말자.</p>\n<p><code class=\"tui-language-text\">buffer</code>나 <code class=\"tui-language-text\">matcher</code>는 이후 이어지는 내용에서 조금 더 자세히 알아볼 예정이니 우선은 무시하자.</p>\n<h2 id=\"소켓-채널-메시지-수신\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%BC%93-%EC%B1%84%EB%84%90-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%88%98%EC%8B%A0\" aria-label=\"소켓 채널 메시지 수신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소켓 채널 메시지 수신</h2>\n<p>소켓 채널 팩토리를 만들었으니 이제 소켓 메시지들을 수신해보자. 다음 간단한 코드로 소켓 메시지를 수신할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> fork<span class=\"token punctuation\">,</span> take<span class=\"token punctuation\">,</span> call <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"redux-saga/effects\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createSocketChannel <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./createSocketChannel\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">onMessage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">rootSaga</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n  <span class=\"token comment\">// \"foo\"와 \"bar\"라는 메시지 수신하기</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>onMessage<span class=\"token punctuation\">,</span> <span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>onMessage<span class=\"token punctuation\">,</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>리덕스 사가는 리덕스의 미들웨어이기 때문에 소켓 채널에서 메시지를 받아 액션을 다시 Dispatch 하거나, 다른 액션을 기다리거나, 에러 처리 혹은 또 다른 비동기 처리 등의 많은 작업을 손쉽게 처리할 수 있다.</p>\n<h2 id=\"소켓-채널-활용하기---특정-액션에서-메시지-수신\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%BC%93-%EC%B1%84%EB%84%90-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0---%ED%8A%B9%EC%A0%95-%EC%95%A1%EC%85%98%EC%97%90%EC%84%9C-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%88%98%EC%8B%A0\" aria-label=\"소켓 채널 활용하기   특정 액션에서 메시지 수신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소켓 채널 활용하기 - 특정 액션에서 메시지 수신</h2>\n<p>소켓 채널을 통해 메시지를 수신하는 방법까지 알아보았다. 이제 <code class=\"tui-language-text\">WAIT_FOO_MESSAGE_ONCE</code>라는 액션이 발생하면 소켓에서 <code class=\"tui-language-text\">&quot;foo&quot;</code> 타입의 메시지를 한 번만 수신해서 처리한다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> takeEvery<span class=\"token punctuation\">,</span> take<span class=\"token punctuation\">,</span> call <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"redux-saga/effects\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createSocketChannel<span class=\"token punctuation\">,</span> closeChannel <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./createSocketChannel\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token constant\">WAIT_FOO_MESSAGE_ONCE</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"../../../action/message\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">waitFooOnce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> channel<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span> <span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">closeChannel</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">rootSaga</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">takeEvery</span><span class=\"token punctuation\">(</span><span class=\"token constant\">WAIT_FOO_MESSAGE_ONCE</span><span class=\"token punctuation\">,</span> waitFooOnce<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"https://redux-saga.js.org/docs/api/#takeeverypattern-saga-args\"><code class=\"tui-language-text\">takeEvery</code></a>를 통해 <code class=\"tui-language-text\">WAIT_FOO_MESSAGE_ONCE</code>라는 액션에 <code class=\"tui-language-text\">waitFooOnce</code>라는 <a href=\"https://redux-saga.js.org/docs/Glossary.html#watcherworker\">Worker</a>를 등록했다. 이제 <code class=\"tui-language-text\">WAIT_FOO_MESSAGE_ONCE</code> 액션이 발생할 때마다 <code class=\"tui-language-text\">&quot;foo&quot;</code> 메시지를 기다려서 처리할 수 있다!</p>\n<p>만약 메시지를 대기하는 작업이 끝나지 않은 상태에서 또 같은 액션이 발생했을 때, 전부 무시하고 한번만 메시지를 수신하고 싶다면 <code class=\"tui-language-text\">takeEvery</code> 대신 <a href=\"https://redux-saga.js.org/docs/api/#takelatestpattern-saga-args\"><code class=\"tui-language-text\">takeLatest</code></a>를 활용할 수 있다.</p>\n<h2 id=\"소켓-채널-활용하기---타임아웃\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%BC%93-%EC%B1%84%EB%84%90-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0---%ED%83%80%EC%9E%84%EC%95%84%EC%9B%83\" aria-label=\"소켓 채널 활용하기   타임아웃 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소켓 채널 활용하기 - 타임아웃</h2>\n<p>소켓 채널에 대해 이해했다면 이제 <code class=\"tui-language-text\">timeout</code> 로직을 구현하기도 매우 쉽다. 10초 동안 메시지를 기다리고, 메시지가 오지 않았다면 alert을 나타낸 후 소켓 메시지를 대기하는 작업을 종료시켜 보자.</p>\n<p><code class=\"tui-language-text\">waitFooOnce</code>를 다음과 같이 변경할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>delay<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'redux-saga'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>takeEvery<span class=\"token punctuation\">,</span> take<span class=\"token punctuation\">,</span> race<span class=\"token punctuation\">,</span> call<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'redux-saga/effects'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>createSocketChannel<span class=\"token punctuation\">,</span> closeChannel<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./createSocketChannel'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">WAIT_FOO_MESSAGE_ONCE</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../../../action/message'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">waitFooOnce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> channel<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>timeout<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      timeout<span class=\"token operator\">:</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      message<span class=\"token operator\">:</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout!!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">closeChannel</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">rootSaga</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">takeEvery</span><span class=\"token punctuation\">(</span><span class=\"token constant\">WAIT_FOO_MESSAGE_ONCE</span><span class=\"token punctuation\">,</span> waitFooOnce<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"https://redux-saga.js.org/docs/api/#raceeffects\"><code class=\"tui-language-text\">race</code> effect</a>를 통해 타임아웃을 간단히 구현할 수 있었다. 만약 리덕스 사가를 사용하지 않고, 특정 액션이 발생했을 때 어떤 소켓 메시지를 타임아웃 설정과 함께 기다리도록 구현한다고 생각해보자. 상상하는 것만으로도 머리가 너무 아프다.</p>\n<h2 id=\"버퍼-활용하기\" style=\"position:relative;\"><a href=\"#%EB%B2%84%ED%8D%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"버퍼 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>버퍼 활용하기</h2>\n<p>특정 액션이 발생하고, 그 액션에 알맞는 요청을 ajax로 처리 한 후 소켓 메시지를 기다린다고 생각해보자.</p>\n<p><code class=\"tui-language-text\">액션 Dispatch =&gt; ajax 처리 =&gt; 소켓 메시지 대기</code></p>\n<p>문제는 ajax 요청과 소켓 메시지는 둘 다 비동기라서 순서가 꼬일 수 있다. 조금 더 세분화해서 보면 다음과 같은 두 가지 흐름이 발생할 수 있다.</p>\n<ol>\n<li><code class=\"tui-language-text\">액션 Dispatch =&gt; ajax 요청 =&gt; ajax 응답 =&gt; 소켓 메시지</code></li>\n<li><code class=\"tui-language-text\">액션 Dispatch =&gt; ajax 요청 =&gt; 소켓 메시지 =&gt; ajax 응답</code></li>\n</ol>\n<p>만약 ajax의 응답과 소켓 메시지가 별개의 문제라면 상관없겠지만, 소켓 메시지가 이전에 호출한 ajax 응답의 결과와 연관되는 메시지라면 문제가 발생한다. 이런 경우를 대비하기 위해 버퍼를 활용할 수 있다.</p>\n<p>다음 코드는 문제가 발생할 수 있는 경우이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>api<span class=\"token punctuation\">.</span>requestFoo<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//... result에 따른 어떤 처리</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>timeout<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  timeout<span class=\"token operator\">:</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  message<span class=\"token operator\">:</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//.. message 따른 어떤 처리</span></code></pre></div>\n<p>ajax 응답이 도착하기 전에 소켓 메시지가 먼저 도착한다면 위 작업은 결국 메시지 타임아웃이 발생한다. 소켓 서버 입장에서는 분명히 메시지를 보냈는데도 불구하고 메시지가 도착하지 않은 것처럼 보이기 때문에 억울할 수 있다.</p>\n<p>이제 버퍼를 활용해보자. 아까 팩토리를 작성할 때 버퍼를 전달받도록 했다는 점을 기억하자. 이벤트 채널의 버퍼는 <a href=\"https://redux-saga.js.org/docs/api/#buffers\">buffers</a>라는 API를 통해 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span> buffers<span class=\"token punctuation\">.</span><span class=\"token function\">sliding</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>api<span class=\"token punctuation\">.</span>requestFoo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//... result에 따른 어떤 처리</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>timeout<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  timeout<span class=\"token operator\">:</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  message<span class=\"token operator\">:</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//.. message 따른 어떤 처리</span></code></pre></div>\n<p>버퍼의 사이즈를 1로 설정하고, overflow가 발생하면 이전 메시지를 버리도록 <code class=\"tui-language-text\">sliding</code> API(이 외에도 <code class=\"tui-language-text\">fixed</code>, <code class=\"tui-language-text\">expanding</code>, <code class=\"tui-language-text\">dropping</code>이 있다.)를 사용했다. ajax의 응답이 도착하지 전에 메시지가 먼저 도착해도 버퍼에 저장되고, 이후 <code class=\"tui-language-text\">take</code>로 가져올 수 있으니 메시지를 놓칠 걱정을 하지 않아도 된다!</p>\n<h2 id=\"matcher-활용하기\" style=\"position:relative;\"><a href=\"#matcher-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"matcher 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Matcher 활용하기</h2>\n<p>Matcher 사용은 버퍼보다 훨씬 간단하다. 이벤트가 수신될 때 실제로 채널에 전달되어야 하는 이벤트만 거르는 필터 역할을 한다.</p>\n<p>메시지에는 요청자 아이디가 있고, 애플리케이션은 메시지의 요청자가 자신일 때만 어떤 다른 처리를 한다고 생각해보자. 다음과 같이 Matcher를 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">matcher</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">message</span> <span class=\"token operator\">=></span> message<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">.</span>requester <span class=\"token operator\">===</span> <span class=\"token constant\">MY_ID</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">onMyMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span> <span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> matcher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 여기에서 받은 메시지는 전부 자신이 직접 요청한 메시지다.</span>\n      <span class=\"token keyword\">const</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// ... 메시지 처리</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p>소켓 채널에서 Matcher를 통해 필터링을 수행할 수 있기 때문에 소켓 메시지 리스너에서 별도의 분기 처리 로직들을 제거할 수 있다. 즉, 소켓 채널을 1개만 만들어서 리스너 내부에서 각 메시지에 따른 분기처리를 하기보다는 Mathcer를 활용해서 여러 개의 채널에서 각각의 서비스 로직을 처리하도록 하자.</p>\n<h2 id=\"빠르게-수신되는-메시지들에-대한-일괄-처리\" style=\"position:relative;\"><a href=\"#%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EC%88%98%EC%8B%A0%EB%90%98%EB%8A%94-%EB%A9%94%EC%8B%9C%EC%A7%80%EB%93%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%BC%EA%B4%84-%EC%B2%98%EB%A6%AC\" aria-label=\"빠르게 수신되는 메시지들에 대한 일괄 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빠르게 수신되는 메시지들에 대한 일괄 처리</h2>\n<p>리덕스-사가를 통해 소켓 메시지에 대한 처리를 손쉽게 할 수 있지만 그래도 문제는 여전히 발생한다. 특히 소켓 메시지가 빠르게 수신되고 그 메시지에 따른 어떤 액션을 dispatch 하는 경우 렌더링에 병목 현상이 발생한다. (관련 이슈 - <a href=\"https://github.com/reactjs/react-redux/issues/263\">\"Huge performance issue when dispatching hundreds of actions\"</a>)</p>\n<p>간단하게 앱을 리액트로 렌더링하는 다음과 같은 경우를 생각해보자.</p>\n<ol>\n<li>리스트에 아이템이 1000개가 있다.</li>\n<li>사용자가 리스트 아이템 1000개 삭제 요청을 한다.</li>\n<li>서버는 아이템 삭제를 비동기로 처리한다.</li>\n<li>각 아이템 삭제에 대한 소켓 메시지가 수신된다.</li>\n<li>아이템 삭제 메시지가 수신될 때마다 리스트 아이템 삭제 액션을 Dispatch 한다.</li>\n<li>리액트가 아이템이 제거된 리스트의 렌더링을 완료하기 전에, 다음 아이템 삭제 메시지가 도착한다.</li>\n<li>이 작업이 약 1000번 반복된다.</li>\n</ol>\n<p>이런 경우, 성능 저하를 피할 수 없다. 간단하게 한 번 더 생각해보자.</p>\n<ol>\n<li>첫 번째 아이템의 삭제 메시지가 도착했다.<br>\n-> 이전 상태 리스트와 다음 상태 리스트를 비교한다.<br>\n--> 리스트 아이템 엘리먼트 1000개를 비교한다.<br>\n---> 삭제된 아이템을 빼는 DOM 업데이트를 수행한다.</li>\n<li>두 번째 아이템의 삭제 메시지가 도착했다.<br>\n-> 이전 상태 리스트와 다음 상태 리스트를 비교한다.<br>\n--> 리스트 아이템 엘리먼트 999개를 비교한다.<br>\n---> 삭제된 아이템을 빼는 DOM 업데이트를 수행한다.</li>\n<li>...</li>\n</ol>\n<p>아이템 1000개를 삭제하면, 일단 DOM의 렌더링 1000번은 무조건 요구한다. 그리고 리액트 리스트 컴포넌트에서만 각 메시지에 따라 각 아이템 엘리먼트를 비교하는 Reconciliation 작업도 있다. 물론 리액트나 브라우저가 내부적으로 어떤 일괄 처리 작업을 수행할 수도 있지만, Operation 자체가 1000번의 DOM 렌더링과 약 50000번 이상의 Reconciliation을 요구하는 것은 변하지 않는다(+ 리덕스의 모든 Change 리스너도 1000번씩 수행된다). 결국 1000개의 메시지가 2~3초 이내에 전부 도착한다면 성능 문제가 발생한다.</p>\n<p>아래 코드를 보자. 평상시에는 별문제가 없겠지만, 많은 작업을 처리할 때는 큰 문제가 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// Action creator</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">deleteItems</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>ids</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token operator\">:</span> <span class=\"token constant\">DELETE_ITEMS</span><span class=\"token punctuation\">,</span>\n    ids\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// Saga</span>\n<span class=\"token keyword\">const</span> channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span> <span class=\"token string\">'deleteItem'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token function\">deleteItems</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>itemId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>성능 문제를 해결하기 위해 먼저 생각해볼 방법은 <a href=\"http://drupalmotion.com/article/debounce-and-throttle-visual-explanation\">Throttle이나 Debounce</a>지만 이런 삭제와 같은 작업에는 적합하지 않다. 어쨌든 결과적으로는 1,000개의 아이템 삭제를 모두 처리하고 사용자에게 보여주어야 하는데, Throttle이나 Debounce는 의도적으로 메시지를 버리는 작업이라서 그 결과를 정확히 보여줄 수가 없다.</p>\n<p>따라서 이런 경우에 약 100~200ms(앱마다 대기해야 할 시간은 다르므로 적정 시간은 꼭 측정해야 한다.) 정도는 메시지를 모았다가 한 번에 일괄처리하는 방법이 필요하다.</p>\n<p>이제 버퍼를 활용해서 메시지를 모아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// Saga</span>\n\n<span class=\"token keyword\">const</span> channel <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>createSocketChannel<span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'deleteItem'</span><span class=\"token punctuation\">,</span>\n   buffers<span class=\"token punctuation\">.</span><span class=\"token function\">expanding</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 임의로 50을 지정했다. 각 앱에 맞게 설정한다.</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> messages <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">flush</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> ids <span class=\"token operator\">=</span> messages<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span> <span class=\"token operator\">=></span> message<span class=\"token punctuation\">.</span>itemId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ids<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token function\">deleteItems</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>ids<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 임의로 지정한 대기 시간이다. 각 앱에 맞게 설정한다.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 버퍼를 활용하면 약 200ms 동안 메시지를 모아서 <code class=\"tui-language-text\">deleteItems</code>를 일괄적으로 처리할 수 있다. 또한, Throttle이나 Debounce와 다르게 메시지를 의도적으로 버리지 않는다.</p>\n<p>그리고 또 중요한 점은 바로 <code class=\"tui-language-text\">if (ids.length)</code> 구문이다. 만약 이 구문이 없으면 메시지를 받았든 받지 않았든 200ms마다 항상 dispatch 작업을 수행하여 개발자에게 엄청난 혼란을 줄 수 있으므로 주의하도록 하자.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>리덕스를 사용하는 애플리케이션에서 소켓과 같은 외부 이벤트들을 함께 처리하는 것은 꽤 어렵다. 앞서 설명한 리덕스 생태계의 라이브러리들이나 리덕스 사가를 활용하면 조금 더 쉽게 외부 이벤트들을 처리할 수 있을 것이다.</p>\n<p>이번에 리덕스 사가와 내부의 이벤트 채널, 버퍼, Matcher API를 활용해 소켓 이벤트를 간단히 처리할 수 있었다. 하지만, 그 예제나 설명이 생각보다 많이 없어서 처음에는 많은 어려움을 겪었다(리덕스 사가의 공식 문서는 꽤 잘 작성되어 있지만, 이벤트 채널에 대한 내용은 많이 없다). 이 글을 통해 리덕스 사가에서의 소켓 이벤트 처리에 조금이나마 도움이 되었길 바란다.</p>","frontmatter":{"id":"ko_20170519","title":"Redux Saga - WebSocket(socket.io) 이벤트 처리","description":"React(이하 리액트), Redux(이하 리덕스) 생태계에서 소켓과 같은 외부 이벤트 처리는 개발에 많은 고민을 안겨준다. 똑같은 외부 이벤트가 발생하더라도 앱의 상태에 따라 다르게 처리하고 싶을 수도 있고, 무시하고 싶을 수도 있으며, 앱의 상태와 관계없이 항상 처리하고 싶을 수도 있다. 특히 외부 이벤트가 리덕스의 액션과 연결되는 경우 리덕스의 미들웨어를 통해 액션이 Dispatch 됐다는 것을 알아야 한다. 때문에 단순한 리덕스 스토어의 API만으로는 모든 서비스 로직을 처리하기가 상당히 까다롭다.","date":"2017.05.19","author":"이민규","tags":["Redux","React"],"thumbnail":"https://image.toast.com/aaaadh/alpha/2017/techblog/ReduxSagaLogoCompact_thumbnail.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20170519","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}