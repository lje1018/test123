{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20200128","result":{"data":{"post":{"html":"<blockquote>\n<p>원문 <a href=\"https://dev.to/napoleon039/what-is-code-splitting-22ni\">https://dev.to/napoleon039/what-is-code-splitting-22ni</a></p>\n</blockquote>\n<p><img src=\"https://miro.medium.com/max/1216/1*-1Sj5oc82N8fii0SMhGIwA.jpeg\" alt=\"img1\"></p>\n<blockquote>\n<p>코드 스플리팅</p>\n<ul>\n<li>코드를 다양한 청크(<em>chunk</em>)로 나눌 수 있으며 필요에 따라 로드할 수 있다.</li>\n<li>페이지 렌더링에 필요한 초기 응답 크기를 줄이는 데 도움이 된다.</li>\n</ul>\n</blockquote>\n<h1 id=\"코드-스플리팅을-통해-사이트의-효율성을-높이는-방법\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%94%8C%EB%A6%AC%ED%8C%85%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"코드 스플리팅을 통해 사이트의 효율성을 높이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 스플리팅을 통해 사이트의 효율성을 높이는 방법</h1>\n<p>여러분이 웹사이트를 만들었다고 가정해보자. 색상 대비도 좋고, 작은 애니메이션들을 사용해서 상호작용하기에도 편하고, 전반적으로 좋아 보이는 웹사이트를 만들었다.</p>\n<p>하지만 첫 로드에 걸리는 시간이 길다고 느껴졌다. 왜 이렇게 오래 걸리는 걸까? 코드에는 아무런 문제가 없는 것 같아 더 의문에 빠졌다.</p>\n<p>이유는 한 페이지만 로드하면 되는 첫 시작 페이지에서 필요로 하지 않는 여러 페이지(또는 프레임워크를 사용하는 경우 import한 컴포넌트 파일)를 로딩하기 때문이다.</p>\n<p>웹팩은 이러한 문제점에 대한 해결책으로 <strong>코드 스플리팅</strong>(<em>code-splitting</em>)을 제공한다. 코드 스플리팅 기능은 특정 프레임워크에 속한 기능이 아니므로 웹팩을 사용하여 언제든지 적용할 수 있다.</p>\n<h2 id=\"소개\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EA%B0%9C\" aria-label=\"소개 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소개</h2>\n<p>이 글은 Vue에서 코드 수플리팅의 대한 내용을 다룬다. 자세히 말하면, Vue 컴포넌트를 <em>경로별</em>로 코드 스플리팅을 사용하였다. 코드 스플리팅은 웹 사이트를 더 빠르게 운영하는 데 도움이 되는 중요한 주제이다. 페이지에 필요한 컴포넌트만 로드되고, 원한다면 다른 컴포넌트도 함께 로드할 수 있다. 많은 컴포넌트를 작성하고 여러 경로를 설정(라우팅)해 주어야 하는 대형 프로젝트에서 코드 스플리팅을 사용하면 로드 시간을 단축하여 사이트 성능을 향상시킬 것이다.</p>\n<p>이 글을 최대한 활용하려면 Vue Router가 설치된 Vue 프로젝트가 좋겠다. 경로 설정에 코드 스플리팅 기능을 적용할 것이기 때문에 라우터(<em>Router</em>)가 필요하다. 물론, Vue가 아닌 다른 프레임워크에서도 코드 스플리팅 기능을 사용할 수 있다. 앞서 언급했듯이, 코드 스플리팅 기능은 프레임워크와는 관련이 없다. 코드를 분할하기 위한 세 가지 접근방식이 있다. 여기서는 세 가지 접근방식 중 <strong>동적 가져오기</strong>(<em>dynamic import</em>)에 대한 내용만 다룰 것이다. 코드 스플리팅에 대한 더 자세한 정보를 얻고 싶다면 <a href=\"https://webpack.js.org/guides/code-splitting/\">웹팩 문서</a>를 확인하자.</p>\n<h2 id=\"개념-비유\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%85%90-%EB%B9%84%EC%9C%A0\" aria-label=\"개념 비유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개념 비유</h2>\n<p>그릇에 있는 주스를 마시고 싶다고 가정해보자. 전체를 한 번에 다 마시지 말고 원하는 양만큼 따라 마신 다음, 그릇에 다시 넣는다. 우리가 하는 일은 주스를 유리잔에 마실 만큼 따르고, 더 먹고 싶다면 조금씩 더 따라 마시는 것이다. 코드 스플리팅도 이와 비슷한 개념이다. 큰 설정 작업이 필요할 것 같지만 빠르게 적용할 수 있다. 바로 시작해보자.</p>\n<h2 id=\"프로젝트-설정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%A4%EC%A0%95\" aria-label=\"프로젝트 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로젝트 설정</h2>\n<p>Vue 라우터를 사용하는 Vue 프로젝트가 필요하다. 만약에 없다면, 간단한 샘플 코드를 만들어보자. 코드가 분할된 결과를 명확히 확인하기 위해 두 개 이상의 컴포넌트가 필요하다. 여기에서 컴포넌트 내용이 <code class=\"tui-language-text\">&lt;h1&gt;</code>로만 이루어져 있는 것은 중요하지 않다. 실제로 코드 스플리팅이 어떻게 적용되는지 이해하는 것이 중요하다. 아직 프로젝트가 없다면 어서 프로젝트를 설정해보자. 여기 샘플 코드가 있다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--x2q4paEw--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/oeju9iujk964vxc9yonv.JPG\" alt=\"img1\"></p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--D5W0KqoU--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/pp3mmean39j46y2rnsgq.JPG\" alt=\"img2\"></p>\n<p>우선, 바벨의 동적 가져오기 플러그인을 설치한다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--bnggvRDh--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/psn6hgri0oksjzx08j7b.JPG\" alt=\"img3\"></p>\n<p>바벨이 이 플러그인을 요구하는 이유는 웹팩이 동적 가져오기를 이해하고 이에 맞게 번들링 하는데, 서버 측에서 바벨이 import 구문을 해석하고 트랜스파일하기 위함이다. <strong>Satyajit Sahoo</strong>는 babeljs 슬랙에서 이에 대해 꽤 잘 설명해주었다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--tugFUHhX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/2o2ef21v8grbjs3sr91z.JPG\" alt=\"img4\"></p>\n<blockquote>\n<p><code class=\"tui-language-text\">syntax-dynamic-import</code>는 바빌론(<em>babylon</em>)에서 구문 사용만 가능하게 해준다. 즉, 바빌론이 구문 오류 없이 코드를 구문 분석할 수 있다는 말이다. 여전히 이해할 수 없는 <code class=\"tui-language-text\">import(...)</code>코드가 남아있으며, 트랜스 파일 해야 한다. <code class=\"tui-language-text\">dynamic-import-node</code>가 <code class=\"tui-language-text\">import(...)</code>를 이해할 수 있는 <code class=\"tui-language-text\">require</code>로 트랜스파일한다. 클라이언트 측에서, 웹팩이 구문을 이해하고 번들링 하므로 트랜스파일 단계가 필요 없다.</p>\n</blockquote>\n<p>다음은 새로 설치된 플러그인을 바벨 설정 파일에 포함한다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--6mApHNLn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/bqs0b0o511mm1fv66wzr.JPG\" alt=\"img5\"></p>\n<p>프로젝트 설정은 끝났다. 이제 주요 내용을 살펴보자.</p>\n<h2 id=\"코드-스플리팅-구현\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%94%8C%EB%A6%AC%ED%8C%85-%EA%B5%AC%ED%98%84\" aria-label=\"코드 스플리팅 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 스플리팅 구현</h2>\n<p><code class=\"tui-language-text\">router.js</code>파일에 포함할 컴포넌트를 가져오는 일반적인 방법은 아래와 같다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--o3SLRQas--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/61m91bga6swb7hhv614m.JPG\" alt=\"img6\"></p>\n<p>현재 코드를 저장하고 개발 서버를 띄운다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\"># 개발 서버 실행\nnpm run dev # Vue v2.x 용\n\nnpm run serve # Vue v3.x 용</code></pre></div>\n<p>크롬, 파이어폭스 또는 원하는 브라우저를 띄어 사이트에 접속한다. 개발자 도구를 열고[F12 키보드 사용] 네트워크 탭으로 이동하여 페이지를 리로드해보자. 컴포넌트가 둘 다 로딩되는 것을 볼 수 있다. (역자주: 번들된 app.js 파일을 보면 두 개의 컴포넌트 내용이 모두 포함되어 있다) 필터에서 JS를 선택하면, (결과 목록 살짝 위쪽에 배치되어 있음, 아래 스크린샷 참조), <code class=\"tui-language-text\">app.js</code>가 보일 것이며 크기를 확인해보자.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--X0TkyFQC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/5gphrhv4q5z8kjw3b0ei.JPG\" alt=\"img7\"></p>\n<p>코드 스플리팅 없이 초기 로드 시 About 컴포넌트는 아직 필요하지 않더라도 Home 컴포넌트와 함께 번들 파일로 제공된다. 초기 로드가 필요하지 않은 컴포넌트는 번들 파일에 포함되지 않도록 수정해보자. 프로미스(<em>Promise</em>) 방식으로 가져오는 방법이 있다. 프로미스를 지원하지 않는 구형 브라우저를 위해 <em>폴리필</em>을 포함하는 것도 잊지 말자.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--mcxlBD_Q--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/yvm5sd4s9oont5oelc58.JPG\" alt=\"img8\"></p>\n<p>import 구문을 반환하는 함수를 작성해주기만 하면 끝이다. 이것이 동적 가져오기 구문이다. 웹팩은 import 구문을 만날 때마다 프로미스에 대한 응답으로 코드 스플리팅이라고 불리는 <strong>청크</strong>를 생성한다. 이제 코드를 저장하고 페이지를 리로드 한 다음 네트워크 탭을 확인해보자. 컴포넌트가 모두 로드되지 않는다. 경로를 바꿔 하나씩 방문하면 컴포넌트가 결과 창에 차례로 추가되는 것을 확인할 수 있다. 아래 이미지는 네트워크 탭에서 경로를 바꿔가며 하나씩 방문해본 결과이다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--MSv0WeFx--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/shw5iz8tzl0e9p2eleot.JPG\" alt=\"img9\"></p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--sNjFjIkL--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/diqovhgdfz8356mssns0.JPG\" alt=\"img10\"></p>\n<p>해냈다! 앞에서 개념 비유를 들면서 주스를 나눠 마시라고 했다. 한 번에 다 먹지 말라고 했던걸 기억해라. ;)</p>\n<p>잠깐! 네트워크 탭에 표시된 파일 이름이 숫자로 표시되어 있어 직관적이지 않다. import 구문에 주석을 추가하여 문제를 해결해보자.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--ZqFDj5R6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/tscfo1rq3asfn5nqs6hy.JPG\" alt=\"img10\"></p>\n<p>웹팩은 주석에 있는 문자 그대로 <strong>청크 이름</strong>으로 해석한다. webpackChunkName에 입력한 값은 숫자 대신 컴포넌트를 나타내는 이름이 된다. 이제 개발자 도구에서도 보고 있는 파일이 무엇인지 알 수 있다. 아마 About 컴포넌트가 여전히 초기 로드시에도 존재한다는 것을 볼 수 있다. 그러나 파일 크기를 확인해보면 0바이트로 실제 컴포넌트가 로드되는 것이 아니다. 아마도 Vue 개발 서버 내부에서 이루어지는 동작일 것이다. 실제 컴포넌트는 해당 경로를 방문할 때만 로드된다.</p>\n<h2 id=\"좀-더-실질적인-예\" style=\"position:relative;\"><a href=\"#%EC%A2%80-%EB%8D%94-%EC%8B%A4%EC%A7%88%EC%A0%81%EC%9D%B8-%EC%98%88\" aria-label=\"좀 더 실질적인 예 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좀 더 실질적인 예</h2>\n<p>코드 스플리팅을 주스 나눠 마시기에 비유하였는데, 현실에서 코드 스플리팅이 어떻게 활용되었을까?</p>\n<p>실제 앱에서 어떻게 작동하는지 살펴보자. 예를 들어, 이미지가 많은 웹 사이트가 있다고 가정하자. 홈 경로도 있고, 여러 경로를 포함하고 있는데, 각각의 경로에서 이미지를 많이 포함하고 있다. 처음 웹 사이트에 접속하면 홈 컴포넌트가 로드될 것이다. 홈 컴포넌트에는 적은 개수의 애니메이션과 이미지가 포함되어있지만 다른 경로에 있는 컴포넌트가 많은 이미지를 사용하기 때문에 홈 컴포넌트가 느리게 렌더링 될 것이다. 또 다른 컴포넌트에서는 애니메이션 몇 개를 포함할 수 도있다. 홈페이지에서 이러한 모든 컴포넌트들을 다 가져올 것이다. 이미지가 많아 무거운 페이지가 왜 느리게 렌더링하고 로드되는지 이해될 것이다. 그러나 웹 사이트의 홈페이지는 빠르게 로딩되어야 한다. 경로에 따라 컴포넌트 코드를 분할하여 로드하는 것이 이상적인 해결책이 될 것이다. 이러한 문제점을 직면할 수 있는 현실적인 예시로 인스타그램이나 핀터레스트를 들 수 있겠다.</p>\n<p>웹팩 문서에 방문해서 다른 두 가지 접근법에 관해서도 확인해보자. 동적 가져오기만으로 해결되지 않는 경우 다른 접근법이 도움이 될지 모른다. 처음 코드 스플리팅에 대해 접했던 <a href=\"https://egghead.io/lessons/vue-js-code-split-by-route-in-vuejs\">Egghead.io의 커뮤니티 리소스</a>도 방문해 보면 도움이 될 것이다.</p>\n<p>이쯤에서 글을 마치겠다. 이 글에 대한 생각과 얼마큼 도움이 되었는지 <a href=\"https://dev.to/napoleon039/what-is-code-splitting-22ni\">아래 코멘트</a>에 알려주길 바란다. 만약 질문이나 제안이 있다면 언제든지 작성해주길 바란다.</p>","frontmatter":{"id":"ko_20200128","title":"코드 스플리팅을 통해 사이트의 효율성을 높이는 방법","description":"코드 스플리팅은 코드를 다양한 청크(chunk)로 나눌 수 있으며 필요에 따라 로드할 수 있다. 페이지 렌더링에 필요한 초기 응답 크기를 줄이는데 도움이 된다. 글에서는 Vue 프로젝트에서 적절한 예시를 통해 코드 스플리팅을 알아본다.","date":"2020.01.28","author":"조정은","tags":["performance","VueJs"],"thumbnail":"https://miro.medium.com/max/1216/1*-1Sj5oc82N8fii0SMhGIwA.jpeg"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20200128","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}