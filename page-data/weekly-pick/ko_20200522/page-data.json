{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20200522","result":{"data":{"post":{"html":"<h1 id=\"webassembly에서-메모리-최대-4gb-까지-사용하기\" style=\"position:relative;\"><a href=\"#webassembly%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EB%8C%80-4gb-%EA%B9%8C%EC%A7%80-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"webassembly에서 메모리 최대 4gb 까지 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>WebAssembly에서 메모리 최대 4GB 까지 사용하기</h1>\n<blockquote>\n<p>원글: <a href=\"https://v8.dev/blog/4gb-wasm-memory\">Andreas Haas, Jakob Kummerow, and Alon Zakai - Up to 4GB of memory in WebAssembly</a>\n라이선스: <a href=\"https://creativecommons.org/licenses/by/3.0/deed.ko\">CC BY 3.0</a></p>\n</blockquote>\n<h2 id=\"소개\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EA%B0%9C\" aria-label=\"소개 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소개</h2>\n<p>Chrome과 Emscripten의 노력 덕분에, 이제 웹 어셈블리 애플리케이션에서 4GB의 메모리를 사용할 수 있게 되었다. 이전에는 2GB까지만 사용 가능했다. 메모리 사용량에 제한이 있다는 사실이 이상하게 다가오겠지만, 대부분 512MB 또는 1GB의 메모리를 사용하는 작업이 필요하지 않았다. 하지만 이번에 2GB 제한에서 4GB로 늘어나면서 브라우저와 툴 체인에 조금 특별한 일이 일어났다. 어떤 일이었는지 설명해 보겠다.</p>\n<h2 id=\"32-비트\" style=\"position:relative;\"><a href=\"#32-%EB%B9%84%ED%8A%B8\" aria-label=\"32 비트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>32 비트</h2>\n<p>시작하기 전에 알아두어야 할 내용이 하나 있는데, 새로운 4GB 메모리 제한은 32비트 포인터 환경에서 사용 가능한 용량이다. 이는 현재 웹 어셈블리가 지원하는 환경으로 LLVM등에서는 \"wasm32\"로 알려져 있다. 64비트 포인터를 사용하며 1,600만 테라바이트 이상의 메모리를 사용할 수 있는(!) \"wasm64\"(wasm 명세의 <a href=\"https://github.com/WebAssembly/memory64/blob/master/proposals/memory64/Overview.md\">\"memory64\"</a>)는 아직 진행 중이지만, 그때 까지는 4GB가 웹 어셈블리에서 사용 가능한 최대 용량이다.</p>\n<p>32비트 포인터는 원래 4GB 용량을 지원한다. 그런데, 왜 그동안 2GB밖에 사용하지 못한 것일까? 여러 이유가 있지만, 브라우저와 툴체인 모두 그럴 수밖에 없던 이유가 있다. 우선 브라우저부터 살펴보자.</p>\n<h2 id=\"chromev8의-처리\" style=\"position:relative;\"><a href=\"#chromev8%EC%9D%98-%EC%B2%98%EB%A6%AC\" aria-label=\"chromev8의 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chrome/V8의 처리</h2>\n<p>원리만을 따지고 보면 V8은 간단한 수정만 하면 될 것처럼 보인다. 웹 어셈블리 함수용으로 생성된 모든 코드와 메모리 관리 코드가 메모리 인덱스와 길이에 부호 없는 32비트 정수를 사용하는지 확인하는 것이다. 하지만 실제로는 더 많은 수정이 필요하다. 웹 어셈블리 메모리를 자바스크립트의 ArrayBuffer로 내보낼 수도 있는데, 이렇게 되면 ArrayBuffer, TypedArray를 사용하는 모든 웹 API의 구현도 변경해야 한다.</p>\n<p>우선 V8이 TypedArray 인덱스와 길이에 <a href=\"https://v8.dev/blog/pointer-compression#value-tagging-in-v8\">Sims</a>(31비트 부호 있는 정수)를 사용했기 때문에, 실상 <code class=\"tui-language-text\">(2^30)-1</code> 즉 대략 1GB 정도의 크기밖에 가지지 못했다. 게다가, 32비트 정수로 모든 것을 바꾸더라도 4GB를 저장하기엔 부족했다. 이것에 대해 부연 설명하자면 10진수로 두 자리(0부터 99까지의 정수)를 가진 수 100개가 있지만, \"100\" 자체는 3자리 숫자이다. 마찬가지로 4GB 는  32비트 주소로 처리될 수 있지만, 4GB 자체는 33비트 숫자다. 따라서 항상 가능한 크기보다 조금 더 작은 한도까지만 사용할 수 있지만, 어쨌든 모든 TypedArray 코드를 수정해야 했기 때문에 미래에 사용하게 될지 모를 더 큰 메모리 한도에 대비하기 위한 준비도 했다. 64비트 길이의 정수 타입, 혹은 자바스크립트에 필요하게 될 길이를 사용할 수 있게 TypedArray 인덱스와 길이를 처리하는 모든 코드를 수정했다. 그 작업에 대한 효과로, 지금 당장 wasm64에 더 큰 메모리를 지원할 수도 있게 되었다.</p>\n<p>두 번째 어려움은 객체의 구현 중 하나인 명명된 속성이 자바스크립트 배열 요소에 적용되었을 때의 특별 케이스를 처리하는 것이었다. (이것은 자바스크립트 명세와 관련된 기술적인 이슈로, 자세한 내용은 다 알지 않아도 괜찮다)\n다음 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span><span class=\"token number\">5_000_000_000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">array</code>가 자바스크립트 객체거나 배열이라면, <code class=\"tui-language-text\">array[5_000_000_000]</code>는 문자열 기반 속성 탐색으로 처리될 것이다. 런타임은 문자열 이름 속성 \"5000000000\"을 찾을 것이다. 해당 속성이 없다면 프로토타입 체인을 따라서 해당 속성을 찾다가 체인의 끝에서 결국 <code class=\"tui-language-text\">undefined</code>를 반환하게 될 것이다. 하지만 <code class=\"tui-language-text\">array</code>나 프로토타입 체인의 객체가 TypedArray인 경우에 런타임은 인덱스 5,000,000,000에서 인덱스 된 요소를 찾아보거나 인덱스 범위를 벗어난 경우 즉시 <code class=\"tui-language-text\">undefined</code>를 반환할 것이다.</p>\n<p>다시 말해 TypedArray의 규칙은 일반 배열과는 다르며, 그 차이는 큰 규모의 인덱스 조작에서 드러난다. 작은 TypedArray만 허용한다면 구현은 상대적으로 쉬워질 것이다. 특히 속성 키를 한 번만 살펴보면 인덱싱, 혹은 명명된 탐색을 할 것인지 결정할 수 있게 된다. 더 큰 TypedArray를 허용하려면 프로토타입 체인을 따라갈 때 반복적으로 이런 구분작업을 해야 한다. 따라서 반복적인 작업과 오버헤드로 기존 자바스크립트 코드가 느려지지 않도록 캐싱을 적절히 사용해야 한다.</p>\n<h2 id=\"툴-체인의-처리\" style=\"position:relative;\"><a href=\"#%ED%88%B4-%EC%B2%B4%EC%9D%B8%EC%9D%98-%EC%B2%98%EB%A6%AC\" aria-label=\"툴 체인의 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>툴 체인의 처리</h2>\n<p>툴 체인 측에서도 웹 어셈블리의 컴파일 된 코드뿐만 아니라 자바스크립트 지원 코드에서도 잘 동작하도록 해야 했다. 가장 큰 문제는 Emscripten이 메모리에 접근하는 코드를 항상 다음과 같이 작성한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">HEAP32[(ptr + offset) &gt;&gt; 2]</code></pre></div>\n<p>이 코드는 <code class=\"tui-language-text\">ptr + offset</code>주소에서부터 부호 있는 정수로 32비트(4바이트)를 읽는다. <code class=\"tui-language-text\">HEAP32</code>는 Int32Array로 작동한다. 따라서 각 배열의 인덱스에는 4바이트가 있다는 것을 알 수 있다. 그러므로 인덱스를 얻기 위해서는 <code class=\"tui-language-text\">ptr + offset</code>을 4로 나눌 필요가 있다.  이것이 <code class=\"tui-language-text\">&gt;&gt;2</code>가 하는 일이다.</p>\n<p><code class=\"tui-language-text\">&gt;&gt;</code>는 부호 있는 연산이라는 게 문제다! 만약 주소가 2GB보다 같거나 크다면 음수로 오버플로우 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// 2GB 미만이므로 괜찮다. 536870911이 출력된다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">-</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 2GB 초과로 -536870912가 출력된다. :(</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 때는 <code class=\"tui-language-text\">&gt;&gt;&gt;</code> 부호 없는 이동(unsigned shift)를 하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// 이제야 정상적으로 536870912가 출력된다!</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>>></span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Emscripten은 컴파일 시점에 2GB 이상의 메모리를 사용할 수 있는지 알 수 있다(컴파일 시 사용하는 플래그에 달려있다. 잠시 후에 설명할 예정). 2GB보다 큰 주소를 사용할 수 있도록 플래그를 설정했다면, 컴파일러는  <code class=\"tui-language-text\">&gt;&gt;</code> 대신 <code class=\"tui-language-text\">&gt;&gt;&gt;</code>를 사용한다. 그리고 위의 예제에서처럼 <code class=\"tui-language-text\">HEAP32</code> 뿐만 아니라 <code class=\"tui-language-text\">.subArray()</code>와 , <code class=\"tui-language-text\">.copyWithin()</code>과 같은 메모리에 접근하는 코드를 자동으로 재작성한다. 다시 말해 부호 있는 포인터가 아닌 부호 없는 포인터를 사용하도록 바꾸는 것이다.</p>\n<p>이런 전환은 코드 크기를 조금씩 키운다. 각 shift마다 한 개의 문자가 추가되는 것이다. 이게 바로 2GB보다 더 큰 메모리 주소가 필요하지 않을 때는 이런 일을 하지 않는 이유이다. 비록 늘어난 크기는 일반적으로 1%보다 더 작은 정도지만, 그 용량은 실제로는 필요하지 않은 것에 의해 늘어난 것이기도 하고, 용량이 늘어나지 않을 경우를 쉽게 파악할 수 있기 때문이다. 그리고 다수의 최적화 코드들이 추가된다.</p>\n<p>자바스크립트 지원 코드에서 드물게 이슈가 발생할 수도 있다. 일반적인 메모리 접근은 앞서 설명한 대로 자동으로 처리되지만, 부호 있는 포인터와 부호 없는 포인터(2GB보다 같거나 큰 주소의)를 수동으로 비교하는 등의 작업을 수행하면, <code class=\"tui-language-text\">false</code>를 반환한다. 이런 문제를 찾기 위해 우리는 Emscripten의 자바스크립트를  검사했으며 특정 모드에서 모든 것이 2GB 이상의 주소에 있는 상황에서 테스트 수트를 실행했다. (여러분이 자신만의 자바스크립트 지원 코드를 작성했고, 일반적인 메모리 접근이 아닌, 포인터를 사용하여 수동으로 메모리에 접근한다면 우리와 비슷한 수정이 필요할 것이다.)</p>\n<h2 id=\"실습해보기\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%8A%B5%ED%95%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"실습해보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실습해보기</h2>\n<p>테스트를 위해 <a href=\"https://emscripten.org/docs/getting_started/downloads.html\">최신 Emscripten 릴리스</a> 또는 1.39.15 이상의 버전이 필요하다. 그리고 다음과 같은 플래그를 추가해서 빌드하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">emcc -s ALLOW_MEMORY_GROWTH -s MAXIMUM_MEMORY=4GB</code></pre></div>\n<p>이렇게 하면 메모리를 늘릴 수 있다. 그리고 프로그램에서 최대 4GB에 달하는 메모리를 할당 할 수 있다. 기본적으로는 2GB까지만 할당할 수 있지만, 2~4GB의 메모리를 사용하려면 명시적으로 이렇게 옵션을 넘겨주어야 한다는 것을 알아두자. (이를 통해 위에서 언급한 <code class=\"tui-language-text\">&gt;&gt;&gt;</code> 대신 <code class=\"tui-language-text\">&gt;&gt;</code>를 사용하는 더 작은 코드를 얻을 수 있다)</p>\n<p>크롬 M83 (beta 버전) 이상에서 테스트해야 한다. 사용 중에 문제를 찾는다면 어떤 것이라도 좋으니 우리에게 보고해주길 부탁한다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>4GB 메모리 지원은 웹을 네이티브 플랫폼처럼 쓸 수 있게 해주는 하나의 단계다. 32 비트 프로그램이 본래의 용량을 정상적으로 사용할 수 있게 된 것이다. 이 단계에서는 완전히 새로운 단계의 애플리케이션으로 바뀌지 않겠지만, 방대한 게임 레벨이나 고용량 콘텐츠를 그래픽 편집기에서 수정하는 등의 고급 경험을 웹에서도 가능하게 할 수 있다.</p>\n<p>앞서 말했듯이 64비트 메모리 지원도 계획되어 있으며, 4GB 이상을 사용할 수 있다. 하지만 wasm64는 64비트 네이티브 플랫폼과 동일한 단점을 가진다. 바로 메모리를 두 배 더 소모한다는 것이다. 그래서 wasm32에서 4GB 지원이 중요한 의미를 가지는 이유이다. 이전과 같은 wasm 코드 크기를 가지고 두 배의 메모리를 사용할 수 있으니 말이다!</p>\n<p>늘 그렇듯, 여러 브라우저에서 코드를 테스트해야 한다. 그리고 2~4GB도 큰 메모리 용량인 것을 명심해야 한다! 더 많이 사용해야 한다면 어쩔 수 없지만, 모든 사용자의 컴퓨터에 메모리가 많은 것은 아니니 아껴서 사용해야 한다. 가능한 작은 초기 메모리 용량으로 시작하고 필요한 경우에 확장하는 것이 좋다. 그리고 만약 메모리가 늘어나는 옵션을 주었다면 <code class=\"tui-language-text\">malloc()</code> 실패를 우아하게 처리하자.</p>","frontmatter":{"id":"ko_20200522","title":"WebAssembly에서 메모리 최대 4GB 까지 사용하기","description":"Chrome과 Emscripten의 노력 덕분에, 이제 웹 어셈블리 애플리케이션에서 4GB의 메모리를 사용할 수 있게 되었다. 이전에는 2GB까지만 사용 가능했다. 메모리 사용량에 제한이 있다는 사실이 이상하게 다가오겠지만, 대부분 512MB 또는 1GB의 메모리를 사용하는 작업이 필요하지 않았다. 하지만 이번에 2GB 제한에서 4GB로 늘어나면서 브라우저와 툴 체인에 조금 특별한 일이 일어났다. 어떤 일이었는지 설명해 보겠다.","date":"2020.05.22","author":"박정환","tags":["WebAssembly"],"thumbnail":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20200522","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}