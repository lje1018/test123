{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20180302","result":{"data":{"post":{"html":"<h1 id=\"리액트-hoc-집중-탐구-2\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-hoc-%EC%A7%91%EC%A4%91-%ED%83%90%EA%B5%AC-2\" aria-label=\"리액트 hoc 집중 탐구 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트 HOC 집중 탐구 (2)</h1>\n<p><a href=\"/test123/weekly-pick/ko_20171117\">1부</a>에서는 HOF(Higher Order Function)의 개념부터 시작해서 HOC(Higher Order Component)의 개념이 무엇인가와 어떤 상황에 이용될 수 있는지에 대해 알아보았다. 하지만 1부의 내용만 읽어서는 HOC를 실제 프로젝트에 어떻게 활용할 수 있는지에 대한 감이 잘 잡히지 않았을 것이다.</p>\n<p>2부에서는 실제로 간단한 HOC를 만들어보고, 그 과정에서 발생할 수 있는 문제들과 이를 어떤 식으로 해결하는지, 그리고 지켜야할 컨벤션에 어떤 것들이 있는지에 대해 살펴보도록 하겠다.</p>\n<h2 id=\"기본-예제-window의-스크롤-추적하기\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%98%88%EC%A0%9C-window%EC%9D%98-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%B6%94%EC%A0%81%ED%95%98%EA%B8%B0\" aria-label=\"기본 예제 window의 스크롤 추적하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 예제: window의 스크롤 추적하기</h2>\n<p>간단한 예제로 시작해보자. 먼저 윈도우의 스크롤 위치가 변경될 때마다 해당 위치를 화면에 출력하는 컴포넌트를 만들어보겠다. 이를 위해서는 컴포넌트가 mount 될 때와 unmount 될 때 <code class=\"tui-language-text\">window</code>의 <code class=\"tui-language-text\">scroll</code> 이벤트 핸들러를 각각 등록, 해제해 주는 과정이 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">WindowScrollTracker</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    x<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    y<span class=\"token operator\">:</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">scrollHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      x<span class=\"token operator\">:</span> window<span class=\"token punctuation\">.</span>pageXOffset<span class=\"token punctuation\">,</span>\n      y<span class=\"token operator\">:</span> window<span class=\"token punctuation\">.</span>pageYOffset\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"scroll\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"scroll\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>scrollHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n        <span class=\"token constant\">X</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>좀 번거롭긴 하지만, 그리 길지 않은 코드로 간단하게 구현할 수 있다. 하지만 만약 윈도우의 스크롤 위치가 변경될 때마다 반응해야 하는 컴포넌트가 여러 개 있다면 어떨까? 이 경우 동일한 형태의 로직이 각 컴포넌트에 중복해서 들어가게 될 것이다. 이러한 로직을 보통 횡단 관심사(Cross-Cutting Concerns)라고 하는데, HOC를 활용하면 코드 중복을 효율적으로 제거할 수 있다.</p>\n<p>자, 그럼 위의 컴포넌트 코드를 활용해서 HOC를 만들어 보도록 하겠다. 무엇부터 해야 할까? 먼저 HOC의 정의가 무엇인지 다시 기억해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> compY <span class=\"token operator\">=</span> <span class=\"token constant\">HOC</span><span class=\"token punctuation\">(</span>compX<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>HOC는 컴포넌트를 인자로 받아서 새로운 컴포넌트를 반환하는 함수이다. 즉, 가장 먼저 할 일은 함수를 만드는 일이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> React<span class=\"token punctuation\">.</span>Component <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>새롭게 반환되는 컴포넌트 클래스는 <code class=\"tui-language-text\">render</code> 메소드를 제외하고는 처음에 만들었던 <code class=\"tui-language-text\">WindowScrollTracker</code>와 동일하다. <code class=\"tui-language-text\">render</code> 메소드에서는 <code class=\"tui-language-text\">withWindowScroll</code> 함수에서 인자로 받은 <code class=\"tui-language-text\">WarppedComponent</code>를 렌더링하면서, <code class=\"tui-language-text\">state</code>로 관리하고 있는 <code class=\"tui-language-text\">x</code>와 <code class=\"tui-language-text\">y</code> 정보를 props로 내려주면 된다.</p>\n<p>여기서 주의할 점은, <code class=\"tui-language-text\">x</code>, <code class=\"tui-language-text\">y</code> 외에도 <code class=\"tui-language-text\">WrappedComponent</code>가 사용하는 자신만의 props가 있을 것이므로, 해당 props도 모두 전달해 주어야 한다는 점이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> React<span class=\"token punctuation\">.</span>Component <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ... 나머지 코드는 WindowSizeTracker 와 동일</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">}</span> x<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">}</span> y<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자, 그럼 이 <code class=\"tui-language-text\">withWindowScroll</code> HOC 함수를 이용해서 처음에 만들었던 <code class=\"tui-language-text\">WindowSizeTracker</code>를 다시 정의해보자.\n기존 로직에서 <code class=\"tui-language-text\">render</code> 메소드만 남기고 모두 제거한 다음 HOC를 호출해서 새로운 컴포넌트를 정의하면 된다.\n이제 <code class=\"tui-language-text\">render</code> 메소드에서는 <code class=\"tui-language-text\">this.state</code> 대신에 <code class=\"tui-language-text\">withWindowScroll</code>통해 내려받은 props를 이용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">PositionTracker</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token constant\">X</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Y</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>y<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> WindowScrollTracker <span class=\"token operator\">=</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>PositionTracker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 만들어진 HOC는 이제 윈도우의 스크롤 위치를 반영해야 하는 어떠한 컴포넌트에도 사용될 수 있다. 예를 들어, 스크롤이 최상단에 위치할 때만 \"Top\" 이라는 문자를 화면에 출력하는 컴포넌트가 있다면 다음과 같이 간단하게 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">TopStatus</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>y <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">\"It's on Top!!\"</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> WindowScrollTopStatus <span class=\"token operator\">=</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>TopStatus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"hoc-커스터마이징-1--파라미터-추가하기\" style=\"position:relative;\"><a href=\"#hoc-%EC%BB%A4%EC%8A%A4%ED%84%B0%EB%A7%88%EC%9D%B4%EC%A7%95-1--%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\" aria-label=\"hoc 커스터마이징 1  파라미터 추가하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HOC 커스터마이징 1 : 파라미터 추가하기</h2>\n<p>이제, 위의 예제를 좀 더 발전시켜보자. 만약, <code class=\"tui-language-text\">withWindowScroll</code>를 사용하는 컴포넌트가 스크롤 이벤트를 throttle 시켜서 사용하고 싶다면 어떻게 해야 할까? 컴포넌트마다 원하는 <code class=\"tui-language-text\">wait</code> 값이 다를 수 있으므로, 추가적인 인자를 받아야만 처리할 수 있을 것이다. 그럼 두 번째 인자를 객체 형태로 받아서, 원하는 커스텀 값을 받을 수 있도록 기존 코드를 수정해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> throttle <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"lodash-es\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> wait <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> React<span class=\"token punctuation\">.</span>Component <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 나머지 코드는 동일</span>\n\n    <span class=\"token comment\">// 코드를 단순화하기 위해, wait 값이 0인 경우에도 throttle 함수를 이용하도록 하자.</span>\n    scrollHandler <span class=\"token operator\">=</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        x<span class=\"token operator\">:</span> window<span class=\"token punctuation\">.</span>pageXOffset<span class=\"token punctuation\">,</span>\n        y<span class=\"token operator\">:</span> window<span class=\"token punctuation\">.</span>pageYOffset\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">}</span> x<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">}</span> y<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제, 다음과 같이 각 컴포넌트가 원하는 throttle 값을 넘겨서 사용할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> WindowScrollTracker <span class=\"token operator\">=</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>PositionTracker<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> wait<span class=\"token operator\">:</span> <span class=\"token number\">30</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> WindowScrollTopStatus <span class=\"token operator\">=</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>TopStatus<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> wait<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"hoc-커스터마이징-2-props-mapper\" style=\"position:relative;\"><a href=\"#hoc-%EC%BB%A4%EC%8A%A4%ED%84%B0%EB%A7%88%EC%9D%B4%EC%A7%95-2-props-mapper\" aria-label=\"hoc 커스터마이징 2 props mapper permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HOC 커스터마이징 2: props mapper</h2>\n<p>현재 <code class=\"tui-language-text\">withWindowScroll</code> 함수 통해 반환되는 컴포넌트는 <code class=\"tui-language-text\">x</code>, <code class=\"tui-language-text\">y</code>를 props 로 주입받고 있다. 이 때 동일한 이름의 props를 주입시켜 주는 또 다른 HOC를 중첩해서 사용한다면 어떻게 될까? 예를 들어 마우스의 위치를 <code class=\"tui-language-text\">x</code>, <code class=\"tui-language-text\">y</code>라는 이름으로 주입시켜 주는 <code class=\"tui-language-text\">withMousePosition</code> 라는 HOC를 다음과 같이 사용한다고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> SinglePositionTracker <span class=\"token operator\">=</span> <span class=\"token function\">withMousePosition</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>PositionTracker<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 경우, <code class=\"tui-language-text\">withWindowScroll</code>을 통해 주입된 <code class=\"tui-language-text\">x</code>, <code class=\"tui-language-text\">y</code>는 <code class=\"tui-language-text\">withMousePosition</code>에서 주입되는 <code class=\"tui-language-text\">x</code>, <code class=\"tui-language-text\">y</code>에 의해 덮어씌워질 것이다.\n이렇듯, 중첩된 HOC의 props 이름이 충돌할 수 있다는 점이 HOC의 단점으로써 종종 언급되곤 하는데, 이는 mapper 함수를 제공함으로써 간단하게 해결될 수 있다.</p>\n<p>아마 많은 사람들에게 익숙할 react-redux 라이브러리의 <code class=\"tui-language-text\">connect</code> 함수에서 사용하는 <code class=\"tui-language-text\">mapStateToProps</code>을 떠올려 보면 쉽게 이해할 수 있을 것이다. <code class=\"tui-language-text\">connect</code> 함수의 역할 중 하나는 스토어에 저장된 <code class=\"tui-language-text\">state</code>를 컴포넌트로 주입시켜 주는 것인데,\n이 때 <code class=\"tui-language-text\">mapStateToProps</code> 함수를 이용해 컴포넌트가 사용하고 싶은 <code class=\"tui-language-text\">state</code>만 선택할 수 있고 원하는 props의 이름도 지정할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">mapStateToProps</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">state</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  userName<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>\n  userScore<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>score\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> ConnectedComponent <span class=\"token operator\">=</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>mapStateToProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 하면 <code class=\"tui-language-text\">MyComponent</code>에서는 전체 state 대신 <code class=\"tui-language-text\">userName</code>과 <code class=\"tui-language-text\">userScore</code> 라는 이름의 props 만을 전달받게 된다. 마찬가지 방식으로 HOC 함수를 호출할 때, 주입받고 싶은 props를 객체로 반환하는 mapper 함수를 전달할 수 있도록 하면 이름 충돌을 해결할 수 있게 된다. <code class=\"tui-language-text\">withWindowScroll</code>, <code class=\"tui-language-text\">withMousePosition</code> 함수에 이를 적용해보면 다음과 같이 사용할 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">PositionTracker</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> scrollX<span class=\"token punctuation\">,</span> scrollY<span class=\"token punctuation\">,</span> mouseX<span class=\"token punctuation\">,</span> mouseY <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      ScrollX<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>scrollX<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> ScrollY<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>scrollY<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> mouseX<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>mouseX<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> mouseY<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>mouseY<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> windowScrollOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  wait<span class=\"token operator\">:</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">mapProps</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    scrollX<span class=\"token operator\">:</span> x<span class=\"token punctuation\">,</span>\n    scrollY<span class=\"token operator\">:</span> y\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> mousePositionOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">mapProps</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    mouseX<span class=\"token operator\">:</span> x<span class=\"token punctuation\">,</span>\n    mouseY<span class=\"token operator\">:</span> y\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> EnhancedPositionTracker <span class=\"token operator\">=</span> <span class=\"token function\">withMousePotision</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>PositionTracker<span class=\"token punctuation\">,</span> windowScrollOptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  mousePositionOptions\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그럼 이제 <code class=\"tui-language-text\">withWindowScroll</code> 함수도 조금 수정해서, <code class=\"tui-language-text\">mapProps</code> 함수를 지원할 수 있도록 해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> throttle<span class=\"token punctuation\">,</span> identity <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"lodash-es\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">WrappedComponent<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> wait <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mapProps <span class=\"token operator\">=</span> identity <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> React<span class=\"token punctuation\">.</span>Component <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> passingProps <span class=\"token operator\">=</span> <span class=\"token function\">mapProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">,</span> y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>WrappedComponent <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>passingProps<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 <code class=\"tui-language-text\">mapProps</code>를 이용하면 연산을 통해 전혀 다른 데이터를 props로 전달할 수도 있다. 예를 들어 위에서 구현했던 <code class=\"tui-language-text\">TopStatus</code>의 경우 스크롤의 Y값이 0인지의 여부만 알면 되는데, 이 경우 <code class=\"tui-language-text\">mapProps</code>를 활용하면 다음과 같이 더 효율적으로 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">TopStatus</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>PureComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>isScrollOnTop <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">\"It's on Top!!\"</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> ScrollTopStatus <span class=\"token operator\">=</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>TopStatus<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  wait<span class=\"token operator\">:</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">mapProps</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    isScrollOnTop<span class=\"token operator\">:</span> y <span class=\"token operator\">===</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 코드에서 <code class=\"tui-language-text\">TopStatus</code>가 <code class=\"tui-language-text\">PureComponent</code>인 것을 볼 수 있을 것이다. 사실 <code class=\"tui-language-text\">TopStatus</code>는 스크롤 Y값이 0인지 아닌지의 여부만 확인하면 되는데, 기존 구현에서는 스크롤 값이 변경될 때마다 항상 새로운 props를 전달받기 때문에 불필요한 렌더링이 계속해서 발생하고 있었다. 변경된 코드에서는 <code class=\"tui-language-text\">isScrollOnTop</code> 값이 변경될 때에만 props로 전달받으므로, <code class=\"tui-language-text\">PureComponent</code>를 이용해 불필요한 렌더링을 방지할 수 있다.</p>\n<h2 id=\"hoc-중첩---compose\" style=\"position:relative;\"><a href=\"#hoc-%EC%A4%91%EC%B2%A9---compose\" aria-label=\"hoc 중첩   compose permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HOC 중첩 - compose</h2>\n<p>위에서 <code class=\"tui-language-text\">withMousePosition</code>와 <code class=\"tui-language-text\">withWindowScroll</code>를 중첩해서 사용하는 경우 코드를 다시 한 번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> EnhancedPositionTracker <span class=\"token operator\">=</span> <span class=\"token function\">withMousePotision</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>PositionTracker<span class=\"token punctuation\">,</span> windowScrollOptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  mousePositionOptions\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>함수의 호출과 각각의 인자값이 중첩되어 있어 한눈에 알아보기가 힘들 것이다. 만약 여기서 몇가지 HOC를 더 중첩해서 사용하게 된다면, 코드는 점점 알아보기 힘들게 된다.</p>\n<p>이러한 문제를 해결하기 위해 리액트에서는 HOC를 위한 <a href=\"https://reactjs.org/docs/higher-order-components.html#convention-maximizing-composability\">컨벤션</a>을 제안하고 있다. 컨벤션은 react-redux의 <code class=\"tui-language-text\">connect</code> 함수와 같은 형태라고 볼 수 있는데, 아래에서 볼 수 있듯이 <code class=\"tui-language-text\">connect</code> 함수는 사실 HOC가 아니고 HOC를 반환하는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// 추가 인자가 적용된 HOC를 생성한다</span>\n<span class=\"token keyword\">const</span> enhance <span class=\"token operator\">=</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  mapStateToProps<span class=\"token punctuation\">,</span>\n  mapDispatchToProps\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// HOC는 하나의 인자(컴포넌트)만 받는다.</span>\n<span class=\"token keyword\">const</span> EnhancedComponent <span class=\"token operator\">=</span> <span class=\"token function\">enhance</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>즉, HOC 함수가 항상 하나의 인자(컴포넌트)만을 받을 수 있도록 하고, 이를 위한 또다른 함수를 제공하는 것이다. 이 형식에 맞게 <code class=\"tui-language-text\">withWindowScroll</code>의 API를 변경하면 다음과 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> windowScrollOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  wait<span class=\"token operator\">:</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">mapProps</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> y <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    isScrollOnTop<span class=\"token operator\">:</span> y <span class=\"token operator\">===</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> enhance <span class=\"token operator\">=</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>windowScrollOptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> EnhancedComponent <span class=\"token operator\">=</span> <span class=\"token function\">enhance</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 모든 HOC가 하나의 동일한 인자만을 받게 되면, <code class=\"tui-language-text\">Component =&gt; Component</code> 와 같은 형식이 되므로 lodash의 <code class=\"tui-language-text\">flow</code>나 redux의 <code class=\"tui-language-text\">compose</code> 함수 등 함수의 조합을 도와주는 라이브러리를 이용해서 좀 더 우아하게 중첩된 HOC를 처리할 수 있다. 예를 들어, 기존의 중첩 HOC 예제에서 react-redux의 <code class=\"tui-language-text\">connect</code> 함수까지 더해 총 세 개의 HOC를 중첩해서 사용한다고 해 보자. 이 경우 <code class=\"tui-language-text\">compose</code> 함수를 활용한다면 다음과 같이 간결하게 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> compose <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"redux\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> connect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react-redux\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\n\n<span class=\"token keyword\">const</span> enhance <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">withMousePosition</span><span class=\"token punctuation\">(</span>mousePositionOptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span>windowScrollOptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n    mapStateProps<span class=\"token punctuation\">,</span>\n    mapDispatchToProps\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> EnhancedComponent <span class=\"token operator\">=</span> <span class=\"token function\">enhance</span><span class=\"token punctuation\">(</span>MyComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">withWindowScroll</code> 함수에서 이를 지원하는 방법은 어렵지 않다. 기존의 컴포넌트를 반환하던 로직을 함수로 한 번 더 감싸면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> wait <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mapProps <span class=\"token operator\">=</span> identity <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> React<span class=\"token punctuation\">.</span>Component <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 클래스 코드는 기존과 동일</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"디버깅---display-name\" style=\"position:relative;\"><a href=\"#%EB%94%94%EB%B2%84%EA%B9%85---display-name\" aria-label=\"디버깅   display name permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디버깅 - Display Name</h2>\n<p>마치기 전에 한 가지만 더 언급해야 할 것 같다. 어떻게 보면 HOC의 단점 중의 하나라고 볼 수 있는데, 위의 예제와 같이 코드를 작성할 경우 실제 HOC에 의해 반환되는 컴포넌트는 이름 없는 익명 컴포넌트가 된다. 이를 리액트 개발자 도구를 통해 확인해 보면 다음과 같이 보일 것이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/37006868-c988f954-211d-11e8-93ed-5aa7919babd7.png\" alt=\"devtools-before\"></p>\n<p>이처럼 <code class=\"tui-language-text\">_class3</code>, <code class=\"tui-language-text\">_class2</code> 같은 이름으로는 디버깅 할 때 어떤 컴포넌트인지 정확한 정보를 알기가 쉽지 않다. 그래서 리액트에서는 HOC에서 반환하는 컴포넌트에 대해 <code class=\"tui-language-text\">displayName</code>을 지정하도록 컨벤션을 정해놓고 있다.</p>\n<p>위의 그림에서 react-redux의 <code class=\"tui-language-text\">connect</code> 함수가 반환하는 컴포넌트는 <code class=\"tui-language-text\">Connect(_class3)</code> 라는 이름을 갖고 있는 것이 보일 것이다. 이렇게 대문자로 시작하는 HOC의 이름과 괄호 안에 적용되는 컴포넌트의 <code class=\"tui-language-text\">displayName</code> 을 합쳐서 표시하는 것이 컨벤션이다. <code class=\"tui-language-text\">withWindowScroll</code> 함수에 적용하려면 다음과 같이 작성하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// 컴포넌트의 displayName이 지정되어 있을 수도 있고, 아닌 경우도 있기 때문에</span>\n<span class=\"token comment\">// 이런 헬퍼 함수가 별도로 필요하다.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getDisplayName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> WrappedComponent<span class=\"token punctuation\">.</span>displayName <span class=\"token operator\">||</span> WrappedComponent<span class=\"token punctuation\">.</span>name <span class=\"token operator\">||</span> <span class=\"token string\">\"Component\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">withWindowScroll</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> wait <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mapProps <span class=\"token operator\">=</span> identity <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">WrappedComponent</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> React<span class=\"token punctuation\">.</span>Component <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 현재 static 필드 문법은 Stage 2 상태이다.</span>\n      <span class=\"token comment\">// 사용할 수 없는 환경에서는 외부에서 클래스의 static 멤버를 직접 지정하면 된다.</span>\n      <span class=\"token keyword\">static</span> displayName <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">WithWindowScroll(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">getDisplayName</span><span class=\"token punctuation\">(</span>\n        WrappedComponent\n      <span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// 나머지 코드는 기존과 동일</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>뭔가 코드가 좀 더 복잡해진 것 같긴 한데, 사실 이를 지키지 않아도 상관은 없다. 하지만 추후 디버깅을 쉽게 하기 위해서는 컨벤션을 따르는 것이 도움이 될 것이다. 이렇게 수정하고 나면 개발자 도구에서 다음과 같이 보이게 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/37006866-c83ac9ce-211d-11e8-8bb6-95ef5e07e28f.png\" alt=\"devtools-after\"></p>\n<h2 id=\"2부를-마치며\" style=\"position:relative;\"><a href=\"#2%EB%B6%80%EB%A5%BC-%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"2부를 마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2부를 마치며</h2>\n<p>2부에서는 간단한 HOC로 시작해서 조금씩 기능을 추가해 가면서 몇가지 기법들과 컨벤션들에 대해서 설명해 보았다.\n여기서 다룬 내용만 잘 숙지하고 있으면, 실제 프로젝트에서 HOC를 활용하는 데에 크게 문제가 없을 것이다.</p>\n<p>사실, 지금까지는 대부분 HOC를 어떻게 활용하는지와 장점에 대해서만 주로 설명했지만 HOC에는 여러가지 단점도 있다. shallow 렌더링을 중첩된 HOC를 테스트 하는 경우에도 추가적인 작업이 필요하고, <code class=\"tui-language-text\">WrappedComponent</code>의 정적 멤버들을 사용하려고 할 때에도 추가작업이 필요하며, 렌더링 시에 <code class=\"tui-language-text\">WrappedComponent</code> 에서 필요한 정보를 전달받아 처리하기도 쉽지 않다.</p>\n<p>이런 이유로 인해 최근에는 Render Props에 대한 관심이 높아지고 있는데, 얼마전 리액트 공식 홈페이지에도 <a href=\"https://reactjs.org/docs/render-props.html\">Render Props 관련 문서</a>가 추가되었다. 심지어 16.3.0에서 새롭게 변경된 <a href=\"https://github.com/acdlite/rfcs/blob/new-version-of-context/text/0000-new-version-of-context.md#basic-example\">Context API</a>가 Render Props 형식을 사용하면서 더 힘을 얻기도 했다.</p>\n<p>(관심있는 분들은 이전에 위클리에서 번역했던 글 - <a href=\"https://github.com/nhn/fe.javascript/wiki/January-1---January-5,-2018\">Render Props을 이용하자</a> - 을 읽어보면 좋을 것 같다)</p>\n<p>하지만, 개인적으로 Render Props는 단지 HOC보다 더 나은 개념이 아니며, 두 기법은 각각의 장단점을 갖고 있다고 생각한다. HOC를 적절히 잘 사용한다면 리액트에서의 중복 코드를 깔끔하게 제거할 수 있으며, 컴포넌트 조합을 통해 좀더 유연한 구조를 만들 수 있을 것이다.</p>","frontmatter":{"id":"ko_20180302","title":"리액트 HOC 집중 탐구 (2)","description":"1부에서는 HOF(Higher Order Function)의 개념부터 시작해서 HOC(Higher Order Component)의 개념이 무엇인가와 어떤 상황에 이용될 수 있는지에 대해 알아보았다. 하지만 1부의 내용만 읽어서는 HOC를 실제 프로젝트에 어떻게 활용할 수 있는지에 대한 감이 잘 잡히지 않았을 것이다. 2부에서는 실제로 간단한 HOC를 만들어보고, 그 과정에서 발생할 수 있는 문제들과 이를 어떤 식으로 해결하는지, 그리고 지켜야할 컨벤션에 어떤 것들이 있는지에 대해 살펴보도록 하겠다.","date":"2018.03.02","author":"김동우","tags":["React"],"thumbnail":"https://image.toast.com/aaaadh/real/2017/repimg/main(3)_thumbnail.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20180302","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}