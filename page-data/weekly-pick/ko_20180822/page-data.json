{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20180822","result":{"data":{"post":{"html":"<h1 id=\"뷰-컴포넌트-테스트를-위한-치트시트\" style=\"position:relative;\"><a href=\"#%EB%B7%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%B9%98%ED%8A%B8%EC%8B%9C%ED%8A%B8\" aria-label=\"뷰 컴포넌트 테스트를 위한 치트시트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뷰 컴포넌트 테스트를 위한 치트시트</h1>\n<blockquote>\n<p>원문: <a href=\"https://medium.com/3yourmind/testing-vue-components-a-cheat-sheet-299b3b8be88d\">https://medium.com/3yourmind/testing-vue-components-a-cheat-sheet-299b3b8be88d</a></p>\n</blockquote>\n<p>프론트엔드에 대한 단위 테스트를 작성하도록 요청받았을 당시에만 해도 나는 Vue 애플리케이션을 테스트하는 것에 대해 전혀 몰랐다. 그래서 vuejs 테스트에 대해 알아보고 배운 것을 공유하고 싶다. 잘하면 당신은 이 글에서 좋은 것을 골라낼 수 있을 것이다. 이 글과 관련된 모든 예제코드를 보려면 <a href=\"https://github.com/jamesoshea/vue-test-examples\">GitHub 저장소</a>를 참고하기 바란다.</p>\n<p>이 글에서는 Vue 컴포넌트 단위테스트에 대한 주제만 설명하며, 중간 및 대형 규모의 Vue앱에서 단위 테스트를 작성하는 데 필요한 사항을 요약해 보겠다. 이 글은 테스팅 철학이나 TDD / BDD의 장단점, 또는 소프트웨어 테스트 생명주기에 관한 글이 아니다. 하지만 당신이 Vue 컴포넌트에서 특정한 기능을 테스트 해야 한다면, 계속해서 읽어도 좋다.</p>\n<h2 id=\"설정하기\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"설정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설정하기</h2>\n<p>우리는 단위 테스트를 작성하는데 기본이 되는 두 가지 주요 오픈 소스 도구 <code class=\"tui-language-text\">vue-test-utils</code>와 <code class=\"tui-language-text\">Jest</code>를 사용한다. <code class=\"tui-language-text\">Jest</code>는 Facebook에서 공개한 테스트 실행 및 확인(assertion) 라이브러리이며 <code class=\"tui-language-text\">vue-test-utils</code>는 현재 Vue 팀 및 오픈 소스 커뮤니티로 부터 제공되는 공식 테스트 유틸리티 라이브러리이다.</p>\n<p>이 글을 읽고 있는 독자는 webpack(또는 유사한)을 사용하여 Vue앱을 만들고 있다고 추측된다. 내가 생각하기에 Vue를 scaffold 하기에 가장 간단한 <code class=\"tui-language-text\">webpack-simple</code> template로 초기 세팅을 시작하였다. 여기에 <code class=\"tui-language-text\">vue-test-utils</code>와 <code class=\"tui-language-text\">jest</code>의 추가가 필요하다. 터미널에서 다음을 실행해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">yarn add <span class=\"token operator\">--</span>dev @vue<span class=\"token operator\">/</span>test<span class=\"token operator\">-</span>utils jest</code></pre></div>\n<p>우리는 이제 package.json에 test script를 추가할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">”test”<span class=\"token operator\">:</span> “<span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>node_modules<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span>bin<span class=\"token operator\">/</span>jest”</code></pre></div>\n<p>우선 'test' 라는 폴더를 만들고 거기에 모든 것을 넣는 것으로 충분하다. 나중에, 좀 더 야심 찬 앱을 위한 적절한 폴더 구조를 설명하겠다. 이제 첫 번째 단위 테스트를 작성할 준비가 되었다.</p>\n<h3 id=\"첫번째-테스트\" style=\"position:relative;\"><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"첫번째 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫번째 테스트</h3>\n<p>모든 것을 일관되게 유지하기 위해, 단위테스트 명을 테스트하려는 컴포넌트 명과 동일하게 명명하자. <code class=\"tui-language-text\">Jest</code>는 기본적으로 test.js 또는 spec.js로 끝나는 파일을 찾는다. 우리의 유일한 컴포넌트는 App.vue 임으로 App.test.js 라는 파일을 만들고 신속히 테스트를 수행해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'App.vue'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'should mount for testing'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>yarn의 테스트 스크립트를 실행하면, '1 equals 1' 이라는 것을 알려주는 사랑스러운 초록 콘솔 메세지가 나타난다. 이 파일에 포함된 내용을 간단하게 알아보자.</p>\n<p>describe 함수는 실제로 테스트 중인 컴포넌트를 알려준다. 각 컴포넌트가 하나의 테스트 suite(기본적으로 하나의 컴포넌트나 유틸을 위한 테스트 그룹)를 가지고 있는 구조를 원하기 때문에 각 테스트 파일에는 이들 중 하나만 있어야 한다. describe 함수의 콜백 함수 안에는 assertion(실제테스트)를 그룹화한 test 함수들이 실행되어 테스트를 통과시킨다.</p>\n<p>예를 들어 컴포넌트 안에서 다양한 데이터를 그릴 때, 특정 엘리먼트가 어떻게 동작하는지 assertion(실제 테스트들)을 그룹화하는데 <code class=\"tui-language-text\">test</code> 함수를 사용한다. 각 테스트 파일에는 적어도 하나의 <code class=\"tui-language-text\">test</code> 블록이 필요하며, 없을 경우에는 실행되지 않는다. <code class=\"tui-language-text\">test</code> 함수에는 별칭이 존재하며, 일반적인 별칭으로 <code class=\"tui-language-text\">it</code>을 사용한다.</p>\n<p><code class=\"tui-language-text\">expect</code> 함수는 특정 상태가 true임을 나타낸다. <code class=\"tui-language-text\">Jest</code>는 엄격한 동일(toBe), 객체 동등(toEqual)과 같은 것들을 테스트하기 위해 다양한 Matchers를 제공한다. Matchers들은 너무 많은 종류가 있어서 전부 다 설명하기는 힘들며, 더 많은 것을 알고 싶다면 <a href=\"https://jestjs.io/docs/en/expect.html%EB%A5%BC\">https://jestjs.io/docs/en/expect.html를</a> 확인해보자.</p>\n<p>이상으로, Jest가 무엇인지 아주 짧게 소개했다. 현재까지는 <code class=\"tui-language-text\">vue-test-utils</code>에 관해 전혀 언급하지 않았다. <code class=\"tui-language-text\">Jest</code>를 사용하여 Vue 컴포넌트를 테스트를 시작해보자.</p>\n<h2 id=\"실제-vue-컴포넌트-테스트\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%A0%9C-vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"실제 vue 컴포넌트 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실제 Vue 컴포넌트 테스트</h2>\n<p> 나는 아주 멋진 카드 컴포넌트를 만들었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">&lt;template&gt;\n  &lt;div\n    class=&quot;vte__cool-card&quot;\n    data-test=&quot;cool-card-div&quot;\n  &gt;\n    hello I am a card :)\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &#39;CoolCard&#39;\n};\n&lt;/script&gt;\n\n&lt;style&gt;\n.vte__cool-card {\n  height: 20vh;\n  width: 40vw;\n  padding: 2rem;\n  border-radius: 1rem;\n  box-shadow: 0px 1px 1px #000;\n}\n&lt;/style&gt;</code></pre></div>\n<p>이 컴포넌트에서 주의 깊게 봐야 될 부분은 div의 <code class=\"tui-language-text\">data-test</code>에트리뷰트 단 하나이다. <code class=\"tui-language-text\">data-test</code>에트리뷰트는 나중에도 css를 리팩터링 하면서 변경되지 않으므로 테스트시 ID나 class를 대신하여 div에 액세스 할 수 있다.</p>\n<p>Vue 컴포넌트를 테스트 하기 전에 설정해야 되는 부분이 한 가지 더 있다. 우선, <code class=\"tui-language-text\">yarn add--dev babel-jest vue-jest</code> 를 실행한 후, package.json에 다음과 같이 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">  &quot;jest&quot;: {\n    &quot;moduleFileExtensions&quot;: [\n      &quot;js&quot;,\n      &quot;vue&quot;\n    ],\n    &quot;transform&quot;: {\n      &quot;^.+\\\\.js$&quot;: &quot;babel-jest&quot;,\n      &quot;.*\\\\.(vue)$&quot;: &quot;vue-jest&quot;\n    }\n  }</code></pre></div>\n<p>아래와 같은 내용의 <code class=\"tui-language-text\">.babelrc</code> 파일을 어딘가에 배치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">  &quot;env&quot;: {\n    &quot;test&quot;: {\n      &quot;plugins&quot;: [&quot;transform-es2015-modules-commonjs&quot;]\n    }\n  }</code></pre></div>\n<p>이 설정으로 <code class=\"tui-language-text\">Jest</code>는 두 가지 일을 할 수 있게 된다. 첫째로, .vue파일을 올바르게 해석한다, 그리고 import문법을 사용할 수 있게 된다 (나머지 코드베이스에서는 아마도 ES모듈을 사용할 것이지만 <code class=\"tui-language-text\">Jest</code>는 Node에서 실행됨으로 CommonJS 모듈이 사용되므로) 이제 테스트에서도 컴포넌트를 작성하는 문법과 동일한 문법을 사용할 수 있게된다. 더 많은 정보는 <a href=\"https://jestjs.io/docs/en/webpack.html#using-with-webpack-2\">jest document</a> 에서 얻을 수 있다.</p>\n<p>더 많은 설정 과정이 있었지만, 일단은 넘어가도록 하자. 아래와 같은 테스트에서 특정 컨텐츠의 존재 여부를 테스트 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">import { mount } from &#39;@vue/test-utils&#39;;\nimport CoolCard from &#39;../components/CoolCard.vue&#39;;\n\ndescribe(&#39;CoolCard&#39;, () =&gt; {\n  test(&#39;should render content correctly&#39;, () =&gt; {\n    const wrapper = mount(CoolCard);\n    expect(wrapper.find(&#39;[data-test=&quot;cool-card-div&quot;]&#39;).text()).toEqual(\n      &#39;hello I am a card :)&#39;\n    );\n  });\n});</code></pre></div>\n<p><code class=\"tui-language-text\">yarn test</code> 를 다시 실행하면, 테스트가 통과하는것을 발견할 수 있다. 이 테스트는 정말 단순한 경우이다(이런 단순한 테스트는 스냅샷 테스트로 커버할 수 있다, 이것에 대해서는 조금 후에 이야기 하겠다). 좀 더 유용하게, 약간의 변경으로 특정 테이블의 행의 개수를 테스트할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">import { mount } from &#39;@vue/test-utils&#39;;\nimport FakeComponent from &#39;../components/FakeComponent.vue&#39;;\n\ndescribe(&#39;FakeComponent&#39;, () =&gt; {\n  test(&#39;it should display the right number of table rows&#39;, () =&gt; {\n    const wrapper = mount(FakeComponent);\n    expect(\n      wrapper.findAll(&#39;[data-test=&quot;fake-table-row&quot;]&#39;).wrappers.length\n    ).toBe(2);\n  });\n});</code></pre></div>\n<p><code class=\"tui-language-text\">vue-test-utils</code> 문서의 'common tips page'는 거의 모든 Vue 관련 문서와 마찬가지로 매우 훌륭하다. 지금 읽어볼 것을 강력하게 추천한다.</p>\n<hr>\n<p>대부분의 사람들이 테스트 환경을 만들 때 테스트에 린터를 통합하는 문제에 마주치게 된다. 이것은 비교적 쉬운 문제이지만, 두 가지 주요한 접근법이 있다. 하나는 .eslintrc 파일이나 유사한 파일을 test 디렉터리에 넣는 것이고, 다른 하나는 기본 eslint 설정 파일에 덮어써서 사용하는 것이다. 필자는 첫 번째 접근법을 더 선호한다, 하지만 설정 파일이 분산되기 때문에 룰을 파악하기가 더 어려워 진다는 단점이 있다. 예제 .eslintrc파일은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">{\n  &quot;globals&quot;: {\n    &quot;jest&quot;: true,\n    &quot;expect&quot;: true,\n    &quot;mockFn&quot;: true,\n    &quot;config&quot;: true,\n    &quot;afterEach&quot;: true,\n    &quot;beforeEach&quot;: true,\n    &quot;describe&quot;: true,\n    &quot;it&quot;: true,\n    &quot;runs&quot;: true,\n    &quot;waitsFor&quot;: true,\n    &quot;pit&quot;: true,\n    &quot;require&quot;: true,\n    &quot;xdescribe&quot;: true,\n    &quot;xit&quot;: true\n  }\n}</code></pre></div>\n<p> 이 파일은 전역 변수에 대해 허용하는 것으로 표시해야 하는 목적의 린트 설정을 가지고 있다. 만약 단일 폴더 내에 모든 테스트 관련 파일을 놓길 원하지 않는다면(예를 들면 .js 파일별로 테스트 규칙을 유지하려면), 파일 이름을 기반으로 규칙을 작성할 수도 있다. 다음은 당신의 메인 .eslintrc 파일에 추가할 수 있는 간단한 예이다. <a href=\"https://eslint.org/docs/user-guide/configuring#relative-glob-patterns\">eslint 문서</a>에서 더 많은 정보를 찾을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\"> &quot;overrides&quot;: [\n   {\n     &quot;files&quot;: [ &quot;**/*.test.js&quot; ],\n     &quot;rules&quot;: {\n       &quot;quotes&quot;: [ 2, &quot;single&quot; ]\n     }\n   }\n ]</code></pre></div>\n<p>많은 사람들이 묻는 \"무엇을 테스트해야 합니까\"라는 질문은 답하기가 쉽지 않으므로 여기서는 이야기하지 않을 것이다. \"무엇을 테스트 해야 하는지\"답을 얻기에 유용할 만한 읽을거리를 글의 말미에 열거하였다. 하지만 무엇을 테스트해야 하는지 이미 알고 있다면, 다음에 소개할 패턴들이 당신에게 도움이 될 것이다.</p>\n<h3 id=\"렌더링된-html-테스트\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%9C-html-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"렌더링된 html 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링된 HTML 테스트</h3>\n<p>스냅샷 테스트는 렌더링된 HTML을 테스트하는 가장 빠른 방법이다. 테스트 비교를 위해 마운트된 컴포넌트를 미리 단순하게 직렬화하여 예기치 않은 UI변경으로부터 보호한다. <code class=\"tui-language-text\">yarn add jest-serializer-vue</code> 를 실행한 후 pacakge.json의 Jest 섹션에 한 줄을 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">  &quot;jest&quot;: {\n    &quot;moduleFileExtensions&quot;: [\n      &quot;js&quot;,\n      &quot;vue&quot;\n    ],\n    &quot;snapshotSerializers&quot;: [\n      &quot;jest-serializer-vue&quot;\n    ],\n    &quot;transform&quot;: {\n      &quot;^.+\\\\.js$&quot;: &quot;babel-jest&quot;,\n      &quot;.*\\\\.(vue)$&quot;: &quot;vue-jest&quot;\n    }\n  }</code></pre></div>\n<p>이제 매우 간단하게 스냅샷 테스트를 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">test(&#39;should render content correctly&#39;, () =&gt; {\n  const wrapper = mount(CoolCard, { store, localVue });\n  expect(wrapper.vm.$el).toMatchSnapshot();\n});</code></pre></div>\n<p>이렇게 하면 나중에 비교할 수 있도록 컴포넌트가 랜더링하는 HTML만 직렬화한다. 만약 실제로 UI가 변경되면 <code class=\"tui-language-text\">yarn test -u</code> 를 실행하여 스냅샷을 업데이트 할 수 있다. 결과 스냅샷 파일은 항상 버전 컨트롤에 의해 관리되어야 한다.</p>\n<h3 id=\"method-테스트\" style=\"position:relative;\"><a href=\"#method-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"method 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method 테스트</h3>\n<p>Method는 단위 테ì  수 있도록 컴포넌트가 랜더링하는 HTML만 직렬화한다. 만약 실제로 UI가 변경되면 <code class=\"tui-language-text\">yarn test -u</code> 를 실행하여 스냅샷을 업데이트 할 수 있다. 결과 스냅샷 파일은 항상 버전 컨트롤에 의해 관리되어야 한다.</p>\n<h3 id=\"method-테스트-1\" style=\"position:relative;\"><a href=\"#method-%ED%85%8C%EC%8A%A4%ED%8A%B8-1\" aria-label=\"method 테스트 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method 테스트</h3>\n<p>Method는 단위 테ì  수 있도록 컴포넌트가 랜더링하는 HTML만 직렬화한다. 만약 실제로 UI가 변경되면 <code class=\"tui-language-text\">yarn test -u</code> 를 실행하여 스냅샷을 업데이트 할 수 있다. 결과 스냅샷 파일은 항상 버전 컨트롤에 의해 관리되어야 한다.</p>\n<h3 id=\"method-테스트-2\" style=\"position:relative;\"><a href=\"#method-%ED%85%8C%EC%8A%A4%ED%8A%B8-2\" aria-label=\"method 테스트 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method 테스트</h3>\n<p>Method는 단위 테ì  수 있도록 컴포넌트가 랜더링하는 HTML만 직렬화한다. ë</p>\n<h3 id=\"computed-properties-테스트\" style=\"position:relative;\"><a href=\"#computed-properties-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"computed properties 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Computed Properties 테스트</h3>\n<p>Computed Properties는 암시적 입력(호출된 컨텍스트, 즉 this 또는 더 넒은 스코프 체인에 있는 다른 상태)에 의존하기 때문에 테스트 하기가 더 어렵다. 하지만 Computed Properties는 순수한 함수여야 한다는 것을 생각하여 접근하면, 출력을 테스트 하는것은 쉽다. <code class=\"tui-language-text\">wrapper.setData</code> 또는 <code class=\"tui-language-text\">wrapper.setProps</code> 메소드를 사용하여 Vue 컴포넌트에 데이터를 설정할 수 있다. 둘 다 모두 Computed Properties를 테스트 하는데 사용될수 있는 데이터 구성요소를 초기화 할 수 있다. <code class=\"tui-language-text\">setProps</code>는 이 글을쓰는 시점에서 deprecated 되었으므로 올바른 패턴은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">  test(&#39;someComputedProperty should evaluate buzzwords correctly&#39;, () =&gt; {\n    const wrapper = mount(CoolCard, {\n      propsData: {\n        wow: &#39;wow&#39;\n      }\n    });\n    wrapper.setData({\n      buzzword: &#39;Big Data&#39;\n    });\n    expect(wrapper.vm.someComputedProperty).toEqual(&#39;Big Data is very big&#39;);\n  });</code></pre></div>\n<h2 id=\"고급-보너스\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EA%B8%89-%EB%B3%B4%EB%84%88%EC%8A%A4\" aria-label=\"고급 보너스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고급 보너스</h2>\n<p> 지금까지 테스트 해본 컴포넌트는 vuex와 같은 store를 사용하지 않고 라우팅을 인식하지 않으며 다른 외부 라이브러리와 같이 사용하지도 않으므로 매우 간단했다. 하지만 좀더 복잡한 컴포넌트나 router view 안에서의 테스트는 mocked(실제를 흉내낸 모방 객체)가 필요할 수 있다.</p>\n<h3 id=\"mocking-the-route-object\" style=\"position:relative;\"><a href=\"#mocking-the-route-object\" aria-label=\"mocking the route object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mocking the $route object</h3>\n<p>router또는 더 구체적인 것을 더 쉽게 mock하는 방법은 Vue 인스턴스가 액세스 할 수 있는 route 객체를 사용하는 것이다. 예를들면 Method나 Computed Properties가 $route.path 에 접근하는 테스트의 경우, 우리는 이 프로퍼티를 가진 mock 객체를 생성하고 그 객체를 <code class=\"tui-language-text\">vue-test-util</code>가 제공하는 mount 함수의 옵션의 인자로 넘겨줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">const $route = {\n  params: {\n    id: 15,\n  },\n};\n\nconst wrapper = mount(ComplexComponent, {\n  mocks: { $route },\n});</code></pre></div>\n<h3 id=\"브라우저-apis-모방하기\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-apis-%EB%AA%A8%EB%B0%A9%ED%95%98%EA%B8%B0\" aria-label=\"브라우저 apis 모방하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 APIs 모방하기</h3>\n<p>테스트에서 브라우저 API또한 비교적 자주 mocked 되어야 한다 컴포넌트가 localStorage에 의존하는 경우 우리는 localStorage를 mocked 해야 한다. 아래와 같이 테스트 헬퍼 funcion을 사용하여 테스트를 실행하기 위해 stubbed된 기능을 제공함으로써 이 작업을 수행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">export function setGlobals() {\n  global.window.localStorage = {\n    setItem: (key, value) =&gt; null,\n      getItem: (key) =&gt; [],\n  };\n}</code></pre></div>\n<p>이제 이 helper를 필요로하는 테스트에서 import할 수 있다. 이 경우 테스트에서는 컴포넌트의 localStorage 사용을 실제로 테스트하지 않는다. 그러나 mock이 없으면 컴포넌트가 테스트를 위해 mount 되지 않으므로, 가장 기본적인 속성은 꼭 stubbed되어야 한다.</p>\n<h3 id=\"스토어-모방하기\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%86%A0%EC%96%B4-%EB%AA%A8%EB%B0%A9%ED%95%98%EA%B8%B0\" aria-label=\"스토어 모방하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스토어 모방하기</h3>\n<p>store 저장소 모방은 Vue 컴포넌트를 테스트하는데 가장 시간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된 store에서는 store 모방의 순간이 많이 걸리는 부분이다. 하지만 잘 설계된            currentTotal: () => 789\n}\n}\n}\n});\n});\ntest('card should show correct total', () => {\nconst wrapper = mount(CoolCard, { store, localVue });\nexpect(wrapper.vm.currentTotal).toEqual(789);\n});\n});</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">이 테스트는 통과한다. 하지만 조금 장황해보인다. component에서 3개 또는 4개의 모듈에 접근한다면, 테스트는 신속하게 관리하기 힘들게 되고 테스트 파일은 커질 것이다. 테스트파일에 직접 store를 moking 하는대신 추상화 하여 유틸리티로 옮겨와 사용한다면 모든 테스트에 적용할 수 있을 것이다. 또한 사용된 beforeEach 함수는, 각 테스트가 독립적이라는 것을 인지하기 전에 store가 리셋되며, 이 부분은 단위테스트의 품질에 중요한 영향을 미친다.\n\n\n\n### 스토어 모방을 위한 팩토리 함수\n\nstore 구조가 Kevin이 제안한 것과 유사 하다고 가정하고, 아래에 복잡한 컴포넌트를 mount하는데 필요한 mocked된 getter를 전부 해결할 factory 함수의 아주 작은 예제가 아래에 있다.</code></pre></div>\n<p>/* storeFactory.js */</p>\n<p>import Vue from 'vue';\nimport Vuex from 'vuex';</p>\n<p>Vue.use(Vuex);</p>\n<p>export default (getters, actions) =>\nnew Vuex.Store({\nmodules: {\nbasket: {\nnamespaced: true,\nactions,\ngetters: {\nprojectId: () => getters.basket.currentTotal || null,\ncurrentTotal: () => getters.basket.currentTotal || null\n}\n}\n}\n});</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">다음과 같이 테스트 할 수 있다.</code></pre></div>\n<p>/* usingStoreFactory.test.js */</p>\n<p>import { mount, createLocalVue } from '@vue/test-utils';\nimport Vuex from 'vuex';\nimport CoolCard from '../components/CoolCard.vue';\nimport StoreFactory from './utils/StoreFactory';</p>\n<p>const localVue = createLocalVue();\nlocalVue.use(Vuex);</p>\n<p>const actions = {\nincrementTotal: jest.fn()\n};</p>\n<p>describe('CoolCard', () => {\nlet store;\nbeforeEach(() => {\nstore = StoreFactory(\n{\nbasket: { currentTotal: 567 }\n},\nactions\n);\n});\ntest('card should show correct total', () => {\nconst wrapper = mount(CoolCard, { store, localVue });\nexpect(wrapper.vm.currentTotal).toEqual(567);\n});\n});</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">기본적으로 테스트중인 컴포넌트가 의존하는 모든 gatter에 대한 mock값을 정의하면 된다. 이 Factory 함수는 mocked되지 않은 gatter는 null을 반환함으로 완전히 재사용할 수 있다. 필요한 모든 action은 Jest의 jest.fn() mock 함수로 모방한 것이다. 이 패턴의 또다른 이점은 app이 커지고 모듈이 추가되어도 전체 모듈을 모방하는 대신 한두 줄을 추가하는 것으로 대체할 수 있다는 것이다.\n\n\n\n단점으로는 store factory 함수를 처음 작성하는데 많은 시간이 소요된다는 점이다. 현재 작업중인 모듈 7개가 있는 중간 크기의 앱의 경우 약 30분이 걸렸다, 하지만 그만한 가치가 있다고 느낀다.\n\n\n### 보너스 라운드: 테스트 구조\n\n구조에 대해 언급하고자 하는것은 명명 규칙에 관한 것이다. 우리는 모든것을 가능한 한 일관되게 유지하려고 노력해야 한다 예를 들면 SomeComponent.vue라는 컴포넌트가 있으면 해당 테스트의 이름은 항상 SomeComponent.test.js 가 되어야 한다. 이와 같은 사소한 세부 사항들은 신규 개발자들을 최대한 고통 없이 적응하도록 하며, 결국 우리 모두 승리하는 길이다.\n\n\n### 보너스 라운드 2: Nodelectric Boogavue\n\n아래의 명령어를 치고 크롬 브라우저의 chrome:inspect 를 열면 devtools 이용하여 테스트를 디버깅 할 수 있게 된다. 명령어를 Shell의 별칭으로 설정하고 사용하자.\n\n`node --inspect-brk node_modules/.bin/jest --runInBand`\n\n\n## 결론\n\n모든 사람들이 직장에서 코드 테스트를 작성하는 것을 좋아하는 것은 아니지만, `vue-test-utils` 덕분에 조금 덜 고통스러울 수 있다. 끝을 맺으며, 충분하지 못한 공간 (또는 지식) 때문에 제대로 전달하지 못한 것들을 보충할 수 있도록 몇 가지 더 많은 책을 추천하고 싶다.\n\n\n필자는 컴포넌트 중심으로 설명하였으므로 Vuex store의 테스트는 다루지 않았다. [Lachlan Miller 은 Vuex 테스트에 대해 훌륭한 글](https://codeburst.io/a-pattern-for-mocking-and-unit-testing-vuex-actions-8f6672bdb255)을 썼다. 바로 이 글을 읽어보길 추천한다.\n\n\n\n무엇을 테스트할지 아는것은 테스트 자체를 작성하는 것에 전문가가 되는 것보다 훨씬 중요하다. 이 주제에 대하여 나는 현재 [Kent C. Dodds의 블로그](https://kentcdodds.com/)를 읽고있다. 그리고 By Evan Burchard가 쓴[Refactoring Javascript](http://shop.oreilly.com/product/0636920053262.do)를 추천한다. 둘 모두 오직 가치있는 것을 테스트하는데 집중하도록 도와주었고, 처음 시작부터 좋은 테스트를 작성하는것이 얼마나 중요한지 다시 알게해줬다. `vue-test-utils`의 배후인 Edd Yerburghë¶천하고 싶다.\n\n\n필자는 컴포넌트 중심으로 설명하였으므로 Vuhttps://www.manning.com/books/testing-vuejs-applications)을 썼다. 확인해 보기 바란다.\n\n이 블로그의 글은 베를린에서 개발자를 찾고있는 나의 [3YOURMIND](https://www.3yourmind.com/) 고용주의 협력 아래에 작성하였다. 우리는 3D 프린트 분야에서 인정받고 있고 지식이 풍부한 개발자 팀을 가지고 있는 신생 기업이다. 우리는 Vue.js, Django Rest Framework, Spring, Docker등 많은 첨단 기술을 사용하며 당신을 위한 자리가 [여기](https://www.3yourmind.com/career) 있다.</code></pre></div>","frontmatter":{"id":"ko_20180822","title":"뷰 컴포넌트 테스트를 위한 치트시트","description":"프론트엔드에 대한 단위 테스트를 작성하도록 요청받았을 당시에만 해도 나는 Vue 애플리케이션을 테스트하는 것에 대해 전혀 몰랐다. 그래서 vuejs 테스트에 대해 알아보고 배운 것을 공유하고 싶다.","date":"2018.08.22","author":"김진우","tags":["VueJs"],"thumbnail":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20180822","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}