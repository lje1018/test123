{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20200728","result":{"data":{"post":{"html":"<h1 id=\"devicepixelcontentbox를-사용하여-완벽하게-픽셀pixel-perfect-렌더링하기\" style=\"position:relative;\"><a href=\"#devicepixelcontentbox%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%99%84%EB%B2%BD%ED%95%98%EA%B2%8C-%ED%94%BD%EC%85%80pixel-perfect-%EB%A0%8C%EB%8D%94%EB%A7%81%ED%95%98%EA%B8%B0\" aria-label=\"devicepixelcontentbox를 사용하여 완벽하게 픽셀pixel perfect 렌더링하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"tui-language-text\">devicePixelContentBox</code>를 사용하여 완벽하게 픽셀(pixel-perfect) 렌더링하기</h1>\n<blockquote>\n<p>원문 : <a href=\"https://web.dev/device-pixel-content-box/\">https://web.dev/device-pixel-content-box/</a>\n실제로 캔버스에는 몇 개의 픽셀이 있을까?</p>\n</blockquote>\n<p>크롬 84부터, <a href=\"https://web.dev/resize-observer/\">ResizeObserver</a>는  물리적 픽셀 단위로 요소의 크기를 측정하는 새로운 박스 측정법인 <code class=\"tui-language-text\">device-pixel-content-box</code>을 제공한다. 특히 고밀도 화면에서 픽셀 단위의 그래픽을 완벽하게 렌더링 할 수 있도록 한다.</p>\n<h2 id=\"배경-css-픽셀-캔버스-픽셀과-물리적-픽셀\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EA%B2%BD-css-%ED%94%BD%EC%85%80-%EC%BA%94%EB%B2%84%EC%8A%A4-%ED%94%BD%EC%85%80%EA%B3%BC-%EB%AC%BC%EB%A6%AC%EC%A0%81-%ED%94%BD%EC%85%80\" aria-label=\"배경 css 픽셀 캔버스 픽셀과 물리적 픽셀 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배경: CSS 픽셀, 캔버스 픽셀과 물리적 픽셀</h2>\n<p>길이를 지정할 때 <code class=\"tui-language-text\">em</code>, <code class=\"tui-language-text\">%</code>, <code class=\"tui-language-text\">vh</code>와 같은 추상적인 단위를 사용하여 작업할 때가 있는데, 이런 추상적인 값은 최종적으로 픽셀 단위로 변경된다. CSS에서 요소의 크기나 위치를 지정할 때마다 브라우저의 레이아웃 엔진은 결국 그 값을 픽셀(<code class=\"tui-language-text\">px</code>)로 변환한다. \"CSS 픽셀\"은 많은 역사를 가지고 있으며 화면상의 픽셀과 느슨한 관계(<em>loose relationship</em>)를 맺는다.</p>\n<p>오랫동안 96DPI(<em>Dots per inch</em> - 1인치당 점의 개수)로 화면 픽셀 밀도를 추정하는 것은 꽤 합리적이었데, 주어진 모니터가 1cm당 약 38픽셀을 가진다고 의미한다. 시간이 지나면서 모니터는 커지거나 축소되었고, 같은 표면적에 더 많은 픽셀을 가질 수도 있게 되었다. 웹에서 글꼴 크기를 포함하여 많은 콘텐츠가 크기를 <code class=\"tui-language-text\">px</code>로 정의할 수 있는데, 이러한 개념과 결합되면 고밀도 화면(\"HiDPI\")상에서 읽기 어려운 텍스트가 생기게 된다. 대응책으로, 브라우저는 모니터의 실제 픽셀 밀도를 숨기는 대신 사용자가 96DPI 디스플레이를 가지고 있다고 가장한다. CSS에서 <code class=\"tui-language-text\">px</code>단위\b는 가상 96DPI 디스플레이에서 하나의 픽셀 크기를 나타내므로 \"CSS 픽셀\"이라는 이름이 붙여진다. \"CSS 픽셀\" 단위는 위치와 측정용으로 사용된다. 실제 렌더링이 일어나기 전에 물리적인 픽셀로 변환된다.</p>\n<p>이렇게 가상 디스플레이에서 실제 사용자의 디스플레이로 어떻게 이동하는 것일까? <code class=\"tui-language-text\">devicePixelRatio</code>를 입력해보자. <code class=\"tui-language-text\">devicePixelRatio</code>는 전역 변수이며, 이 값은 CSS 픽셀을 구성하는데 필요한 물리적 픽셀 수를 나타낸다. 만약 <code class=\"tui-language-text\">devicePixelRatio</code>(dPR)이 <code class=\"tui-language-text\">1</code>이면, 약 96DPI 모니터로 작업 중인 게 된다. 만약 레티나 화면일 경우, dPR은 <code class=\"tui-language-text\">2</code>일 것이다. 모바일에서는 <code class=\"tui-language-text\">2</code>,  <code class=\"tui-language-text\">3</code> 또는 <code class=\"tui-language-text\">2.65</code>와 같이 더 높은 dPR 값이 나타날 수 도 있다. 이 값은 정밀한 값이긴 하지만, 모니터의 실제 DPI 값을 가져오지 못하도록 하는 것이 핵심이다. <code class=\"tui-language-text\">2</code> dPR은 1CSS 픽셀이 실제로 물리적 픽셀 2개와 대응됨(<em>mapping</em>)을 의미한다.</p>\n<hr>\n<p><span style=\"color:#3740ff\">예제</span></p>\n<p>크롬 브라우저에 의하면, 필자의 모니터는 1dPR을 가진다고 한다. 디스플레이 영역 폭이 79cm이며 3440픽셀을 가진다. 이 화면은 110DPI의 해상도이다. 96에 가깝지만, 완전히 같지는 않다. 대부분의 디스플레이에서 <code class=\"tui-language-text\">&lt;div style = &quot;width : 1cm; height : 1cm&quot;&gt;</code>가 1cm 크기를 정확하게 잴 수 없는 이유이다.</p>\n<hr>\n<p>결정적으로, dPR은 브라우저의 확대/축소 기능에 영향을 받을 수도 있다. 확대하면 브라우저가 dPR을 증가시켜 모든 것을 더 크게 렌더링한다. 브라우저를 확대/축소하는 동안 개발자 도구 콘솔에서 <code class=\"tui-language-text\">devicePixelRatio</code>를 입력해보면 변경된 값이 보인다.</p>\n<div style=\"text-align: center;\">\n<img src=\"https://webdev.imgix.net/device-pixel-content-box/dprs.png\" width=\"600\">\n<figcaption style=\"font-size: 11px\">개발자 도구에서 브라우저를 줌하는 동안  'devicePixelRatio'를 확인해보면 분수형 값을 확인할 수 있다.</figcaption>\n</div>\n<p><code class=\"tui-language-text\">&lt;canvas&gt;</code> 요소에 <code class=\"tui-language-text\">width</code>와 <code class=\"tui-language-text\">height</code> 속성을 사용하여 원하는 픽셀 수를 지정할 수 있다. <code class=\"tui-language-text\">&lt;canvas width=40 height=30&gt;</code>은 40 x 30 픽셀의 캔버스가 될 것이다. 그러나 40 x 30 픽셀로 <em>표시되는</em> 것은 아니다. 기본적으로 캔버스는 <code class=\"tui-language-text\">width</code>와 <code class=\"tui-language-text\">height</code> 속성을 사용하여 고유한 크기를 정의하지만, CSS 속성을 사용하여 캔버스의 크기를 임의로 재조정할 수 있다. 지금까지 배운 모든 것을 가지고, 모든 시나리오에서 적합한 것은 아니다. 캔버스에서 하나의 픽셀이 여러 개의 물리적 픽셀을 덮을 수도 있으며 물리적인 픽셀을 일부만 덮을 수 있다. 이는 시각적으로 부드럽지 않은 결과물이 보여질 수 있다.</p>\n<p>요약하면,</p>\n<ul>\n<li>캔버스 요소에는 그려질 수 있는 영역을 정의하기 위한 크기를 지정해 줄 수 있다.</li>\n<li>캔버스 픽셀 수는 CSS 픽셀로 지정된 캔버스의 디스플레이 크기와 완전히 독립적으로 동작한다.</li>\n<li>CSS 픽셀 수는 물리적인 픽셀 수와 같지 않다.</li>\n</ul>\n<h3 id=\"픽셀-완성도\" style=\"position:relative;\"><a href=\"#%ED%94%BD%EC%85%80-%EC%99%84%EC%84%B1%EB%8F%84\" aria-label=\"픽셀 완성도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>픽셀 완성도</h3>\n<p>일부 시나리오에서는 캔버스 픽셀에서 물리적 픽셀로 정확하게 매핑하는 것이 바람직할 수도 있다. 이 매핑이 완벽하게 매칭되는 경우를 \"픽셀-퍼펙트\"라고 한다. 픽셀-퍼펙트 렌더링은 텍스트를 읽기 쉽게 렌더링하는데 중요하며, 특히 <a href=\"https://en.wikipedia.org/wiki/Subpixel_rendering\">서브 픽셀 렌더링</a>을 사용하거나 명도를 번갈아 바꿔가며 빽빽하게 정렬된 선을 표현할 때 더욱 중요하다.</p>\n<p>아래 코드는 웹에서 픽셀-퍼펙트에 가까운 캔버스를 만들기 위해 자주 사용되는 방법 중에 하나이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"tui-language-html\"><code class=\"tui-language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style\"><span class=\"token language-css\">\n  <span class=\"token comment\">/* … styles that affect the canvas' size … */</span>\n</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>canvas</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>myCanvas<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>canvas</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script\"><span class=\"token language-javascript\">\n  <span class=\"token keyword\">const</span> cvs <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#myCanvas'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 캔버스의 CSS 픽셀 크기를 가져오기</span>\n  <span class=\"token keyword\">const</span> rectangle <span class=\"token operator\">=</span> cvs<span class=\"token punctuation\">.</span><span class=\"token function\">getBoundingClientRect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 실제 픽셀로 변환</span>\n  cvs<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> rectangle<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> devicePixelRatio<span class=\"token punctuation\">;</span>\n  cvs<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> rectangle<span class=\"token punctuation\">.</span>height <span class=\"token operator\">*</span> devicePixelRatio<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 그리기 시작...</span>\n</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>똑똑한 독자들은 dPR이 정수가 아닐 때 어떻게 동작되는지 궁금할 것이다. 좋은 질문이며 전체 문제의 중요한 핵심이다.  요소의 위치나 크기를 지정할 때 <code class=\"tui-language-text\">%</code>, <code class=\"tui-language-text\">vh</code> 또는 정확한 픽셀값이 아닌 간접적으로 계산된 값을 사용하면 분수형 CSS 픽셀값이 설정될 수 있다. <code class=\"tui-language-text\">margin-left: 33%</code>인 요소의 사각형 정보는 아래와 같다.</p>\n<div style=\"text-align: center;\">\n<img src=\"https://webdev.imgix.net/device-pixel-content-box/fractional-pixels.png\" width=\"600\">\n<figcaption style=\"font-size: 11px\">개발자 도구에서 'getBoundingClientRect()'을 호출한 결과이다. 분수형 픽셀 값들을 볼 수 있다.</figcaption>\n</div>\n<p>CSS 픽셀은 가상의 값이기 때문에, 이론적으로 분수 값을 가져도 된다. 그러나 브라우저는 이에 대응하는 물리적 픽셀을 어떻게 알아낼까? <em>물리적</em> 픽셀은 분수 값으로 존재할 수 없는데 말이다.</p>\n<h2 id=\"픽셀-스냅\" style=\"position:relative;\"><a href=\"#%ED%94%BD%EC%85%80-%EC%8A%A4%EB%83%85\" aria-label=\"픽셀 스냅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>픽셀 스냅</h2>\n<p>물리적 픽셀로 엘리먼트의 정렬을 맞추기 위해 단위를 변환하는 프로세스를 \"픽셀 스냅(pixel snapping)\"이라고 하며, \"픽셀 스냅\"은 이름 그대로 분수형 픽셀값을 정수형 물리적 픽셀값으로 스냅 한다는 의미이다. 어떻게 정확히 이런 일이 일어나는지는 브라우저마다 다르다. dPR이 1인 디스플레이에 폭이 <code class=\"tui-language-text\">791.984px</code>인 요소가 있으면 어떤 브라우저는 <code class=\"tui-language-text\">792px</code>의 물리적 픽셀로 렌더링하고 다른 브라우저는 <code class=\"tui-language-text\">791px</code>로 렌더링할 수 있다. 단지 1px 차이지만, 단일 픽셀이 완벽한 픽셀 렌더링(픽셀-퍼펙트)을 해야하는 상황에서 해로울 수 있다. 흐릿하게 보여지거나 무아레(<em>Moiré</em>) 효과같은 시각적인 결과물(<em>visual artifact</em>)이 나올 수 있다.</p>\n<div style=\"text-align: center;\">\n<img src=\"https://webdev.imgix.net/device-pixel-content-box/side-by-side.png\" width=\"600\">\n<figcaption style=\"font-size: 11px\">상단 이미지는 다른 색의 픽셀의 래스터다. 하단 이미지는 위와 동일하지만 양선형(*bilinear*) 스케일링을 이용해 너비와 높이가 1픽셀 줄었다. 이 새로운 패턴을 무아레 효과라고 한다.\n(이미지를 확장하지 않고 보려면 새 탭에서 열어야함)</figcaption>\n</div>\n<h2 id=\"devicepixelcontentbox\" style=\"position:relative;\"><a href=\"#devicepixelcontentbox\" aria-label=\"devicepixelcontentbox permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"tui-language-text\">devicePixelContentBox</code></h2>\n<p><code class=\"tui-language-text\">devicePixelContentBox</code>는 디바이스의 픽셀(예. 물리적인 픽셀) 단위에서 요소의 컨텐트 박스 정보를 준다. <code class=\"tui-language-text\">ResizeObserver</code>에 포함되어 지원된다. <a href=\"https://caniuse.com/#feat=resizeobserver\">ResizeObserver는 Safari 13.1 이후 모든 주요 브라우저에서 지원</a>되지만 <code class=\"tui-language-text\">devicePixelContentBox</code> 속성은 현재 Chrome 84 이상에만 있다.</p>\n<p><a href=\"https://web.dev/resize-observer/\"><code class=\"tui-language-text\">ResizeObserver</code>대한 게시글</a>에서 언급했듯이 요소의 <code class=\"tui-language-text\">document.onresize</code>와 마찬가지로 <code class=\"tui-language-text\">ResizeObserver</code>의 콜백 함수는 <em>페인트</em> 전과 <em>레이아웃</em> 후에 호출된다. 즉, 콜백에 넘겨지는 <code class=\"tui-language-text\">entries</code> 매개 변수는 페인트 하기 직전에 관찰된 모든 요소의 크기 정보가 포함된다. 위에서 설명한 캔버스 문제와 관련하여 캔버스의 픽셀 수를 보정하고 캔버스 픽셀과 실제 픽셀 간의 정확한 일대일 매핑을 보장할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> observer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResizeObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entries</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entry <span class=\"token operator\">=</span> entries<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entry</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> entry<span class=\"token punctuation\">.</span>target <span class=\"token operator\">===</span> canvas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  canvas<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">.</span>devicePixelContentBoxSize<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>inlineSize<span class=\"token punctuation\">;</span>\n  canvas<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">.</span>devicePixelContentBoxSize<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>blockSize<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">/* 캔버스 렌더링 */</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobserver<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>canvas<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>box<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'device-pixel-content-box'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">observer.observe()</code>의 옵션 객체의 <code class=\"tui-language-text\">box</code> 속성은 <em>관찰</em>하는 요소의 크기를 정의하도록 한다. 따라서 각 <code class=\"tui-language-text\">ResizeObserverEntry</code>는 항상 <code class=\"tui-language-text\">borderBoxSize</code>, <code class=\"tui-language-text\">contentBoxSize</code> 및 <code class=\"tui-language-text\">devicePixelContentBoxSize</code>(브라우저가 지원하는 경우)를 전달하며, <em>관찰중인(</em>observed<em>)</em> 박스 매트릭스의 변경이 감지되었을 때만 콜백이 호출된다.</p>\n<hr style=\"border-top: 1px solid #3740ff;\">\n<p><span style=\"color:#3740ff\">★ 모든 박스 매트릭스는 <code class=\"tui-language-text\">ResizeObserver</code>가 향후 단편화(<em>fragmentation</em>)를 처리할 수 있도록 지원하는 배열이다. 이 글을 작성하는 시점에서 배열 길이는 항상 1이다.</span></p>\n<p>새로운 속성 <code class=\"tui-language-text\">devicePixelContentBoxSize</code>로 캔버스의 크기와 위치(효과적으로 분수형 픽셀값을 보장함)까지 애니메이션을 만들 수 있고 렌더링에 미치는 무아레 현상은 더 이상 볼 수 없다. <code class=\"tui-language-text\">getBoundingClientRect()</code>를 사용하여 재현한 무아레 현상과 새로운 <code class=\"tui-language-text\">ResizeObserver</code> 속성을 사용하여 이를 해결한 현상을 보고 싶다면 Chrome 84 이상에서 <a href=\"https://device-pixel-content-box.glitch.me/\">데모</a>를 확인해보자!</p>\n<h3 id=\"기능-탐지\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%8A%A5-%ED%83%90%EC%A7%80\" aria-label=\"기능 탐지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기능 탐지</h3>\n<p>사용자의 브라우저에서 <code class=\"tui-language-text\">devicePixelContentBox</code>를 지원하는지 확인하려면 요소를 관찰하여 <code class=\"tui-language-text\">ResizeObserverEntry</code>에 <code class=\"tui-language-text\">devicePixelContentBox</code> 속성이 있는지 확인하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">hasDevicePixelContentBox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> ro <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResizeObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entries</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>entries<span class=\"token punctuation\">.</span><span class=\"token function\">every</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entry</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">'devicePixelContentBoxSize'</span> <span class=\"token keyword\">in</span> entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      ro<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ro<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>box<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'device-pixel-content-box'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">hasDevicePixelContentBox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 브라우저가 devicePixelContentBox를 지원하지 않음</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>픽셀은 웹에서 의외로 복잡한 주제이며 이전에는 사용자 화면에서 요소가 차지하는 물리적 픽셀 수를 정확히 알 방법이 없었다. <code class=\"tui-language-text\">ResizeObserverEntry</code>에 있는 새로운 <code class=\"tui-language-text\">devicePixelContentBox</code> 속성을 통해 그 정보를 알 수 있으며, <code class=\"tui-language-text\">&lt;canvas&gt;</code>를 사용하여 픽셀 단위까지 완벽한 렌더링을 할 수 있게 되었다. <code class=\"tui-language-text\">devicePixelContentBox</code>는 크롬 84이상에서 지원한다.</p>","frontmatter":{"id":"ko_20200728","title":"devicePixelContentBox를 사용하여 완벽하게 픽셀(pixel-perfect) 렌더링하기","description":"픽셀은 웹에서 의외로 복잡한 주제이다. 이제 ResizeObserverEntry에 있는 새로운 devicePixelContentBox 속성을 통해 그 정보를 알 수 있으며, <canvas>를 사용하여 픽셀 단위까지 완벽한 렌더링을 할 수 있게 되었다.","date":"2020.07.28","author":"조정은","tags":["browser","etc"],"thumbnail":"https://webdev.imgix.net/device-pixel-content-box/pixels.jpg?auto=format&fit=max&w=1959"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20200728","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}