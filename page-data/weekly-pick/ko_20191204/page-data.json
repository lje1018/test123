{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20191204","result":{"data":{"post":{"html":"<h1 id=\"반응형-시스템-개선하기feat-toast-ui-grid\" style=\"position:relative;\"><a href=\"#%EB%B0%98%EC%9D%91%ED%98%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0feat-toast-ui-grid\" aria-label=\"반응형 시스템 개선하기feat toast ui grid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>반응형 시스템 개선하기(feat. TOAST UI Grid)</h1>\n<p><a href=\"https://github.com/nhn/tui.grid\">TOAST UI Grid</a>는 자체적인 반응형 시스템을 구축하여 데이터의 상태 관리를 하고 있다. 데이터가 변경되면 반응형 시스템이 변경을 감지하고 있는 다른 데이터 속성들도 자동으로 갱신해주기 때문에 데이터의 변경 관리를 편리하게 할 수 있었고, 간결하면서도 선언적인 코드를 사용할 수 있어 불필요한 코드도 줄일 수 있었다. 하지만 대용량 데이터를 반응형 데이터로 변경할 때 치명적인 성능 문제가 있었고, 그리드의 초기 렌더링 속도 저하를 유발했다(10만개의 데이터를 기준으로 초기 렌더링에 약 2.5초정도의 시간이 소요되었다). 이 글은 <strong>대용량 데이터에 대한 반응형 시스템의 성능 이슈 해결</strong>을 위해 그 동안 도입했던 방법들과 고민했던 점들을 실제 소스 코드와 함께 설명하는 내용이다(반응형 시스템의 개념과 동작 원리에 대해서는 이 글에서 자세히 다루지 않는다. 이 부분에 대해 알고 싶다면 <a href=\"https://ui.toast.com/weekly-pick/ko_20190531/\">0.7KB로 Vue와 같은 반응형 시스템 만들기</a>를 꼭 먼저 읽어보길 바란다).</p>\n<h2 id=\"lazy-observable\" style=\"position:relative;\"><a href=\"#lazy-observable\" aria-label=\"lazy observable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lazy Observable</h2>\n<p><strong>lazy observable</strong>은 <em>반응형 데이터를 실제로 필요한 경우에만 실시간으로 생성해준다</em>는 의미이다. 글의 서두에서 이야기했듯이 대용량 배열 데이터 전체를 반응형 데이터로 생성하는 것은 생각보다 매우 큰 비용이 드는 작업이었고, 이로 인해 그리드의 초기 렌더링 성능이 급격하게 저하되었다. 문제를 해결하기 위해 반응형 데이터 생성에 소요되는 시간을 줄이는 법을 계속 고민하였고, <em>초기에 전체 데이터를 반응형 데이터로 변경하지 않고 객체 범위를 한정하여 필요할 때마다 변경하는 건 어떨까?</em> 란 생각을 하게 되었다. 그리고 최종적으로 반응형 데이터로 변경할 객체의 범위를 <strong>화면에서 보이는 데이터(스크롤 영역내의 데이터)</strong> 로 한정하여 lazy observable을 적용해보자는 결론을 얻을 수 있었다.</p>\n<p>lazy observable에 대한 이해를 돕기 위해 그리드의 예시 이미지와 함께 설명하겠다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/37766175/70106895-3a6ff300-1688-11ea-8342-585088166b0d.gif\" alt=\"images\"></p>\n<p>위 이미지는 <strong>10만개</strong>의 대용량 데이터를 TOAST UI Grid에서 렌더링한 것이다. 이런 경우 모든 데이터가 반응형 데이터로 생성될 필요가 있을까? 실제로 필요한 데이터는 스크롤 영역내에 보이는 한정적인 데이터다. 그렇다면 스크롤 영역내 렌더링에 필요한 데이터 객체들만 반응형 데이터로 만들고 보이지 않는 데이터는 일반적인 객체 상태 그대로 유지하는 것이 훨씬 효율적일 것이다. 이것이 바로 lazy observable의 개념이다(그리드는 스크롤 영역을 기준으로 데이터를 한정했지만, 이 기준은 어플리케이션마다 다를 것이다).</p>\n<p>그럼 이제부터 TOAST UI Grid에서는 어떻게 구현하였는지 코드를 살펴보자.</p>\n<h3 id=\"1-반응형-데이터로-변경할-객체들의-목록을-구한다\" style=\"position:relative;\"><a href=\"#1-%EB%B0%98%EC%9D%91%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%A0-%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EB%AA%A9%EB%A1%9D%EC%9D%84-%EA%B5%AC%ED%95%9C%EB%8B%A4\" aria-label=\"1 반응형 데이터로 변경할 객체들의 목록을 구한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 반응형 데이터로 변경할 객체들의 목록을 구한다.</h3>\n<p>가장 먼저 해야 할 일은 배열 데이터에서 <strong>화면에 보여줄 데이터(반응형 데이터로 변경할 객체)의 범위</strong>를 구하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createOriginData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">,</span> rowRange</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> rowRange<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span>gridRows<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">acc<span class=\"token punctuation\">,</span> row<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 이미 반응형 데이터인 경우는 포함시키지 않는다.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isObservable</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        acc<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        acc<span class=\"token punctuation\">.</span>targetIndexes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">return</span> acc<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      rows<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      targetIndexes<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TOAST UI Grid에서는 <code class=\"tui-language-text\">createOriginData</code> 함수를 실행하여 반응형 데이터로 변경할 객체의 범위를 구한다. 화면에 보이는 로우 범위에 대한 정보를 가지고 있는 <code class=\"tui-language-text\">rowRange</code>를 이용하여 전체 데이터(<code class=\"tui-language-text\">data.gridRows</code>)를 기준으로 반응형 데이터로 변경되어야 하는 row 객체와 index 정보를 반환한다. 단, 이미 객체가 반응형 데이터인 경우는 새롭게 생성될 필요가 없기때문에 <a href=\"https://github.com/nhn/tui.grid/blob/73441b33b294c093e3eaf53f016f10de58b068f8/packages/toast-ui.grid/src/helper/observable.ts#L100\">isObservable</a> 함수를 이용하여 처리하였다.</p>\n<h3 id=\"2-원본-데이터를-반응형-데이터로-변경한다\" style=\"position:relative;\"><a href=\"#2-%EC%9B%90%EB%B3%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B0%98%EC%9D%91%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%9C%EB%8B%A4\" aria-label=\"2 원본 데이터를 반응형 데이터로 변경한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 원본 데이터를 반응형 데이터로 변경한다.</h3>\n<p>원본 데이터는 반응형 데이터가 아니기 때문에 데이터의 변화를 감지하여 자동으로 갱신할 수 없다. 그러므로 이제 변경이 필요한 객체들의 정보를 이용하여 원본 데이터를 반응형 데이터로 변경해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createObservableData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> viewport <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> originData <span class=\"token operator\">=</span> <span class=\"token function\">createOriginData</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> viewport<span class=\"token punctuation\">.</span>rowRange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>originData<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">changeToObservableData</span><span class=\"token punctuation\">(</span>column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> originData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">changeToObservableData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> originData</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> targetIndexes<span class=\"token punctuation\">,</span> rows <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 반응형 데이터 생성</span>\n  <span class=\"token keyword\">const</span> gridRows <span class=\"token operator\">=</span> <span class=\"token function\">createData</span><span class=\"token punctuation\">(</span>rows<span class=\"token punctuation\">,</span> column<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> gridRows<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> index <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> targetIndex <span class=\"token operator\">=</span> targetIndexes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token punctuation\">.</span>gridRows<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>targetIndex<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> gridRows<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"tui-language-text\">changeToObservableData</code> 함수에서는 <code class=\"tui-language-text\">originData</code>(<code class=\"tui-language-text\">createOriginData</code> 함수의 결과)를 이용하여 <code class=\"tui-language-text\">gridRows</code>라는 반응형 데이터를 만든다. 그리고 기존 데이터(<code class=\"tui-language-text\">data.gridRows</code>)를 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\">splice</a> 메서드를 이용하여 새로 생성된 반응형 데이터로 변경한다.</p>\n<h3 id=\"3-렌더링-범위-변화-감지\" style=\"position:relative;\"><a href=\"#3-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B2%94%EC%9C%84-%EB%B3%80%ED%99%94-%EA%B0%90%EC%A7%80\" aria-label=\"3 렌더링 범위 변화 감지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 렌더링 범위 변화 감지</h3>\n<p>마지막으로 해야 할 일은 렌더링된 데이터의 범위가 변경될 때, 즉, <strong>스크롤을 이동하는 경우를 감지하여 자동으로 해당 범위의 데이터를 반응형 데이터로 변경해주는 작업</strong>을 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">createObservableData</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">createObservableData</code> 함수를 <code class=\"tui-language-text\">observe</code> 하면, 함수 내부에서 사용하는 <code class=\"tui-language-text\">rowRange</code>나 <code class=\"tui-language-text\">gridRaws</code> 등이 변경될 때마다 자동으로 재실행되어 반응형 데이터가 아닌 데이터를 동적으로 변경시켜 준다. 우리는 이미 <a href=\"https://github.com/nhn/tui.grid/blob/73441b33b294c093e3eaf53f016f10de58b068f8/packages/toast-ui.grid/src/helper/observable.ts#L104\">observe</a> 함수를 구현했었기 때문에 위 코드처럼 단 1줄의 코드로 이 부분을 자동화할 수 있었다.</p>\n<p>완성된 코드를 살펴보자(실제 코드는 <a href=\"https://github.com/nhn/tui.grid/blob/73441b33b294c093e3eaf53f016f10de58b068f8/packages/toast-ui.grid/src/dispatch/data.ts#L721\">여기</a>서 확인해볼 수 있다).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">/**\n * 반응형 데이터로 변경할 객체들의 목록을 구한다.\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createOriginData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">,</span> rowRange</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> rowRange<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span>gridRows<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">acc<span class=\"token punctuation\">,</span> row<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 이미 반응형 데이터인 경우는 포함시키지 않는다.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isObservable</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        acc<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        acc<span class=\"token punctuation\">.</span>targetIndexes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">return</span> acc<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n      rows<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      targetIndexes<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * 원본 데이터를 반응형 데이터로 변경한다.\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">changeToObservableData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> originData</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> targetIndexes<span class=\"token punctuation\">,</span> rows <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 반응형 데이터 생성</span>\n  <span class=\"token keyword\">const</span> gridRows <span class=\"token operator\">=</span> <span class=\"token function\">createData</span><span class=\"token punctuation\">(</span>rows<span class=\"token punctuation\">,</span> column<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> gridRows<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> index <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> targetIndex <span class=\"token operator\">=</span> targetIndexes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token punctuation\">.</span>gridRows<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>targetIndex<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> gridRows<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createObservableData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> viewport <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> originData <span class=\"token operator\">=</span> <span class=\"token function\">createOriginData</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> viewport<span class=\"token punctuation\">.</span>rowRange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>originData<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">changeToObservableData</span><span class=\"token punctuation\">(</span>column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> originData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * 렌더링 범위 변화를 감지하여 자동으로 반응형 데이터가 아닌 데이터를 동적으로 변경시켜 준다.\n */</span>\n<span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">createObservableData</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실제 10만개의 데이터를 기준으로 lazy observable을 적용하기 전과 후 그리드의 초기 렌더링 속도는 <code class=\"tui-language-text\">2357ms</code>, <code class=\"tui-language-text\">99ms</code> 로 무려 <strong>23배</strong> 정도의 속도 차이가 났다.</p>\n<p>대용량 데이터를 다루는 어플리케이션에서 반응형 시스템을 사용하고 있다면, 반응형 데이터 생성의 최적화 방법에 대해 반드시 고려해야한다.\n생각보다 반응형 데이터의 생성 비용이 크다는 점을 명심하자.</p>\n<h2 id=\"batch-processing\" style=\"position:relative;\"><a href=\"#batch-processing\" aria-label=\"batch processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Batch Processing</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Batch_processing\">batch processing</a>은 대량 반복 작업이나 데이터 변경에 대한 작업을 효율적으로 처리하기 위해 널리 사용되는 방법이다. 일괄 작업 처리를 위한 방법으로 우리는 <em>반응형 시스템에서 한 개의 데이터 업데이트로 인해 연쇄되는 작업</em>들을 하나의 <strong>batch의 단위</strong>로 묶어 한번에 처리했다. </p>\n<p>batch processing을 반응형 시스템에 적용했을 때 어떤 장점이 있는지 간단하게 알아보자.🤔</p>\n<h3 id=\"업데이트-작업의-효율적인-관리\" style=\"position:relative;\"><a href=\"#%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%9E%91%EC%97%85%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EA%B4%80%EB%A6%AC\" aria-label=\"업데이트 작업의 효율적인 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>업데이트 작업의 효율적인 관리</h3>\n<p>반응형 시스템에서 특정한 데이터가 변경되면 데이터를 감지하고 있는 다른 데이터 속성과 계산된(computed) 속성들도 연쇄적으로 변경된다. 만약 데이터의 업데이트가 화면의 <a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en\">레이아웃</a> 작업이나 <a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en\">리페인팅</a> 작업을 유발한다면, 매 업데이트마다 개별적으로 수행하는 것보다는 하나의 작업 단위로 묶어 불필요한 렌더링을 유발하는 업데이트를 제거하는 방법이 더 효율적일 것이다.</p>\n<h3 id=\"중복된-업데이트-제거\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%A0%9C%EA%B1%B0\" aria-label=\"중복된 업데이트 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중복된 업데이트 제거</h3>\n<p>반응형 시스템의 단점이 있다면, 하나의 업데이트로 인해 파생되는 업데이트 중 중복된 작업이 있어도 쉽게 알아차리기 힘들고 개선하기 힘들다는 점이다. 하지만 업데이트 작업을 batch 단위로 묶어 작업하게 된다면, 적어도 batch 단위별로는 중복된 업데이트를 제거할 수 있다(batch 단위의 정의는 도입부에서 설명하였다).</p>\n<p>그럼 이제부터는 TOAST UI Grid의 실제 batch processing 구현을 보며 설명해보겠다(여기서 observe 함수의 자세한 구현은 다루지 않을 것이며 batch processing의 구현만 중점적으로 볼 것이다. observe 함수의 구현이 궁금하다면 <a href=\"https://github.com/nhn/tui.grid/blob/73441b33b294c093e3eaf53f016f10de58b068f8/packages/toast-ui.grid/src/helper/observable.ts#L104\">여기</a>를 참조바란다).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">callObserver</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">observerId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  observerIdStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  observerInfoMap<span class=\"token punctuation\">[</span>observerId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  observerIdStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">observerId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">callObserver</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// do something</span>\n  <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 기존 <code class=\"tui-language-text\">observe</code> 함수의 예시이다. <code class=\"tui-language-text\">observe</code> 함수가 호출되면 먼저 실행 순서를 관리하기 위해 <code class=\"tui-language-text\">observerId</code>를 내부적으로 관리하는 스택(<code class=\"tui-language-text\">observerIdStack</code>)에 쌓는다. 그리고 observer 함수를 실행한다. 이 과정에서 스택의 최상단에 있는 <code class=\"tui-language-text\">observerId</code>와 관련된 또 다른 observer 함수들이 호출되어 스택에 쌓일 것이며, 연관 작업들이 모두 끝나면 스택에서 해당 <code class=\"tui-language-text\">observerId</code>를 순차적으로 제거한다.</p>\n<p>여기에 batch processing을 적용하여 하나의 작업 단위로 묶어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> observerIdMap <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">batchUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">observerId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>observerIdMap<span class=\"token punctuation\">[</span>observerId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    observerIdMap<span class=\"token punctuation\">[</span>observerId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">observerId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">batchUpdate</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>변경된 코드를 보면 <code class=\"tui-language-text\">run</code> 함수에서 observer 함수를 바로 실행하는 것이 아니라, <code class=\"tui-language-text\">batchUpdate</code> 함수를 호출하여 <code class=\"tui-language-text\">queue</code>에 <code class=\"tui-language-text\">observerId</code> 를 넣고 있다. 즉, <strong><code class=\"tui-language-text\">queue</code>를 하나의 batch 단위</strong>로 볼 수 있다. 그리고 여기서 눈여겨 볼 점은 <code class=\"tui-language-text\">observerIdMap</code>이란 객체를 이용하여 이미 <code class=\"tui-language-text\">queue</code>에 들어간 <code class=\"tui-language-text\">observerId</code> 는 중복해서 넣지 않도록 처리하고 있는 것이다. 이 한 줄의 코드로 중복된 업데이트를 방지할 수 있다.</p>\n<p><code class=\"tui-language-text\">queue</code>에 담긴 observer 함수들을 실행하는 <code class=\"tui-language-text\">flush</code>란 함수를 만들어 아래처럼 최종 코드를 완성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> observerIdMap <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> pending <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">batchUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">observerId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>observerIdMap<span class=\"token punctuation\">[</span>observerId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    observerIdMap<span class=\"token punctuation\">[</span>observerId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pending<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">callObserver</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">observerId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  observerIdStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  observerInfoMap<span class=\"token punctuation\">[</span>observerId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  observerIdStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">clearQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  observerIdMap <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  pending <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  pending <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> observerId <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    observerIdMap<span class=\"token punctuation\">[</span>observerId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">callObserver</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">clearQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"tui-language-text\">batchUpdate</code> 함수가 실행되면 <code class=\"tui-language-text\">pending</code> 이란 변수를 보고 <code class=\"tui-language-text\">flush</code> 함수를 실행한다. 만약 동일한 batch 내에서 이미 <code class=\"tui-language-text\">flush</code> 함수가 실행 중인 경우(<code class=\"tui-language-text\">pending</code> 변수의 값이 <code class=\"tui-language-text\">true</code>)에는 <code class=\"tui-language-text\">queue</code>에 <code class=\"tui-language-text\">observerId</code> 만 넣어주고 <code class=\"tui-language-text\">flush</code> 함수는 실행하지 않는다. 이 부분이 중요하다. 파생된 업데이트들이 누락되지 않고 모두 올바르게 실행되려면, pending 상태일 때도 <code class=\"tui-language-text\">observerId</code> 를 <code class=\"tui-language-text\">queue</code>에 넣어야 한다. 그리고 <code class=\"tui-language-text\">flush</code> 함수내의 for문에서는 동적으로 증가되는 <code class=\"tui-language-text\">queue</code>의 길이를 반영하여 observer 함수들을 실행한다.</p>\n<p>사실 최근 많이 사용하고 있는 프레임워크 또는 라이브러리(<a href=\"https://reactjs.org/\">React</a>, <a href=\"https://vuejs.org/\">Vue</a>, <a href=\"https://preactjs.com/\">Preact</a> 등)에서 이미 DOM 렌더링과 관련된 최적화를 해주고 있다. 하지만 batch processing 을 추가하면 렌더링 최적화 이전에 불필요한 연산을 방지할 수 있다.</p>\n<h2 id=\"monkey-patch-array\" style=\"position:relative;\"><a href=\"#monkey-patch-array\" aria-label=\"monkey patch array permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Monkey Patch Array</h2>\n<p>TOAST UI Grid는 배열 데이터를 반응형 데이터로 생성하지 않고 있다. 앞서 설명했듯이 반응형 데이터의 생성 비용은 생각보다 크고, 배열이 클 경우 이런 작업은 매우 부담되기 때문이다.\n기존 TOAST UI Grid에서는 배열 데이터의 갱신이 필요할 때마다 <a href=\"https://github.com/nhn/tui.grid/blob/cdd4a0335a9fc27564432c84556617cc9ffbd78c/packages/toast-ui.grid/src/helper/observable.ts#L186\">notify</a> 란 함수를 직접 호출하여 배열의 속성과 연관된 observe 함수들을 강제로 호출하도록 처리하고 있었다. 초기에는 <code class=\"tui-language-text\">notify</code> 함수만으로 문제가 없었으나, 새로운 기능을 추가할 수록 <code class=\"tui-language-text\">notify</code> 함수를 호출하는 중복 코드가 많아지는 문제가 생겼다. 중복 코드가 많다는 것은 코드의 품질이 떨어진다는 의미이기도 하다. 우리는 코드 품질 향상을 위해 <code class=\"tui-language-text\">notify</code> 함수 호출 없이 배열 데이터와 관련된 observe 함수들을 자동으로 호출하는 방법에 대해 고민하였다. 그리고 <a href=\"https://en.wikipedia.org/wiki/Monkey_patch\">monkey patch</a> 방법을 활용하여 문제를 해결해보고자 했다(monkey patch는 특정 객체의 속성이나 메서드를 동적으로 변경한다는 의미로 자세한 설명은 링크를 참조바란다).</p>\n<p>이제 monkey patch을 활용하여 어떻게 문제를 개선하였는지 살펴보자(TOAST UI Grid의 소스 코드와 함께🤓).</p>\n<h3 id=\"1-monkey-patch를-적용하기-전-배열-데이터-갱신-코드\" style=\"position:relative;\"><a href=\"#1-monkey-patch%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84-%EB%B0%B0%EC%97%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%B1%EC%8B%A0-%EC%BD%94%EB%93%9C\" aria-label=\"1 monkey patch를 적용하기 전 배열 데이터 갱신 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. monkey patch를 적용하기 전 배열 데이터 갱신 코드</h3>\n<p>TOAST UI Grid는 갱신해야하는 배열 데이터가 많아질 수록 관련된 observe 함수들을 호출하기 위해 <code class=\"tui-language-text\">notify</code> 함수를 실행한다. 아래 예시 코드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">appendRow</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">store<span class=\"token punctuation\">,</span> row</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// do something</span>\n  rawData<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>at<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> rawRow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  viewData<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>at<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> viewRow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  heights<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>at<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getRowHeight</span><span class=\"token punctuation\">(</span>rawRow<span class=\"token punctuation\">,</span> dimension<span class=\"token punctuation\">.</span>rowHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// notify 호출 부분</span>\n  <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token string\">'rawData'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token string\">'viewData'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token string\">'filteredRawData'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token string\">'filteredViewData'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span>rowCoords<span class=\"token punctuation\">,</span> <span class=\"token string\">'heights'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 보자마자 <code class=\"tui-language-text\">notify</code> 함수 호출이 반복된다는 것을 느낄 것이다. 성능에는 전혀 문제가 없지만 코드가 중복되고 있으며, <code class=\"tui-language-text\">appendRow</code> 같이 여러 배열 데이터의 변경이 있는 함수가 많아질 수록 중복 코드는 더 추가될 것이다.</p>\n<h3 id=\"2-배열-메서드를-랩핑하는-monkey-patch-코드\" style=\"position:relative;\"><a href=\"#2-%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EB%9E%A9%ED%95%91%ED%95%98%EB%8A%94-monkey-patch-%EC%BD%94%EB%93%9C\" aria-label=\"2 배열 메서드를 랩핑하는 monkey patch 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 배열 메서드를 랩핑하는 monkey patch 코드</h3>\n<p>monkey patch의 대상은 <em>배열 데이터</em>이며, 목적은 <em>배열 데이터의 갱신을 자동으로 감지하고 관련된 observe 함수를 실행되도록 하는 것</em>이다. 그러므로 배열 데이터의 갱신을 발생시키는 특정 메서드들(<code class=\"tui-language-text\">splice</code>, <code class=\"tui-language-text\">push</code>, <code class=\"tui-language-text\">pop</code> 등)만 랩핑 대상이 되며, 이외에 단순 조회나 새로운 배열 객체를 반환하는 메서드들에 대해서는 작업을 할 필요가 없다.</p>\n<p>갱신을 일으키는 메서드들을 어떻게 랩핑했는지 코드와 함께 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> methods <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'splice'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'push'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pop'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'shift'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'unshift'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'sort'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">patchArrayMethods</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">,</span> key</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  methods<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">method</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> patchedMethods <span class=\"token operator\">=</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">[</span>method<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 기존 메서드들을 patch 함수로 monkey patch 한다.</span>\n    arr<span class=\"token punctuation\">[</span>method<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">patch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">patchedMethods</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"tui-language-text\">patchArrayMethods</code> 함수 내부의 반복문에는 배열의 데이터를 갱신한 후 자동으로 <code class=\"tui-language-text\">notify</code> 함수를 호출하는 <code class=\"tui-language-text\">patch</code> 함수가 선언되어 있다. 그리고 미리 정의한 <code class=\"tui-language-text\">methods</code> 변수를 이용하여 배열(<code class=\"tui-language-text\">arr</code>)의 속성을 <code class=\"tui-language-text\">patch</code> 함수로 monkey patch 하는 작업을 하고 있다.\n<code class=\"tui-language-text\">Array.prototype</code>을 직접 조작하여 변경해도 되지만 다른 어플리케이션에 의도치 않은 버그와 사이드 이펙트를 발생시킬 수 있기 때문에 이 방법보다는 각각의 배열 객체를 대상으로 monkey patch 하는 방법을 선택했다.</p>\n<h3 id=\"3-배열-메서드를-랩핑하는-monkey-patch-코드\" style=\"position:relative;\"><a href=\"#3-%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EB%9E%A9%ED%95%91%ED%95%98%EB%8A%94-monkey-patch-%EC%BD%94%EB%93%9C\" aria-label=\"3 배열 메서드를 랩핑하는 monkey patch 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 배열 메서드를 랩핑하는 monkey patch 코드</h3>\n<p>이제 monkey patch을 적용한 코드를 보며 어떤 변화가 있었는지 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">storage<span class=\"token punctuation\">,</span> resultObj<span class=\"token punctuation\">,</span> observerIdSet<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>storage<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">patchArrayMethods</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> resultObj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    storage<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>observerIdSet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">observerId</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>observerId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">observable</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// do something</span>\n\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">key</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do something</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isFunction</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token function\">getter</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>resultObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>storage<span class=\"token punctuation\">,</span> resultObj<span class=\"token punctuation\">,</span> observerIdSet<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      storage<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>storage<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">patchArrayMethods</span><span class=\"token punctuation\">(</span>storage<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> resultObj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>resultObj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>storage<span class=\"token punctuation\">,</span> resultObj<span class=\"token punctuation\">,</span> observerIdSet<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> resultObj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">appendRow</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">store<span class=\"token punctuation\">,</span> row</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// do something</span>\n  rawData<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>at<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> rawRow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  viewData<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>at<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> viewRow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  heights<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>at<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getRowHeight</span><span class=\"token punctuation\">(</span>rawRow<span class=\"token punctuation\">,</span> dimension<span class=\"token punctuation\">.</span>rowHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드처럼 <code class=\"tui-language-text\">observable</code> 함수에서 반응형 데이터의 속성 타입이 배열인 경우 <code class=\"tui-language-text\">patchArrayMethods</code>를 호출하여 배열의 메서드를 랩핑한다면, 해당 배열 데이터가 갱신될 때 자동으로 연관된 observe 함수가 호출된다(observable 함수의 전체 소스코드는 <a href=\"https://github.com/nhn/tui.grid/blob/73441b33b294c093e3eaf53f016f10de58b068f8/packages/toast-ui.grid/src/helper/observable.ts#L118\">여기</a>서 확인할 수 있다). 강제적으로 observe 함수를 실행하기 위해 <code class=\"tui-language-text\">notify</code> 함수를 호출할 필요가 없어진 것이다. <code class=\"tui-language-text\">appendRow</code> 함수를 보면 중복되는 <code class=\"tui-language-text\">notify</code> 함수가 모두 제거되고 훨씬 깔끔하게 수정된 것을 볼 수 있다.</p>\n<p>TOAST UI Grid에서 반응형 시스템에 monkey patch를 적용한 이유와 방법을 간단하게 설명하였고, 코드와 함께 적용 과정을 보았다. 중복된 코드를 제거하여 훨씬 깔끔한 코드로 리팩토링할 수 있었고, 코드의 품질도 향상되었다.</p>\n<h2 id=\"-정리\" style=\"position:relative;\"><a href=\"#-%EC%A0%95%EB%A6%AC\" aria-label=\" 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📝 정리</h2>\n<p>lazy observable 에서 설명했던 코드를 기준으로 앞의 내용들을 정리해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">changeToObservableData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> originData</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> targetIndexes<span class=\"token punctuation\">,</span> rows <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 반응형 데이터 생성</span>\n  <span class=\"token keyword\">const</span> gridRows <span class=\"token operator\">=</span> <span class=\"token function\">createData</span><span class=\"token punctuation\">(</span>rows<span class=\"token punctuation\">,</span> column<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> gridRows<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> index <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> targetIndex <span class=\"token operator\">=</span> targetIndexes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token punctuation\">.</span>gridRows<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>targetIndex<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> gridRows<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createObservableData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> viewport <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> originData <span class=\"token operator\">=</span> <span class=\"token function\">createOriginData</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> viewport<span class=\"token punctuation\">.</span>rowRange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>originData<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">changeToObservableData</span><span class=\"token punctuation\">(</span>column<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> originData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">createObservableData</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>다시 한 번 간략하게 설명하자면, 위의 코드는 스크롤이 이동할 때, 화면 렌더링에 필요한 데이터를 반응형 데이터로 갱신해주는 코드이다.</p>\n<p>위 코드에서 반복문 코드를 자세히 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> gridRows<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> index <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> targetIndex <span class=\"token operator\">=</span> targetIndexes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  data<span class=\"token punctuation\">.</span>gridRows<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>targetIndex<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> gridRows<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리드 내에서 배열 데이터는 반응형 데이터로 만들지 않았기 때문에 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\">splice</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push\">push</a>와 같은 함수로 데이터를 갱신하여도 <code class=\"tui-language-text\">notify</code>와 같은 함수를 호출하지 않으면 업데이트가 발생하지 않는다. 눈치가 빠른 사람들은 여기서 어떤 이야기가 나올지 이미 예상하였을 것이다. Monkey Patching Array에서 봤듯이 배열 메서드를 랩핑하였기 때문에 자동으로 업데이트가 발생된다.</p>\n<p>그럼 여기서 한가지 의문점이 생길 수 있다. for문 안에서 <code class=\"tui-language-text\">splice</code> 메서드 호출로 인해 매번 배열 데이터가 갱신되고 파생된 업데이트가 실행되면 문제가 있지 않을까?\n걱정하지 않아도 된다. batch processing을 구현했기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">createObservableData</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>반응형 데이터를 생성(<code class=\"tui-language-text\">createObservableData</code>)해주는 함수가 <code class=\"tui-language-text\">observe</code> 함수 내에서 호출된다. 즉, for문내에서 파생되는 업데이트들은 모두 하나의 batch 작업 단위로 묶이게 되므로, 반복문마다 매번 즉각적으로 갱신이 되거나, 중복된 업데이트들은 발생하지 않는다.</p>\n<p>앞에서는 각각의 방법들의 내용과 어떤 장점이 있는지 설명하였다면, 이번에는 전체적인 흐름이 어떻게 되는지 간단하게 살펴보았다. 이 외에도 설명에서 생략된 코드들을 보고 싶다면 <a href=\"https://github.com/nhn/tui.grid/tree/master/packages/toast-ui.grid/src\">github</a>에서 확인할 수 있다.</p>\n<h2 id=\"주의할-점\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"주의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>❗주의할 점</h2>\n<p>반응형 시스템은 매우 편리하다. observe 함수를 이용해 자동으로 데이터와 뷰(View) 갱신을 해준다. 그러나 이런 편리함에 익숙해져 매번 갱신될 필요가 없는 데이터까지 반응형 데이터로 등록하여 개발을 하는 경우가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token function\">observable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  start<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  end<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">expensiveCalculation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>end<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ... do expensive calculation</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nobj<span class=\"token punctuation\">.</span>start <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span>end <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 예제에서 <code class=\"tui-language-text\">expensiveCalculation</code> 라는 매우 복잡한 연산을 수행하는 계산된(computed) 속성이 반응형 데이터로 생성된다고 가정해보자. 이 속성은 <code class=\"tui-language-text\">start</code> 또는 <code class=\"tui-language-text\">end</code> 속성이 변경될 때마다 복잡한 연산을 동반하며, 자동으로 갱신되어야 한다. 이런 경우 <code class=\"tui-language-text\">expensiveCalculation</code>이 매번 갱신될 만큼 자주 쓰이는 속성인지 생각해봐야한다. 그렇지 않다면 <code class=\"tui-language-text\">expensiveCalculation</code>이 필요한 경우에만 별도의 함수로 분리하여 호출하는 것이 훨씬 효율적일 수 있다.</p>\n<p>사실 당연한 내용이지만, 개발 초기에 생각보다 이 부분을 놓치고 반응형 시스템의 편리함에 기대어 시작하는 경우가 있다. 필자도 그러한 경험이 있었고 나중에서야 이 부분을 변경했던 기억이 있다.</p>\n<p>대가없는 편리함은 없다. 항상 이 부분을 염두하고 개발하자.</p>\n<h2 id=\"-맺음말\" style=\"position:relative;\"><a href=\"#-%EB%A7%BA%EC%9D%8C%EB%A7%90\" aria-label=\" 맺음말 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎀 맺음말</h2>\n<p>TOAST UI Grid처럼 대용량 데이터를 다루는 어플리케이션에서 성능은 매우 중요한 부분이다. 성능에 영향을 미치는 요인과 개선 방안은 여러가지가 있겠지만, 우리는 반응형 시스템의 성능 개선을 중점적으로 보았다. 그리고 최적화를 위한 세 가지 방법들을 실제 TOAST UI Grid의 적용 코드와 함께 살펴보았다. 이 방법들은 그리드에만 국한된 방법들이 아니며, 반응형 시스템 개선을 위해 어디든 적용 가능한 방법들이다. 이 글이 반응형 시스템 개선을 위해 고민하고 있거나 혹은 반응형 시스템에 대해 좀 더 깊게 이해하고 싶은 사람들에게 도움이 되었으면 한다.</p>\n<p>TOAST UI Grid는 v4 메이저 배포 이후에도, 다양한 기능 추가와 성능 이슈 해결을 위한 많은 변화가 있었다. 앞으로도 TOAST UI Grid는 많은 사람들이 유용하게 사용할 수 있도록 더 나아갈 것이니 관심 가져주길 바란다. 만약 문의 사항이나 바라는 점이 있다면 <a href=\"https://github.com/nhn/tui.grid/issues\">github issue</a>에 남겨주길 바란다.</p>\n<p>그리고 마지막으로 좋은 어플리케이션을 만들기 위해 항상 같이 고민하며 도움을 준 팀원들에게 감사함을 표한다.😎</p>","frontmatter":{"id":"ko_20191204","title":"반응형 시스템 개선하기(feat. TOAST UI Grid)","description":"TOAST UI Grid는 자체적인 반응형 시스템을 구축하여 데이터의 상태 관리를 하고 있다. 데이터가 변경되면 반응형 시스템이 변경을 감지하고 있는 다른 데이터 속성들도 자동으로 갱신해주기 때문에 데이터의 변경 관리를 편리하게 할 수 있었고, 간결하면서도 선언적인 코드를 사용할 수 있어 불필요한 코드도 줄일 수 있었다. 하지만 대용량 데이터를 반응형 데이터로 변경할 때 치명적인 성능 문제가 있었고, 그리드의 초기 렌더링 속도 저하를 유발했다","date":"2019.12.04","author":"이재성","tags":["opensource","performance","architecture"],"thumbnail":"https://user-images.githubusercontent.com/37766175/70294697-b3598100-1827-11ea-8bd8-9500aa200490.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20191204","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}