{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20161007","result":{"data":{"post":{"html":"<h1 id=\"angular2\" style=\"position:relative;\"><a href=\"#angular2\" aria-label=\"angular2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Angular2</h1>\n<p>FE-Weekly-Pick에서는 최근에 팀내에서 진행했던 스터디 내용을 정리하는 의미에서, 4회에 걸쳐 자바스크립트 (프론트엔드) 프레임워크를 소개하는 시리즈를 연재할 예정입니다. 아래와 같은 목차로 진행되니 많은 관심 부탁드립니다.</p>\n<ol>\n<li>Cycle.js</li>\n<li><strong>Angular 2</strong></li>\n<li>Vue.js</li>\n<li>React</li>\n</ol>\n<h2 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h2>\n<ol>\n<li>소개</li>\n<li>개발환경</li>\n<li>아키텍쳐</li>\n<li>테스트</li>\n<li>성능</li>\n<li>정리</li>\n</ol>\n<h2 id=\"소개\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EA%B0%9C\" aria-label=\"소개 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소개</h2>\n<p>Angular는 확장된 HTML 문법을 기반으로 하는 웹 애플리케이션 프레임워크로 개발되었다. 데이터 바인딩, 템플릿 문법 등과 같은 편리한 기능을 제공하여 웹 애플리케이션의 유지 보수, 개발 속도를 크게 향상했으며, 수많은 개발자에게 큰 인기를 얻고 있다. 또 그들의 커뮤니티 또한 많이 발달해 있어, 발전이 기대되는 프레임워크(혹은 플랫폼)로 손꼽힌다.</p>\n<h3 id=\"framework-to-platform\" style=\"position:relative;\"><a href=\"#framework-to-platform\" aria-label=\"framework to platform permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Framework to Platform</h3>\n<p>이제 더는 \"AngularJS\"가 아니다. \"Angular\"다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260279/7f1afc6a-8fc3-11e6-8c41-c33d95f4df0f.png\" alt=\"angular2-is-not-angularjs\"><br>\n(<a href=\"https://AngularJS.org\">https://AngularJS.org</a>)</p>\n<p>\"AngularJS 1\"은 웹앱 개발 생산성에 중점을 두었지만, \"Angular 2\"부터는 생산성은 물론, 여러 플랫폼에 맞춤형 개발을 할 수 있도록 개발의 범위를 확장하는 것에도 중점을 두고 있다.\n<img src=\"https://cloud.githubusercontent.com/assets/12269563/19260285/7f3c6c9c-8fc3-11e6-884e-185c0715234b.png\" alt=\"develop-across-all-platforms\"><br>\n(<a href=\"https://angular.io\">https://angular.io</a>)</p>\n<p>실제로 <a href=\"https://www.ng-conf.org/\">ng-conf</a>의 비디오 자료들을 통해 Angular2의 웹 개발, 테스트, 모바일-프로그레시브 웹 앱, 서버 렌더링, 네이티브 앱, 머티리얼 디자인, 써드파티 프로그램 등 Angular2의 플랫폼을 간접적으로나마 경험할 수 있다.</p>\n<h3 id=\"typescript\" style=\"position:relative;\"><a href=\"#typescript\" aria-label=\"typescript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript</h3>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260286/7f528cfc-8fc3-11e6-8116-1251a1b1df5e.png\" alt=\"javascript-in-typescript\">\n<br>\n(<a href=\"https://docs.google.com/presentation/d/1ctVafwlb8tZFYe0q_RZoLse9hU8mZzW9HhZoUBuHhAE/edit?usp=sharing\">TypeScript: Angular 2's Secret Weapon</a>)</p>\n<p>Angular2는 기존의 JavaScript가 아닌 TypeScript를 주 언어로 권장하고 있다. 처음 접해보는 TypeScript에 대해 부담감을 느낄 수 있지만, JavaScript를 잘 이해하고 있다면 TypeScript에 대한 학습은 어렵지 않을 것이다.</p>\n<p>TypeScript는 JavaScript의 확장 언어로 모든 JavaScript 문법을 포용한다. 때문에 <code class=\"tui-language-text\">js</code>에서 <code class=\"tui-language-text\">ts</code>로 확장자만 변경해도 문제없이 동작한다. TypeScript의 확장된 언어적 기능으로 사용자는 편리한 코드 툴링 기능을 사용할 수 있고, 개발 생산성도 크게 향상될 것이다. TypeScript <a href=\"https://www.typescriptlang.org/\">공식 홈페이지</a>에서 더 자세한 기능과 설명을 확인할 수 있다.</p>\n<br>\n## 개발 환경\n<p>개발 프레임워크를 도입할 때 개발 환경을 갖추는 것부터 하나의 큰 장벽처럼 느껴진다. 빌드 툴, 빌드 설정, 정적분석기(Linter), 트랜스파일러(Transpiler), 테스트 환경, 배포, 디버깅 등 갖춰야 할 환경이 너무 많다. 실제로 Angular2(이하 Angular) 프로젝트를 시작할 때 가장 큰 허들이 무엇인가에 대한 설문조사에 '개발 환경 세팅'이 26%로 1위를 차지했다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260287/7f56937e-8fc3-11e6-9c8d-cb4279a555d1.png\" alt=\"largest-barrier\">\n<br>\n(<a href=\"https://twitter.com/Brocco/status/713374344823640064\">https://twitter.com/Brocco/status/713374344823640064</a>)</p>\n<p>손수 개발환경을 준비하고 단순한 \"app works!\" 문구라도 브라우저에 나타내 보려면 다음과 같은 과정을 진행해야 한다.</p>\n<ol>\n<li>NPM 패키지 설정과 디펜던시 - package.json 작성</li>\n<li>\n<p>타입스크립트</p>\n<ol>\n<li>tsconfig.json 작성</li>\n<li>typgins.json 작성</li>\n<li>tslint.json 작성</li>\n</ol>\n</li>\n<li>모듈러/번들러 설정 (SystemJS 또는 Wepback, ...)</li>\n<li>패키지 설치</li>\n<li>폴더 구조 생성, 루트 모듈, 루트 컴포넌트, main(entry) 스크립트 작성</li>\n<li>index.html 작성</li>\n<li>npm start</li>\n<li>+ 테스트 환경 설정 (Karma, Jasmine, Protractor, ...)</li>\n</ol>\n<p>그런데 위와 같은 반복되는 설정과 패키지 설치를 3~4번의 command만으로 쉽게 처리할 수 있다면 편하지 않을까?\n바로 <a href=\"https://cli.angular.io/\">Angular CLI</a>가 그 역할을 해주는 도구다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260278/7ef91a14-8fc3-11e6-869b-908248e758a1.png\" alt=\"angular-cli\"><br>\n(<a href=\"https://cli.angular.io/\">https://cli.angular.io/</a>)</p>\n<p>Angular-CLI는 <a href=\"http://yeoman.io/\">Yeoman</a>과 유사한 프로그램으로, 초기 개발 환경 스캐폴딩 기능을 제공하며, 이 외에도 컴포넌트 추가/제거, 테스트, 빌드, 추가 라이브러리 등록 등 거의 모든 기반을 함께 제공한다. 이런 기능으로 우리는 쉽고 빠르게 애플리케이션을 개발할 수 있다. 1~2분이면 기본적인 개발 환경을 모두 구성하고 실제로 \"app works!\"를 브라우저에 나타내는 마법을 부릴 수 있다.</p>\n<h3 id=\"브라우저-지원범위\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A7%80%EC%9B%90%EB%B2%94%EC%9C%84\" aria-label=\"브라우저 지원범위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 지원범위</h3>\n<p>IE9 이상의 넓은 브라우저 지원 범위를 가지고 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Chrome</th>\n<th>Firefox</th>\n<th>Edge</th>\n<th>IE</th>\n<th>Safari</th>\n<th>iOS</th>\n<th>Android</th>\n<th>IE mobile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>latest</td>\n<td>latest</td>\n<td>14</td>\n<td>11</td>\n<td>10</td>\n<td>10</td>\n<td>Marshmallow (6.0)</td>\n<td>11</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>13</td>\n<td>10</td>\n<td>9</td>\n<td>9</td>\n<td>Lollipop (5.0, 5.1)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>9</td>\n<td>8</td>\n<td>8</td>\n<td>KitKat (4.4)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>7</td>\n<td>7</td>\n<td>Jellybean (4.1, 4.2, 4.3)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>(<a href=\"https://angular.io/docs/ts/latest/guide/browser-support.html\">https://angular.io/docs/ts/latest/guide/browser-support.html</a>)</p>\n<br>\n## 아키텍처\n<p>Angular 애플리케이션은 기본적으로 템플릿과 프로퍼티(데이터)/이벤트 바인딩으로 동작한다. 이런 템플릿과 바인딩, 애플리케이션 로직을 합쳐 화면의 부분 부분을 구성하는 컴포넌트(<a href=\"https://angular.io/docs/ts/latest/guide/architecture.html#!#components\">Component</a>)라 부른다.</p>\n<p>또 Angular는 <a href=\"https://angular.io/docs/ts/latest/guide/architecture.html#!#modules\">NgModules</a>라 부르는 모듈 시스템을 가지고 있다. 모든 Angular 애플리케이션은 최소 1개 이상의 모듈을 가지고 있으며, 관례상 루트 모듈은 'AppModule'이라 부르며, 이 루트 모듈로 Bootstrapping을 수행하여 애플리케이션을 런칭한다. 이런 모듈 시스템으로 애플리케이션을 기능, 도메인 등에 따라 조직화 하고 각각에 필요한 Angular의 컴포넌트, 서비스, 지시자(Directives) 등을 통합하여 관리한다. 때문에 중복 코드를 피하거나 모듈의 <a href=\"https://angular.io/docs/ts/latest/guide/ngmodule.html#!#lazy-load\">지연 로딩(Lazy loading)</a>등의 이점을 살릴 수 있다.</p>\n<p>모듈 시스템과 같이 이 글에서 자세히 설명하지 못한 내용은 <a href=\"https://angular.io/docs/ts/latest/guide/\">가이드 문서</a>를 통해 폭넓게 파악할 수 있으니 Angular 개발을 시작한다면 꼭 읽어보길 추천한다.</p>\n<h3 id=\"컴포넌트component\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8component\" aria-label=\"컴포넌트component permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트(Component)</h3>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260280/7f2e399c-8fc3-11e6-801e-bfa3f6c57a9e.png\" alt=\"architecture-overview\">\n<br>\n(<a href=\"https://angular.io/docs/ts/latest/guide/architecture.html\">https://angular.io/docs/ts/latest/guide/architecture.html</a>)</p>\n<p>Angular에서 가장 중요한 부분이 바로 컴포넌트다. 컴포넌트는 화면을 구성하기 위한 하나의 단위다. 기본적으로 템플릿 + 메타데이터 + (컴포넌트)클래스 조합으로 구성하고 애플리케이션 로직을 정의한다. 템플릿은 기존에 우리가 알고 있는 HTML이다. 여기에 Angular만의 <a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\">템플릿 문법(Syntax)</a>을 추가하여 데이터나 이벤트를 바인딩한다. 그리고 메타데이터를 통해 단순한 클래스를 템플릿과 함께 연결시키며 Angular에게 컴포넌트로 등록한다. Angular는 이 데이터를 가지고 컴파일도 하고 실제 객체도 만들면서 렌더링을 한다. 그리고 이런 컴포넌트들은 각각 자신의 <a href=\"https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html\">생명주기(Lifecycle)</a>를 가지고 있어서 Hook을 통해 더 정교하고 세밀한 동작을 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// app.component.ts</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@angular/core\"</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Metadata</span>\n  selector<span class=\"token operator\">:</span> <span class=\"token string\">\"app-root\"</span><span class=\"token punctuation\">,</span>\n  templateUrl<span class=\"token operator\">:</span> <span class=\"token string\">\"./app.component.html\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// Template</span>\n  styleUrls<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"./app.component.css\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Class</span>\n  title <span class=\"token operator\">=</span> <span class=\"token string\">\"app works!\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>앞서 잠깐 언급하였듯 컴포넌트는 전체 화면을 구성하는 하나의 단위인데, 이 단위는 개발자가 쪼개고 싶은 만큼 쪼갤 수 있다. 그리고 이렇게 쪼개진 컴포넌트들로 트리를 구성하여 전체적으로 하나의 모듈 또는 페이지를 만들어 내는 것이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260282/7f35afb0-8fc3-11e6-8559-1dc41caaee43.png\" alt=\"component-tree\">\n<br>\n(<a href=\"https://angular.io/docs/ts/latest/guide/architecture.html\">https://angular.io/docs/ts/latest/guide/architecture.html</a>)</p>\n<p>트리로 구성된 컴포넌트들은 <code class=\"tui-language-text\">@Input</code>과 <code class=\"tui-language-text\">@Output</code>을 통해 서로 통신할 수 있다. <a href=\"https://angular-university.io/\">Angular-University</a>에서 제공하는 <a href=\"https://github.com/angular-university/courses/tree/master/01-getting-started-with-angular2/src/components-inputs-and-outputs\">코드 샘플</a>에 <code class=\"tui-language-text\">@Input</code>과 <code class=\"tui-language-text\">@Output</code>으로 컴포넌트가 통신하는 방식이 잘 나타나 있다.</p>\n<h3 id=\"데이터-바인딩data-binding\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%94%EC%9D%B8%EB%94%A9data-binding\" aria-label=\"데이터 바인딩data binding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 바인딩(Data Binding)</h3>\n<p>Angular의 데이터 바인딩은 컴포넌트와 DOM 간의 데이터 통신방식을 의미하지만, 코드상으로는 컴포넌트의 클래스와 템플릿 간의 데이터 통신으로 생각해도 된다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260283/7f3602e4-8fc3-11e6-9449-ce10d18789ef.png\" alt=\"databinding\"><br>\n(<a href=\"https://angular.io/docs/ts/latest/guide/architecture.html\">https://angular.io/docs/ts/latest/guide/architecture.html</a>)</p>\n<p>다음 3가지 바인딩 방식을 나타내는 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"tui-language-html\"><code class=\"tui-language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>{{hero.name}}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>hero-detail</span> <span class=\"token attr-name\">[hero]</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>selectedHero<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>hero-detail</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">(click)</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>selectHero(hero)<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<ul>\n<li><code class=\"tui-language-text\">{{}}</code> 문법은 단순한 <a href=\"https://angular.io/docs/ts/latest/guide/displaying-data.html#interpolation\">출력(Interpolation)</a>으로 보통 클래스가 가지고 있는 프로퍼티를 그대로 출력하는데 사용한다.</li>\n<li><code class=\"tui-language-text\">[]</code>는 <a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding\">프로퍼티 바인딩(Property Binding)</a>으로 해당 컴포넌트나 DOM의 프로퍼티에 값을 지정한다.</li>\n<li><code class=\"tui-language-text\">()</code>은 <a href=\"https://angular.io/docs/ts/latest/guide/user-input.html#click\">이벤트 바인딩(Event Binding)</a>으로 해당 컴포넌트나 DOM에서 이벤트가 발생했을때 수행되는 핸들러를 지정한다.</li>\n</ul>\n<p>그리고 여기에는 자주 놓치기 쉬운 부분이 있는데, 바로 바인딩 문법이 문자열로 작성되었어도 Angular는 이를 코드로 인식하여 Evaluation 한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token punctuation\">[</span>hero<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token string\">\"selectedhero\"</span>\n\n<span class=\"token punctuation\">(</span>js<span class=\"token punctuation\">)</span> heroDetail<span class=\"token punctuation\">.</span>hero <span class=\"token operator\">=</span> <span class=\"token string\">\"selectedHero\"</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> 문자열 그대로 동작하지 않는다<span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span>js<span class=\"token punctuation\">)</span> heroDetail<span class=\"token punctuation\">.</span>hero <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>selectedHero<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> 문자열을 Evaluation 하여 동작한다<span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>다음은 마지막 <a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#!#two-way-binding-with-ngmodel\"><strong>양방향 데이터 바인딩(Two-way data binding)</strong></a>방식 이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"tui-language-html\"><code class=\"tui-language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">[(ngModel)]</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hero.name<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>양방향 데이터 바인딩은 프로퍼티와 이벤트를 동시에 바인딩하는 방식으로 <code class=\"tui-language-text\">ngModel</code> directive와 <code class=\"tui-language-text\">[()]</code>문법을 사용한다. 이 경우 <code class=\"tui-language-text\">hero.name</code>이 바뀔 때 <code class=\"tui-language-text\">input.value</code>가 바뀌고 <code class=\"tui-language-text\">input.value</code>가 바뀔 때 <code class=\"tui-language-text\">hero.name</code>도 바뀐다. 때문에 각각 따로 이벤트와 프로퍼티를 바인딩할 필요 없이 간단한 문법으로 처리할 수 있다.</p>\n<p>위 4가지 바인딩 방식과 동작은 <a href=\"https://angular.io/resources/live-examples/toh-2/ts/plnkr.html\">Angular의 튜토리얼 예제 코드를 직접 실행하여</a> 확인할 수 있다.</p>\n<p>이 외에도 더욱 자세한 설명이나, 바인딩 시 HTML 속성과 DOM 프로퍼티의 차이, 단순 출력과 프로퍼티 바인딩의 쓰임 등과 같은 내용은 Angular의 <a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#!#binding-syntax-an-overview\">템플릿 바인딩 문법 페이지</a>에서 확인할 수 있다.</p>\n<h3 id=\"지시자directives\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%8B%9C%EC%9E%90directives\" aria-label=\"지시자directives permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지시자(Directives)</h3>\n<p>Angular는 DOM을 다루는 모든 방식을 지시자로 표현한다. 즉 컴포넌트도 지시자의 한 종류다. 다만 컴포넌트 자체적으로도 매우 중요한 개념이기에 지시자와 분리하여 생각한다. 넓은 의미의 지시자가 컴포넌트를 포함하며 실질적으로 우리가 말하는 좁은 의미의 지시자는 컴포넌트를 제외한 속성 지시자와 구조적 지시자를 의미한다.</p>\n<h4 id=\"속성-지시자attribute-directives\" style=\"position:relative;\"><a href=\"#%EC%86%8D%EC%84%B1-%EC%A7%80%EC%8B%9C%EC%9E%90attribute-directives\" aria-label=\"속성 지시자attribute directives permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>속성 지시자(Attribute Directives)</h4>\n<p>속성 지시자는 DOM의 외형이나 동작을 변경한다. 이상적인 속성 지시자는 컴포넌트와 관계가 없으며 또한 상세 구현에 묶이지 않은 형태로 동작하며 대표적으로 Angular의 <code class=\"tui-language-text\">ngStyle</code>, <code class=\"tui-language-text\">ngClass</code> 지시자 등이 속성 지시자에 속한다. 그리고 기본적으로 Property Binding과 같은 방식으로 동작한다. 사실 바인딩 자체가 지시자에 속한다고 생각해도 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"tui-language-html\"><code class=\"tui-language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span> <span class=\"token attr-name\">[style.background]</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">'</span>lime<span class=\"token punctuation\">'</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>I am green with envy!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"tui-language-html\"><code class=\"tui-language-html\"><span class=\"token comment\">&lt;!-- 참고: style과 ngStyle을 같이 사용한 경우는 함께 적용된다. --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span> <span class=\"token attr-name\">[style.color]</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">'</span>white<span class=\"token punctuation\">'</span><span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">[ngStyle]</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>{background: myColor}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  Background Color: {{myColor}}\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<h4 id=\"구조적-지시자structural-directives\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%A1%B0%EC%A0%81-%EC%A7%80%EC%8B%9C%EC%9E%90structural-directives\" aria-label=\"구조적 지시자structural directives permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구조적 지시자(Structural Directives)</h4>\n<p>구조적 지시자는 컴포넌트나 DOM을 추가/삭제하여 어떻게 화면에 나타내는지를 표현한다. 즉 실제 DOM트리 자체에 직접 연관이 있다고 볼 수 있다. 대표적으로 Angular의 <code class=\"tui-language-text\">*ngFor</code>, <code class=\"tui-language-text\">*ngIf</code> 지시자 등이 구조적 지시자에 속한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"tui-language-html\"><code class=\"tui-language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">*ngFor</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>let hero of heroes<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>hero-detail</span> <span class=\"token attr-name\">*ngIf</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>selectedHero<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>hero-detail</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p><code class=\"tui-language-text\">*ngFor</code>의 경우 컴포넌트의 <code class=\"tui-language-text\">heros</code> 리스트에 있는 <code class=\"tui-language-text\">hero</code> 개수 만큼 <code class=\"tui-language-text\">&lt;li&gt;</code> DOM을 복제한다.\n<code class=\"tui-language-text\">*ngIf</code>는 선택된 <code class=\"tui-language-text\">hero</code>가 있는 경우에만 <code class=\"tui-language-text\">HeroDetailComponent</code>를 렌더링한다.</p>\n<h3 id=\"서비스service\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4service\" aria-label=\"서비스service permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서비스(Service)</h3>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260288/7f59bf22-8fc3-11e6-91f5-8bf21abc07eb.png\" alt=\"service-dependency-injection\"><br>\n(<a href=\"https://angular.io/docs/ts/latest/guide/architecture.html\">https://angular.io/docs/ts/latest/guide/architecture.html</a>)</p>\n<p>서비스 객체는 어떤 값, 함수, 애플리케이션에 필요한 기능 등 넓은 범위에 사용한다. 사실 거의 모든 것들이 서비스 객체가 될 수 있다. 로거 클래스라던가, HTTP 모듈을 통해 API를 호출하는 클래스, 어떤 복잡한 계산 로직을 가지고 있는 클래스 등 매우 다양하여 특별히 정의할만한 어떤 특징은 없다.</p>\n<p>그래서 서비스 객체는 Angular가 특별하게 정의하고 제공하는 그런 기본 요소가 아니다. 하지만 그렇다고 해서 우리가 서비스 객체 없이 Angular가 제공하는 기능만으로 애플리케이션의 모든 로직을 작성하고 구현하기는 어렵다. 서버로부터 데이터를 받아오거나 검증하거나 콘솔에 출력하는 일은 컴포넌트의 책임이 아니기 때문이다. 컴포넌트는 사용자와의 상호작용, 뷰와 애플리케이션 로직의 전달자 역할만 하기에, 좋은 컴포넌트는 데이터 바인딩을 위한 속성/메서드로만 표현한다. 그래서 컴포넌트와 관련 없는 작업을 '서비스'라는 이름으로 처리하며, 서비스 객체 없이는 좋은 컴포넌트를 구현할 수 없다.</p>\n<p>그리고 이런 서비스 객체는 Angular의 <a href=\"https://angular.io/docs/ts/latest/guide/dependency-injection.html\">DI(Dependency Injection)</a>을 통해 컴포넌트와 상호작용한다.</p>\n<br>\n## 테스트\n<p>Angular의 로직들을 테스트하기 위해서는 여러 가지 방식이 있는데, Angular를 기준으로 테스트하는 방식을 따져보면 모듈, 컴포넌트, 서비스, 파이프, 지시자, 비동기, 이벤트, 라우터, end-to-end 테스트 등 각각이 필요로 하는 테스트 방식이 매우 많다. 다행히 각 테스트의 원리나 기법들을 <a href=\"https://angular.io/docs/ts/latest/guide/testing.html\">Angular의 테스트 가이드</a>에서 잘 설명하고 있기에, 테스트를 작성할 때 꼭 참고하도록 하자.</p>\n<h3 id=\"테스트-환경\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD\" aria-label=\"테스트 환경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 환경</h3>\n<p>JS의 테스트는 여러 프레임워크와 라이브러리의 조합으로 수행할 수 있지만, Angular는 보통 <a href=\"https://karma-runner.github.io/1.0/index.html\">Karma</a>-<a href=\"http://jasmine.github.io/\">Jasmine</a> 조합으로 테스트를 수행한다. 본래 Karma는 Angular 테스트를 쉽게 하기 위해 만들어졌으며, 확장성과 사용성이 좋아 대부분의 다른 JS 테스트에도 널리 쓰인다.</p>\n<p>그런데 아무리 테스트 도구들을 사용하기 쉽게 만들었어도 실제로 그 환경을 맞추기 위해서는 많은 노력과 노하우가 필요하다. 그래서 이런 테스트 환경을 직접 구성하면서 쩔쩔매기보단 Angular-CLI를 통해 테스트 환경을 구축하길 추천한다.</p>\n<h3 id=\"컴포넌트-테스트\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"컴포넌트 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 테스트</h3>\n<p>Angular에서 굳이 꼭 가장 중요한 테스트를 꼽자면 아마 컴포넌트 테스트일 것이다. 컴포넌트 자체가 Angular에서 매우 중요한 개념인 만큼 컴포넌트 테스트도 매우 중요하다. 컴포넌트를 테스트할 수 있는 방식으로 고립(Isolated) 테스트, Shallow 테스트, 통합(Integration) 테스트 3가지가 있다.</p>\n<h4 id=\"고립-테스트\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EB%A6%BD-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"고립 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고립 테스트</h4>\n<p>고립 테스트는 복잡한 로직이거나 렌더링과 관계없이 로직을 테스트할 때 수행한다.</p>\n<p>Form이 있는 컴포넌트를 테스트하는 경우를 생각해보자. 컴포넌트를 굳이 렌더링하지 않아도 Form의 <code class=\"tui-language-text\">onSubmit</code>등의 핸들러를 직접 호출하여, 값에 대한 유효성이나, 발행하는 Action을 검증할 수 있다. 즉 '사용자에 의해 입력이 되었고', '어떤 이벤트가 발생하여 상태 값이 변경 되었다' 같은 가정 하에 해당 메소드나 동작을 테스트하는 것에만 집중하며, 일반적인 함수나 메서드에 대한 단위 테스트와 유사하다.</p>\n<h4 id=\"shallow-테스트\" style=\"position:relative;\"><a href=\"#shallow-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"shallow 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Shallow 테스트</h4>\n<p>때때로 메서드나 함수가 DOM에 의존성이 있어서 실제 렌더링 없이 테스트를 수행하기에 어려운 경우가 있다. 그렇다고 해서 전체 애플리케이션을 렌더링하기에는 테스트에 대한 비용이 너무 커지기 때문에 보통은 해당 컴포넌트만 렌더링하는 Shallow 테스트를 수행한다. Shallow 테스트는 각 케이스에 해당되는 컴포넌트의 템플릿만을 렌더링하며, 자식 컴포넌트들의 템플릿은 렌더링하지 않는다. 그래서 여전히 테스트를 하나의 컴포넌트로 고립시킬 수 있다.</p>\n<p><code class=\"tui-language-text\">NO_ERRORS_SCHEMA</code>라는 스키마를 컴파일러에게 전달하면, 컴파일러는 인식되지 않은 엘리먼트와 속성들을 무시한다. 때문에 더는 불필요한 컴포넌트나 지시자를 선언할 필요가 없어진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token constant\">NO_ERRORS_SCHEMA</span> <span class=\"token punctuation\">}</span>          <span class=\"token keyword\">from</span> <span class=\"token string\">'@angular/core'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> AppComponent <span class=\"token punctuation\">}</span>              <span class=\"token keyword\">from</span> <span class=\"token string\">'./app.component'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> RouterLinkStubDirective <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../testing'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//...</span>\n\n  <span class=\"token function\">beforeEach</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">async</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    TestBed<span class=\"token punctuation\">.</span><span class=\"token function\">configureTestingModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      declarations<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> AppComponent<span class=\"token punctuation\">,</span> RouterLinkStubDirective <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      schemas<span class=\"token operator\">:</span>      <span class=\"token punctuation\">[</span> <span class=\"token constant\">NO_ERRORS_SCHEMA</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token punctuation\">.</span><span class=\"token function\">compileComponents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      fixture <span class=\"token operator\">=</span> TestBed<span class=\"token punctuation\">.</span><span class=\"token function\">createComponent</span><span class=\"token punctuation\">(</span>AppComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      comp    <span class=\"token operator\">=</span> fixture<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'....'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>단 Shallow 테스트를 할 때는 컴파일러가 에러를 알려주지 않기 때문에, 개발자가 애초에 잘못 작성한 오타나 잘못 사용하고 있는 컴포넌트, 지시자에 대한 문제 역시 알려주지 않는다는 점을 주의해야 한다.</p>\n<h4 id=\"통합-테스트\" style=\"position:relative;\"><a href=\"#%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"통합 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통합 테스트</h4>\n<p>마지막으로 통합 테스트는 모듈을 기준으로 테스트한다. Shallow 테스트는 테스트에 필요로 하는 객체들을 제외한 나머지 의존성을 전부 흉내 내지만, 통합 테스트는 실제 의존성을 그대로 사용한다. 그래서 아무리 Shallow 테스트를 열심히 그리고 꼼꼼하게 작성하였을지라도 결국 실제로 필요로 하는 모든 컴포넌트, 서비스 등의 구현체가 유기적으로 동작하는 경우와는 다를 것이다. Shallow 테스트는 대상 컴포넌트가 설계한 대로 동작하는지 확인하는 데 중점을 둔다면, 통합 테스트는 데이터의 정확성을 검증한다.</p>\n<p>보통은 <code class=\"tui-language-text\">TestBed.configureTestingModule</code>에서 테스트하고자 하는 모듈을 <code class=\"tui-language-text\">imports</code>를 통해 구성하고 테스트를 수행한다.</p>\n<h3 id=\"end-to-end-테스트\" style=\"position:relative;\"><a href=\"#end-to-end-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"end to end 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>End-To-End 테스트</h3>\n<p>Angular의 e2e 테스트는 보통 <a href=\"http://www.protractortest.org/\">Protractor</a>를 이용한다. Protractor는 Angular를 위한 end-to-end(이하 e2e) 테스트 프레임워크이자 NodeJS 프로그램이다. <a href=\"http://docs.seleniumhq.org/\">Selenium</a>의 <a href=\"http://webdriver.io/\">WebDriverIO(WebDriverJS)</a>를 이용하여 e2e 테스트를 지원한다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260289/7f5d8c60-8fc3-11e6-98b0-e2c614319c5a.png\" alt=\"protractor\"><br>\n(<a href=\"http://www.protractortest.org/#/infrastructure\">http://www.protractortest.org/#/infrastructure</a>)</p>\n<p>애플리케이션을 브라우저, 모바일에 구동시켜며 실제 사용자와 동일한 입력과 액션을 시뮬레이션하여 전체 애플리케이션을 행위 중심으로 테스트할 수 있다. 또한 Jasmine과 Mocha를 지원하기 때문에 일관된 스타일의 테스트 코드를 작성할 수 있다.</p>\n<br>\n## 성능\n<p><a href=\"https://www.youtube.com/watch?v=gdlpE9vPQFs&#x26;list=PLOETEcp3DkCq788xapkP_OU-78jhTf68j&#x26;index=6\">ng-conf 2016의 Keynote</a>에 따르면 Angular2는 전작보다 최초 혹은 러닝타임 렌더링 성능이 약 5배 더 빨라졌다고 한다. 컴파일러부터 지연 로딩, 서버 렌더링, 웹 워커, 웹 컴포넌트 등 수 많은 기술의 적극적인 도입과 최적화의 결과라고 볼 수 있다.</p>\n<p>그중에서도 전작의 Dirty checking이 아닌 다른 방식의 변경 감지가 성능 향상에 있어 가장 큰 영향을 준 게 아닐까 싶다.</p>\n<h3 id=\"변경-감지change-detection\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80change-detection\" aria-label=\"변경 감지change detection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 감지(Change detection)</h3>\n<p>변경 감지는 애플리케이션의 뷰(화면)에 있는 DOM 혹은 내부 데이터 모델의 변화가 생길 때 감지하는 것을 말한다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260281/7f340b6a-8fc3-11e6-98c6-ae5416c25e29.png\" alt=\"change-detection\"><br>\n(<a href=\"http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html\">http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html</a>)</p>\n<p>예를 들면, 삭제 버튼을 눌러서 항목을 삭제하거나, 추가 버튼으로 항목을 늘리는 경우 DOM의 변경이 발생한다. 반대로 내부 코드에 의해 제한시간이 지나 게시물이 삭제된 경우, 프레임워크의 데이터 모델 변경이 발생한다. 이런 경우는 둘다 뷰의 변경이 발생하며 이를 Rerendering 이라고 부른다. 그렇다면 렌더링에서 다시 그려야 할 대상이 무엇인지 어떻게 알 수 있을까? DOM 트리에 접근하는 비용은 항상 크기 때문에, 어디가 업데이트되어야 하는지 알아야 하고, 가능한 한 DOM 트리 접근 횟수를 줄여야 한다.</p>\n<p>여러 프레임워크마다 각각 다른 방법으로 이 문제를 해결했지만, Angular는 몇 가지 이벤트에 집중한다.</p>\n<h4 id=\"뷰의-업데이트-시기\" style=\"position:relative;\"><a href=\"#%EB%B7%B0%EC%9D%98-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%8B%9C%EA%B8%B0\" aria-label=\"뷰의 업데이트 시기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뷰의 업데이트 시기</h4>\n<p>Angular는 뷰의 업데이트가 필요한지 어떻게 알수 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  template<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    &lt;h1> &lt;/h1>\n    &lt;button (click)=\"changeName()\">Change name&lt;/button>\n  </span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyApp</span> <span class=\"token punctuation\">{</span>\n  firstname<span class=\"token operator\">:</span> string <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">;</span>\n  lastname<span class=\"token operator\">:</span> string <span class=\"token operator\">=</span> <span class=\"token string\">\"Precht\"</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">changeName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstname <span class=\"token operator\">=</span> <span class=\"token string\">\"Brad\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastname <span class=\"token operator\">=</span> <span class=\"token string\">\"Green\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>버튼을 클릭하면 컴포넌트의 상태 값을 변경하는 핸들러가 실행되고, 컴포넌트의 상태 값이 바뀌는 순간이 뷰를 업데이트해야 하는 순간이다.</p>\n<p>다른 경우도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ContactsApp</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">OnInit</span><span class=\"token punctuation\">{</span>\n\n  contacts<span class=\"token operator\">:</span>Contact<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">private</span> http<span class=\"token operator\">:</span> Http</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">ngOnInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>http<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/contacts'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span> <span class=\"token operator\">=></span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">contacts</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>contacts <span class=\"token operator\">=</span> contacts<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>컴포넌트가 초기화될 때, HTTP 요청을 보내게 되는데, 요청에 대한 응답이 올 때마다 리스트는 업데이트된다. 이 시점에 애플리케이션의 상태가 바뀌어 뷰를 업데이트해야 한다.</p>\n<p>결론적으로 애플리케이션 상태 변경은 다음과 같은 비동기적인 동작 때문에 발생한다.</p>\n<ul>\n<li>DOM 이벤트</li>\n<li>XHR</li>\n<li>Timer</li>\n</ul>\n<p>그래서 역으로 보면 어떤 비동기처리가 수행되었다면, 애플리케이션의 상태는 변경될 가능성이 논다는 것이다. 이 비동기의 시점이 바로 Angular에게 뷰를 업데이트해야 한다고 알려야 할 시점이다. 하지만 위의 코드에서 우리는 뷰를 업데이트시키는 코드를 실행한 적이 없다. 그렇다면 Angular에게 뷰를 업데이트하라고 알려주는 일은 누가 할까? 정답은 '<a href=\"https://github.com/angular/zone.js\">Zone</a>이 알려준다' 이다.</p>\n<p>Zone은 Angular와 무관하게 JS 자체의 비동기적 API들을 <a href=\"https://en.wikipedia.org/wiki/Monkey_patch\">몽키패치</a>하여 Hooking하는 라이브러리이며, Angular는 이 Zone을 외부 의존성으로 적극 활용하고 있는 형태이다. Angular는 <code class=\"tui-language-text\">NgZone</code>이라고 불리는 고유의 zone을 가지고 있으며, Angular의 코드 어딘가에는 <code class=\"tui-language-text\">ApplicationRef</code>라고 불리는 것이 있는데, 이는 <code class=\"tui-language-text\">NgZones</code>와 <code class=\"tui-language-text\">onTurnDone</code> 이벤트의 변경을 감지하고 있다. 두 이벤트 중 하나가 발생하면 <code class=\"tui-language-text\">tick()</code>을 실행하는데 이 함수가 바로 변경 감지에서는 빼놓을 수 없는 요소이다.</p>\n<p>그럼 Angular는 전체 컴포넌트들의 유기적인 변화는 어떻게 처리할까? 단순하다. Angular의 각 컴포넌트에는 변화를 감지하는 고유의 디텍터(Change Detector)가 있다. 이 부분이 변경 발생 시 각 컴포넌트에 독립적으로 변경을 감지할 수 있게 한다. 컴포넌트 트리 어딘가에서 비동기 동작이 수행되면 Zone은 자신에게 주어진 핸들러를 처리하고 Angular에게 변경을 알린다. Angular는 각 고유의 디텍터들을 통해 실제 바인딩을 확인하고 업데이트 한다. 트리에서 데이터는 항상 Top-Down 형태로 흐른다. 이런 단방향 데이터 흐름이 순환 구조보다 더 예측하기 쉽다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19260284/7f3a8ca6-8fc3-11e6-937a-958f5d05adab.gif\" alt=\"change-detection-2\"><br>\n(<a href=\"http://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/59\">http://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/59</a>)</p>\n<h3 id=\"최적화\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"최적화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적화?</h3>\n<p>Angular의 컴포넌트 트리 자체가 단순한 구조이면서, 코드 자체도 VM 친화적인 코드를 만들어내기 때문에, 모든 컴포넌트의 이벤트마다 확인한다 해도 빠르게 처리할 수 있다. 예를 들면 이벤트가 발생한 경우 몇 ms사이에 수십만 개의 컴포넌트를 확인할 수도 있다.</p>\n<p>위에서 각 컴포넌트마다 디텍터가 있다고 했지만 그렇다고 해서 어떤 정형화된 디텍터를 각 컴포넌트에서 개별적으로 다룬다는 것은 아니다.\nAngular는 각 컴포넌트의 구조에 맞게 런타임에 디텍터의 클래스를 정의하고 생성 생성하기 때문에 컴포넌트에 알맞은 디텍터를 생성하면서도 VM친화적인 최적화된 코드를 생산한다.</p>\n<p>그래서 우리는 성능에 대해 깊게 생각하지 않아도 된다. Angular가 알아서 해준다.</p>\n<h3 id=\"immutable--observable\" style=\"position:relative;\"><a href=\"#immutable--observable\" aria-label=\"immutable  observable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Immutable &#x26; Observable</h3>\n<p>어떤 비동기 이벤트던 일단 발생한다면 애플리케이션의 상태가 변할 수 있다.\n그래서 그때마다 컴포넌트의 변경 여부를 전부 다 확인해야 한다는 사실은 우리를 여전히 불편하게 만든다.</p>\n<p>변경을 감지하는 시간을 간단하게 표현해보면 다음과 같다.</p>\n<blockquote>\n<p><code class=\"tui-language-text\">전체 변경 감지 시간 = 하나의 바인딩을 확인하는 시간 * 전체 바인딩 개수</code></p>\n</blockquote>\n<p>하나의 바인딩을 확인하는 시간은 앞서 설명했던것 처럼 동적인 디텍터의 생성으로 최적화를 하였다. 그렇다면 이제 남은 것은 전체 바인딩 개수를 조절해야 한다는 것인데, 사실 애플리케이션의 절대적인 전체 바인딩 수를 줄이기는 어렵다. 대신 변경을 감지할 때, 전체 바인딩을 전부 확인하는 것이 아니라, 변경된 바인딩만 확인할 수 있도록 만들 수는 있다. <a href=\"https://en.wikipedia.org/wiki/Immutable_object\">Immutable</a>과 <a href=\"http://reactivex.io/documentation/observable.html\">Observable</a>을 통해 변경되었는지 아닌지를 알 수 있기에 Angular를 더 빠르게 만들 수 있다.</p>\n<p>보통 이런 최적화는 Angular의 <a href=\"https://angular.io/docs/ts/latest/api/core/index/ChangeDetectionStrategy-enum.html\">변경 감지 전략(Change Detection Strategy)</a>을 <code class=\"tui-language-text\">OnPush</code>로 설정하여 처리한다.</p>\n<h4 id=\"immutable\" style=\"position:relative;\"><a href=\"#immutable\" aria-label=\"immutable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Immutable</h4>\n<p>Immutable 객체는 내부 속성값이 변경되는 것이 아닌, 온전히 새로운 객체를 만들어 내용을 다시 채우는 방법으로 값을 변경한다.\n그래서 수정을 가해도 이전의 객체와는 다른 별개의 객체를 가리키게 된다.\n이 말인 즉, Angular의 상태가 변경되면 상태를 관리하는 객체 자체가 별개의 객체로 생성되어 깊은 비교 없이 레퍼런스 비교만으로 상태 변화를 감지할 수 있다는 것이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19294771/9d85e758-906a-11e6-9139-ef40ffc4cc25.png\" alt=\"change-detection-immutable\"><br>\n(<a href=\"http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html\">http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html</a>)</p>\n<p>Angular는 변경 감지 과정에서 변경이 되지 않은 하위 트리 전체를 건너뛴다. 이렇게 수행 횟수를 전체에서 일부로 줄여 성능 향상에 도움을 줄 수 있다.</p>\n<h4 id=\"observable\" style=\"position:relative;\"><a href=\"#observable\" aria-label=\"observable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable</h4>\n<p>Observable은 Immutable과는 다른 방식으로 변경이 발생했다는 것을 보장한다. Immutable이 객체의 레퍼런스를 가지고 보장했다면 Observable은 변경점에서 이벤트를 발생시켜 반응하게 한다. 그런데 Observable과 <code class=\"tui-language-text\">OnPush</code>전략을 함께 사용하면, Observable 객체의 레퍼런스가 변경되지 않기 때문에, 하위 트리들의 업데이트가 발생하지 않는다. 만약 변경이 발생한 컴포넌트만 업데이트가 필요하다면 문제 없지만, 하위 컴포넌트들의 변경도 함께 업데이트가 필요하다면 문제가 될 수 있다. 그래서 이런 경우는 디텍터의 <code class=\"tui-language-text\">markForCheck()</code>라는 API를 통해 변경이 발생한 컴포넌트의 서브 트리까지 업데이트를 시켜줄 방법이 있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/19294770/9d7fac44-906a-11e6-9d9d-022dd04e3d5e.gif\" alt=\"change-detection-observable\"><br>\n(<a href=\"http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html\">http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html</a>)</p>\n<p>이렇게 변경 감지의 범위를 조절하여 성능 향상에 도움을 줄 수 있다.</p>\n<h3 id=\"web-components\" style=\"position:relative;\"><a href=\"#web-components\" aria-label=\"web components permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web components</h3>\n<p>개발자가 직접 HTML 엘리먼트를 만드는 기술을 말한다. 자세한 내용은 <a href=\"http://webcomponents.org/\">공식 홈페이지</a>를 통해 확인할 수 있다. Angular2는 내부적으로 Web Components를 차용하여 Native Element를 이용하기 때문에 기존 JavaScript 컴포넌트를 이용할 때 보다 훨씬 빨라졌다.</p>\n<br>\n## 정리\nAngular는 많은 부분이 바뀌었다.\n<p>AngularJS에서는 할 수 없던 서버-렌더링도 가능해지고, 성능향상, 주요 언어 교체 등 단점이라고 여겨지던 모습들이 많이 사라진 모습으로 새로 돌아왔다. 오히려 비교 대상으로 여겨지는 React와는 다르게 템플릿 코드를 별도 파일로 분리해서 관리 할 수 있어 비 개발자와의 협업에서 장점이 된다.<br>\n또한, Angular2는 프론트엔드 프레임워크이기 때문에 React보다 비교적 자유도가 낮지만 숙련되지 않은 개발자들에게 전체적인 설계 부담을 줄여준다. 더불어 사용자에게 기본적인 성능 최적화를 보장하기 때문에 성능에 깊게 고민할 필요가 없다는 점도 장점이다. 하지만 단점으로 여겨지는 Angular2 자체 코드의 크기가 크다는 문제가 남았는데, <a href=\"https://angular.io/docs/ts/latest/cookbook/aot-compiler.html#!#compile\">실제 사용하는 코드만 뽑아서 번들링</a>하면 해소할 수 있다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>공식 홈페이지 - Angular.io</li>\n<li>ng-conf 2016 - <a href=\"https://www.youtube.com/playlist?list=PLOETEcp3DkCq788xapkP_OU-78jhTf68j\">https://www.youtube.com/playlist?list=PLOETEcp3DkCq788xapkP_OU-78jhTf68j</a></li>\n<li>ANGULAR 2 CHANGE DETECTION EXPLAINED - <a href=\"http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html\">http://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html</a></li>\n<li>Three Ways to Test Angular 2 Components - <a href=\"https://vsavkin.com/three-ways-to-test-angular-2-components-dcea8e90bd8d#.h75hdex2u\">https://vsavkin.com/three-ways-to-test-angular-2-components-dcea8e90bd8d#.h75hdex2u</a></li>\n</ul>","frontmatter":{"id":"ko_20161007","title":"자바스크립트 프레임워크 소개 2 - Angular 2","description":"Angular는 확장된 HTML 문법을 기반으로 하는 웹 애플리케이션 프레임워크로 개발되었다. 데이터 바인딩, 템플릿 문법 등과 같은 편리한 기능을 제공하여 웹 애플리케이션의 유지 보수, 개발 속도를 크게 향상했으며, 수많은 개발자에게 큰 인기를 얻고 있다. 또 그들의 커뮤니티 또한 많이 발달해 있어, 발전이 기대되는 프레임워크(혹은 플랫폼)로 손꼽힌다.","date":"2016.10.07","author":"이민규","tags":["Angular","framework"],"thumbnail":"https://cloud.githubusercontent.com/assets/12269563/19260279/7f1afc6a-8fc3-11e6-8c41-c33d95f4df0f.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20161007","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}