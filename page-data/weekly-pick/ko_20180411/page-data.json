{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20180411","result":{"data":{"post":{"html":"<h1 id=\"javascript에서-rust-그리고-rust에서-javascript-wasm-bindgen-이야기\" style=\"position:relative;\"><a href=\"#javascript%EC%97%90%EC%84%9C-rust-%EA%B7%B8%EB%A6%AC%EA%B3%A0-rust%EC%97%90%EC%84%9C-javascript-wasm-bindgen-%EC%9D%B4%EC%95%BC%EA%B8%B0\" aria-label=\"javascript에서 rust 그리고 rust에서 javascript wasm bindgen 이야기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript에서 Rust, 그리고 Rust에서 JavaScript: wasm-bindgen 이야기</h1>\n<blockquote>\n<p>원문<br>\nAlex Crichton, <a href=\"https://hacks.mozilla.org/2018/04/javascript-to-rust-and-back-again-a-wasm-bindgen-tale/\">https://hacks.mozilla.org/2018/04/javascript-to-rust-and-back-again-a-wasm-bindgen-tale/</a></p>\n</blockquote>\n<br>\n<blockquote>\n<p>역자 주:</p>\n<ul>\n<li>원글의 의도를 해치지 않는 범위에서 의역을 포함한다.</li>\n<li>의도를 명확하게 전달하기 위한 몇몇 단어는 번역하지 않았다.</li>\n</ul>\n</blockquote>\n<p>우리는 최근 WebAssembly <a href=\"https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/\">컴파일이 얼마나 빠른지</a>, <a href=\"https://hacks.mozilla.org/2018/01/oxidizing-source-maps-with-rust-and-webassembly/\">얼마나 빠른 JS 라이브러리를 만들 수 있는지</a>, 거기에 <a href=\"https://hacks.mozilla.org/2018/01/shrinking-webassembly-and-javascript-code-sizes-in-emscripten/\">얼마나 더 작은 바이너리를 만들어 주는지</a> 확인했다. 더욱이 우리는 <a href=\"https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/\">Rust와 JavaScript 커뮤니티의 더 나은 협업을 위한 계획</a>을 세웠고, 이것에는 다른 웹 프로그래밍 언어들을 위한 것도 포함되어있다. <a href=\"https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/\">이전 글</a>에서도 슬쩍 말했지만, 나는 <a href=\"https://github.com/alexcrichton/wasm-bindgen\"><code class=\"tui-language-text\">wasm-bidgen</code></a>에 대해서 좀 더 자세하게 알아보려 한다.</p>\n<p>현재 <a href=\"https://webassembly.github.io/spec/\">WebAssembly 스펙</a>은 단지 두 개의 정수(integer)와 두 개의 실수(floating-point), 즉 4가지의 타입만을 정의하고 있다. 그러나, JS와 Rust 개발자는 보통 그보다 훨씬 다양한 타입을 다룬다! 예를 들자면 JS 개발자는 HTML node들을 추가하거나 수정하기 위해 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document\">document</a>를 사용하고, Rust 개발자는 오류를 처리하기 위해 <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\">Result</a> 같은 타입을 다룬다. 그리고 대부분 개발자는 문자열을 사용한다.</p>\n<p>WebAssembly가 현재 제공하는 4가지 타입에 손발이 묶이는 것은 너무한 일이다. 여기에 <code class=\"tui-language-text\">wasm-bindgen</code>이 딱이다. <code class=\"tui-language-text\">wasm-bidgen</code>는 JS와 Rust 타입들의 가교 구실을 하려는 것이다. 이것은 JS에서 Rust API를 문자열로 호출하거나, Rust가 JS에서 발생한 예외처리를 할 수 있도록 해준다. <code class=\"tui-language-text\">wasm-bindgen</code>은 WebAssembly와 JavaScript사이의 주파수를 맞춰준다. 번거로움 없이 효율적으로 JavaScript가 WebAssembly 함수를 호출하고, WebAssembly 역시 JavaScript 함수를 사용할 수 있도록 한다.</p>\n<p><code class=\"tui-language-text\">wasm-bindgen</code> 프로젝트의 <a href=\"https://github.com/alexcrichton/wasm-bindgen/blob/master/README.md\">README</a> 에 더 많은 설명이 있다. 이제 <code class=\"tui-language-text\">wasm-bindgen</code> 예제를 하나 살펴보고, 이것이 어떤 기능이 있는지 알아보자.</p>\n<h2 id=\"hello-world\" style=\"position:relative;\"><a href=\"#hello-world\" aria-label=\"hello world permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hello, World!</h2>\n<p>고전적이지만, 새로운 도구를 배우는 가장 좋은 방법의 하나는 \"Hello, World!\"를 출력해보는 것이다. 그러니 \"Hello, World!\" alert를 띄우는 이 <a href=\"https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/hello_world\">예제</a>를 살펴보기로 하자.</p>\n<p>이 예제의 목표는 간단명료하다. 이름 하나를 받아 <code class=\"tui-language-text\">Hello, ${name}!</code> 다이얼로그를 생성하는, Rust 함수를 만들 것이다. JavaScript에서는 아마 아래처럼 함수를 정의할 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다만, 우리는 이것을 Rust로 작성하고 싶다. 이제 우리가 할 아래와 같은 몇 가지 일이 보인다.</p>\n<ul>\n<li>JavaScript는 WebAssembly 모듈, 즉 <code class=\"tui-language-text\">greet</code> export를 호출한다.</li>\n<li>그 Rust 함수는 환영(greet)해 줄 이름(<code class=\"tui-language-text\">name</code>)을 문자열로 받는다.</li>\n<li>내부적으로 Rust는 새로운 문자열을 생성하여 그 이름을 저장한다.</li>\n<li>그리고 마지막으로 Rust는 이름을 저장한 문자열과 함께 JavaScript <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/alert\"><code class=\"tui-language-text\">alert</code></a> 함수를 호출한다.</li>\n</ul>\n<p>이제 이 일을 시작하기 위해, 새로운 Rust 프로젝트를 생성하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ cargo new wasm-greet --lib</code></pre></div>\n<p>이 명령은 우리가 작업할 <code class=\"tui-language-text\">wasm-greet</code> 폴더를 만든다. 다음으로 <code class=\"tui-language-text\">Cargo.toml</code>(Rust의 <code class=\"tui-language-text\">package.json</code> 같은)을 아래처럼 수정하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"tui-language-ini\"><code class=\"tui-language-ini\"><span class=\"token selector\">[lib]</span>\n<span class=\"token constant\">crate-type</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span> [\"cdylib\"]</span>\n\n<span class=\"token selector\">[dependencies]</span>\n<span class=\"token constant\">wasm-bindgen</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span> \"0.2\"</span></code></pre></div>\n<p>일단 <code class=\"tui-language-text\">[lib]</code> 이 무엇을 하는지는 넘어가자. 그다음은 <a href=\"https://crates.io/crates/wasm-bindgen\"><code class=\"tui-language-text\">wasm-bindgen</code> crate</a> dependency를 선언한다. 이 crate는 Rust에서 <code class=\"tui-language-text\">wasm-bindgen</code>을 사용하는데 필요한 모든 것들을 포함한다.</p>\n<p>이제 코드를 작성할 시간이다! 자동생성된 <code class=\"tui-language-text\">src/lib.rs</code>를 아래의 내용으로 바꾸자.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"tui-language-rust\"><code class=\"tui-language-rust\"><span class=\"token attribute attr-name\">#![feature(proc_macro, wasm_custom_section, wasm_import_module)]</span>\n\n<span class=\"token keyword\">extern</span> <span class=\"token keyword\">crate</span> <span class=\"token module-declaration namespace\">wasm_bindgen</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">wasm_bindgen<span class=\"token punctuation\">::</span>prelude<span class=\"token punctuation\">::</span></span><span class=\"token operator\">*</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token attribute attr-name\">#[wasm_bindgen]</span>\n<span class=\"token keyword\">extern</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">alert</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token attribute attr-name\">#[wasm_bindgen]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token macro property\">format!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 당신이 Rust에 익숙지 않다면 살짝 장황해 보일 수 있다. 하지만 걱정하지 마시라! <code class=\"tui-language-text\">wasm-bindgen</code> 프로젝트는 지속해서 개선되고 있고, 이 모든것들이 항상 필요한 것은 아니다. 여기서 제일 주목할 부분은 <code class=\"tui-language-text\">#[wasm_bindgen]</code> <em>attribute</em> 인데, 이 Rust annotation은 \"필요하면 wrapper로 처리해주세요.\" 라는 뜻이다. <code class=\"tui-language-text\">alert</code> 함수를 가져올 때도, <code class=\"tui-language-text\">greet</code> 함수를 내보낼 때도, 이 attribute로 annotation을 달았다. 이것이 어떻게 동작하는지는 곧 알아볼 것이다.</p>\n<p>그 전에 먼저, 이 wasm 코드를 컴파일해서 브라우저로 열어보자!</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ rustup target add wasm32-unknown-unknown --toolchain nightly # 한 번만 하면 된다.\n$ cargo +nightly build --target wasm32-unknown-unknown</code></pre></div>\n<p>이러면 <code class=\"tui-language-text\">target/wasm32-unknown-unknown/debug/wasm_greet.wasm</code>이 생성된다. <a href=\"https://github.com/WebAssembly/wabt\"><code class=\"tui-language-text\">wasm2wat</code></a> 같은 도구로 이 파일을 열어보면 조금 무섭게 생겼다. 사실 아직은 JS에서 사용될 수 없다. 이것을 사용하려면 한 단계가 더 남았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ cargo install wasm-bindgen-cli # 한 번만 하면 된다\n$ wasm-bindgen target/wasm32-unknown-unknown/debug/wasm_greet.wasm --out-dir .</code></pre></div>\n<p>이 과정에서 꽤 많은 마법이 일어난다. <code class=\"tui-language-text\">wasm-bindgen</code> CLI 도구는 <code class=\"tui-language-text\">wasm</code> 입력 파일을 전처리하여, 사용하기 적절하게 만든다. \"적절하게\" 만든다는 것이 무슨 뜻인지는 나중에 알아보기로 하자. 지금은 <code class=\"tui-language-text\">wasm_greet.js</code>(<code class=\"tui-language-text\">wasm-bindgen</code> 도구로 만든) 파일을 import 하면, Rust에서 정의한 <code class=\"tui-language-text\">greet</code> 함수를 가져올 수 있다고만 알아두자.</p>\n<p>마지막으로, 우리가 할 일은 bundler로 이것을 패키징하고, HTML 파일을 하나 만들어 이 코드를 실행하는 것이다. 내가 이 글을 쓰고 있는 지금은 <a href=\"https://medium.com/webpack/webpack-4-released-today-6cdb994702d4\">Webpack's 4.0 release</a>만이 깔끔하게 WebAssembly를 지원한다. <a href=\"https://github.com/alexcrichton/wasm-bindgen/blob/master/examples/hello_world/README.md#caveat-for-chrome-users\">크롬에서 주의사항</a>이 있기는 하다. 곧 다른 bundler들도 지원하리라 본다. 자세한 내용은 접어두고, Github repo에 있는 <a href=\"https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/hello_world\">예제</a> 설정을 따라 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> rust <span class=\"token operator\">=</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./wasm_greet\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrust<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> m<span class=\"token punctuation\">.</span><span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"World!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이... 러면 끝! 웹 페이지를 열면 Rust가 만든 \"Hello, World!\" 다이얼로그가 보인다.</p>\n<h2 id=\"wasm-bindgen-원리\" style=\"position:relative;\"><a href=\"#wasm-bindgen-%EC%9B%90%EB%A6%AC\" aria-label=\"wasm bindgen 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"tui-language-text\">wasm-bindgen</code> 원리</h2>\n<p>휴~ \"Hello, World!\" 출력하기 조금 힘들었다. 이것의 원리가 어떻게 되는지, 그리고 도구들이 어떤 일을 했는지 더 자세히 알아보자.</p>\n<p><code class=\"tui-language-text\">wasm-bindgen</code>의 가장 중요한 사항은, wasm module이 ES module의 한 종류라는 개념을 기반으로 한 연동이라는 것이다. 예를 들어 위 예제의 ES module TypeScript signature는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"tui-language-ts\"><code class=\"tui-language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>WebAssembly는 이것이 기본적으로 불가능하다(오직 숫자만 지원하므로). 이 부족함을 채우기 위해 <code class=\"tui-language-text\">wasm-bindgen</code>이 필요하다. 위의 마지막 단계에서 <code class=\"tui-language-text\">wasm-bindgen</code>을 실행했을때, <code class=\"tui-language-text\">wasm_greet_bg.wasm</code>파일과 함께 <code class=\"tui-language-text\">wasm_greet.js</code>파일이 생성되었다. 이 중 JavaScript 파일은 Rust를 호출할 때 사용될 인터페이스 역할을 한다. 그리고 <code class=\"tui-language-text\">*_bg.wasm</code>파일이 우리 코드를 컴파일한 것과 실제 구현을 가지고 있다.</p>\n<p><code class=\"tui-language-text\">./wasm_greet</code> 모듈을 import 하면 Rust 코드에서 내보낸 것에 접근할 수 있다. 현재는 JavaScript 인터페이스 없이 직접 접근하지는 못한다. 여기까지 Rust와 JavaScript의 연동이 어떻게 돌아가는지 알아보았다. 이제 스크립트를 실행하면 어떠한 일이 일어나는지 실행을 따라가 보자. 예제를 실행하면:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> rust <span class=\"token operator\">=</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./wasm_greet\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrust<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> m<span class=\"token punctuation\">.</span><span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"World!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 우리는 비동기적으로 필요한 인터페이스를 import하고, resolve 되기를 기다린다(wasm을 다운로드하고 컴파일 하기를). 이후, 그 모듈의 <code class=\"tui-language-text\">greet</code> 함수를 호출한다.</p>\n<blockquote>\n<p>Note: 이러한 비동기 로딩은 <a href=\"https://github.com/webpack/webpack/issues/6615\">현재 웹팩에 필요한 사항</a>이다. 하지만 항상 이렇지는 않으며, 다른 bundler의 경우는 다를 수 있다.</p>\n</blockquote>\n<p><code class=\"tui-language-text\">wasm_greet.js</code>파일을 살펴보면 <code class=\"tui-language-text\">wasm-bindgen</code> 도구가 생성한 아래와 같은 코드가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> wasm <span class=\"token keyword\">from</span> <span class=\"token string\">'./wasm_greet_bg'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>ptr0<span class=\"token punctuation\">,</span> len0<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">passStringToWasm</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> ret <span class=\"token operator\">=</span> wasm<span class=\"token punctuation\">.</span><span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>ptr0<span class=\"token punctuation\">,</span> len0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        wasm<span class=\"token punctuation\">.</span><span class=\"token function\">__wbindgen_free</span><span class=\"token punctuation\">(</span>ptr0<span class=\"token punctuation\">,</span> len0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">__wbg_f_alert_alert_n</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ptr0<span class=\"token punctuation\">,</span> len0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>Note: 이 코드는 자동 생성되었으며, 최적화되지도 않았다. 딱히 이쁘지도 작지도 않을 수 있다. 우리가 만약 LTO(Link Time Optimization)로 컴파일하고, Rust로 빌드한 후, JS bundler(minification)를 사용했다면, 이 코드는 훨씬 작았을 것이다.</p>\n</blockquote>\n<p>여기서 <code class=\"tui-language-text\">wasm-bindgen</code>이 생성한 <code class=\"tui-language-text\">greet</code> 함수를 보자. 내부적으로 wasm의 <code class=\"tui-language-text\">greet</code> 함수를 호출하고 있지만, 이 호출은 문자열이 아닌 pointer와 length를 사용한다. 만약 <code class=\"tui-language-text\">passStringToWasm</code> 에 대해 더 알고 싶다면 <a href=\"https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/\">Lin Clark의 이전 글</a>을 참고하자. 이 모든 것들은 <code class=\"tui-language-text\">wasm-bindgen</code> 도구가 아니었다면 <em>우리가 직접 작성해야 했을</em> 거추장스러운 것들이다. <code class=\"tui-language-text\">__wbg_f_alert_alert_n</code> 함수는 잠시 후 살펴본다.</p>\n<p>조금 더 깊이 들어가서, WebAssembly의 <code class=\"tui-language-text\">greet</code> 함수를 알아보자. 이 코드를 볼 때 Rust 컴파일러의 시점을 따라가 보자. 위에서 JS wrapper가 생성되었듯, 외부로 노출할 <code class=\"tui-language-text\">greet</code> 심볼 역시 <code class=\"tui-language-text\">#[wasm_bindgen]</code> attribute가 우리 대신 shim을 생성했다. 즉:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"tui-language-rust\"><code class=\"tui-language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token macro property\">format!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token attribute attr-name\">#[export_name = <span class=\"token string\">\"greet\"</span>]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">extern</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">__wasm_bindgen_generated_greet</span><span class=\"token punctuation\">(</span>arg0_ptr<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">u8</span><span class=\"token punctuation\">,</span> arg0_len<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> arg0 <span class=\"token operator\">=</span> <span class=\"token keyword\">unsafe</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">::</span><span class=\"token namespace\">std<span class=\"token punctuation\">::</span>slice<span class=\"token punctuation\">::</span></span><span class=\"token function\">from_raw_parts</span><span class=\"token punctuation\">(</span>arg0_ptr <span class=\"token keyword\">as</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">u8</span><span class=\"token punctuation\">,</span> arg0_len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">let</span> arg0 <span class=\"token operator\">=</span> <span class=\"token keyword\">unsafe</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">::</span><span class=\"token namespace\">std<span class=\"token punctuation\">::</span></span><span class=\"token keyword\">str</span><span class=\"token punctuation\">::</span><span class=\"token function\">from_utf8_unchecked</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 우리가 작성한 <code class=\"tui-language-text\">greet</code> 원래 코드를 발견할 수 있는데, 이상한 이름의 <code class=\"tui-language-text\">__wasm_bindgen_generated_greet</code> 함수에 <code class=\"tui-language-text\">#[wasm_bindgen]</code> attribute가 붙어있다. 이것이 외부로 노출될 함수(<code class=\"tui-language-text\">#[export_name]</code>과 <code class=\"tui-language-text\">extern</code> 키워드로 명시되어)이며, JS가 던진 pointer와 length를 받는다. 내부적으로 이것은 pointer와 length를 <a href=\"https://doc.rust-lang.org/std/primitive.str.html\"><code class=\"tui-language-text\">&amp;str</code></a> (Rust의 문자열)로 변환한 후 우리가 정의한 <code class=\"tui-language-text\">greet</code> 함수에 전달한다.</p>\n<p>정리하면, <code class=\"tui-language-text\">#[wasm_bindgen]</code> attribute는 두 개의 wrapper를 생성한다. JS 타입들을 받아서 wasm으로 변환을 하는 JavaScript 측면 하나와 wasm 타입들을 Rust 타입들로 바꾸는 Rust 측면 하나이다.</p>\n<p>자 이제 마지막으로 남아있는 <code class=\"tui-language-text\">alert</code> 함수 wrapper들을 보자. Rust의 <code class=\"tui-language-text\">greet</code> 함수는 새로운 문자열을 만들고 이것을 <code class=\"tui-language-text\">alert</code>에 보내기 위해 표준 <a href=\"https://doc.rust-lang.org/std/macro.format.html\">format!</a> 매크로를 사용한다. 우리가 <code class=\"tui-language-text\">alert</code> 함수를 선언할 때 <code class=\"tui-language-text\">#[wasm_bindgen]</code>을 붙였음을 잊지 말고, rustc가 이 함수를 어떻게 보는지 따라가 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"tui-language-rust\"><code class=\"tui-language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">alert</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attribute attr-name\">#[wasm_import_module = <span class=\"token string\">\"__wbindgen_placeholder__\"</span>]</span>\n    <span class=\"token keyword\">extern</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">__wbg_f_alert_alert_n</span><span class=\"token punctuation\">(</span>s_ptr<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">u8</span><span class=\"token punctuation\">,</span> s_len<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">unsafe</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> s_ptr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">as_ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> s_len <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">__wbg_f_alert_alert_n</span><span class=\"token punctuation\">(</span>s_ptr<span class=\"token punctuation\">,</span> s_len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이것은 우리가 작성한 것과는 조금 다르지만, 이것이 어떻게 연동되는지 볼 수 있다. 이 <code class=\"tui-language-text\">alert</code> 함수는 사실 Rust <a href=\"https://doc.rust-lang.org/std/primitive.str.html\"><code class=\"tui-language-text\">&amp;str</code></a>을 받아 wasm 타입들(numbers)로 바꿔주는 얇은 wrapper이다. 이 함수는 위에서 보았던 이상한 모양의 <code class=\"tui-language-text\">__wbg_f_alert_alert_n</code> 함수를 호출하는데, <code class=\"tui-language-text\">#[wasm_import_module]</code> attribute가 궁금해진다.</p>\n<p>WebAssembly에서 함수를 가져오기 위한 모든 코드는 함수가 포함된 모듈을 하나씩 가지게 된다. <code class=\"tui-language-text\">wasm-bindgen</code>역시 ES 모듈들로 만들어졌으며, ES module import로 변환된다! <code class=\"tui-language-text\">__wbindgen_placeholder__</code> 모듈은 실제 존재하지는 않지만, 이것은 우리가 생성한 JS 파일을 가져오기 위해, <code class=\"tui-language-text\">wasm-bindgen</code> 도구가 다시 작성할 지시어 역할을 한다.</p>\n<p>그리고 마지막 퍼즐 조각인, 아래의 내용을 담은 JS 생성 파일이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">__wbg_f_alert_alert_n</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ptr0<span class=\"token punctuation\">,</span> len0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> arg0 <span class=\"token operator\">=</span> <span class=\"token function\">getStringFromWasm</span><span class=\"token punctuation\">(</span>ptr0<span class=\"token punctuation\">,</span> len0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>와우! 알고 보니 내부적으로 꽤 많은 일이 일어나고 있고, JS의 <code class=\"tui-language-text\">greet</code>에서 브라우저의 <code class=\"tui-language-text\">alert</code>에까지 살짝 긴 여정이 되었다. 하지만 걱정하지 마시라. <code class=\"tui-language-text\">wasm-bindgen</code>의 핵심이 바로 이러한 것들을 없애준다는 것이다! 여러분은 단지 몇몇 <code class=\"tui-language-text\">#[wasm_bindge]</code>을 여기저기에 적기만 하면 된다. 그러면 여러분은 Rust를 JS 모듈처럼 사용할 수 있다.</p>\n<h3 id=\"이-외에-wasm-bindgen이-할-수-있는-일\" style=\"position:relative;\"><a href=\"#%EC%9D%B4-%EC%99%B8%EC%97%90-wasm-bindgen%EC%9D%B4-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%9D%BC\" aria-label=\"이 외에 wasm bindgen이 할 수 있는 일 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이 외에 <code class=\"tui-language-text\">wasm-bindgen</code>이 할 수 있는 일?</h3>\n<p><code class=\"tui-language-text\">wasm-bindgen</code> 프로젝트는 방대한 범위의 프로젝트이고, 여기서 그 세부사항들을 다 알아볼 수는 없다. 우리가 위에서 보았던 <a href=\"https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/hello_world\">Hello, World!</a> 부터 Rust 코드만으로 <a href=\"https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/dom\">DOM nodes 다루기</a>까지 다양한 <a href=\"https://github.com/alexcrichton/wasm-bindgen/tree/master/examples\">예제 디렉터리</a>가 있다. 이것을 둘러보는 것은 <code class=\"tui-language-text\">wasm-bindgen</code>이 어떤 기능을 가졌는지 알 수 있는 아주 좋은 방법이다.</p>\n<p><code class=\"tui-language-text\">wasm-bindgen</code> 의 주요 기능은 아래와 같다:</p>\n<ul>\n<li>JS structs, functions, objects 등을 가져와 wasm에서 호출하기. 여러분은 struct 의 method를 호출하거나 property에 접근할 수 있다. 한번 <code class=\"tui-language-text\">#[wasm_bindgen]</code> annotation들을 설정하고 나면, 살짝 \"native\" 느낌으로 Rust 코드를 작성할 수 있다.</li>\n<li>Rust structure들과 함수들을 JS에 내보내기. Rust <code class=\"tui-language-text\">struct</code> 을 내보내서 JS <code class=\"tui-language-text\">class</code>로 변환할 수 있다. 정수들뿐만 아니라 struct 도 주고받을 수 있다. <a href=\"https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/smorgasboard\">smorgasboard</a> 예제는 이러한 연동을 잘 보여준다.</li>\n<li>global scope(<code class=\"tui-language-text\">alert</code> 함수 등) 가져오기, JS exception을 Rust에서 <code class=\"tui-language-text\">Result</code>로 처리하기, Rust 프로그램에서 JS 값들 저장하는 것처럼 generic을 사용하기 등 다양한 기능들이 있다.</li>\n</ul>\n<p>만약 더 많은 기능이 궁금하다면, <a href=\"https://github.com/alexcrichton/wasm-bindgen/issues\">이슈 트래커</a>에 채널고정!</p>\n<h2 id=\"앞으로의-wasm-bindgen\" style=\"position:relative;\"><a href=\"#%EC%95%9E%EC%9C%BC%EB%A1%9C%EC%9D%98-wasm-bindgen\" aria-label=\"앞으로의 wasm bindgen permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>앞으로의 <code class=\"tui-language-text\">wasm-bindgen</code>?</h2>\n<p>이 글을 마무리하기 전에 잠시 <code class=\"tui-language-text\">wasm-bindgen</code>의 비전에 대해 쓰려 한다. 왜냐하면 나는 이것이 오늘날 최고로 흥미 있는 프로젝트 중 하나라고 생각하기 때문이다.</p>\n<h3 id=\"rust-이외-다른-언어의-지원\" style=\"position:relative;\"><a href=\"#rust-%EC%9D%B4%EC%99%B8-%EB%8B%A4%EB%A5%B8-%EC%96%B8%EC%96%B4%EC%9D%98-%EC%A7%80%EC%9B%90\" aria-label=\"rust 이외 다른 언어의 지원 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rust 이외 다른 언어의 지원</h3>\n<p><code class=\"tui-language-text\">wasm-bindgen</code> CLI 도구는 첫 시작부터 여러 언어를 지원할 수 있도록 디자인되었다. 현재는 Rust가 유일한 지원 언어이지만, 이 도구는 C, C++ 플러그인도 지원할 수 있도록 디자인되었다. <code class=\"tui-language-text\">#[wasm_bindgen]</code> attribute는 <code class=\"tui-language-text\">*.wasm</code>에 특별한 섹션을 만들어 내는데, 이는 <code class=\"tui-language-text\">wasm-bindgen</code> 도구가 읽어들인 후 삭제한다. 이 섹션에는 어떤 인터페이스를 가진 JS binding을 생성할지 쓰여있다. 이 섹션은 Rust만을 위한 것이 아니기에, C++ 컴파일러 플러그인도 이것을 생성하여 <code class=\"tui-language-text\">wasm-bindgen</code> 도구가 처리토록 할 수 있다.</p>\n<p>나는 이 점이 <code class=\"tui-language-text\">wasm-bindgen</code>같은 도구가 WebAssembly와 JS와의 연동을 위한 표준으로 만들 수 있을 것이라 믿기에 특별히 흥미를 느끼고 있다. 바라건대, 모든 언어를 WebAssembly로 컴파일시킬 수 있도록 하고, bundler는 자동으로 이를 인식하여 위에서 알아보았던 도구나 설정들이 필요 없었으면 한다.</p>\n<h3 id=\"js-에코-시스템-자동-바인딩\" style=\"position:relative;\"><a href=\"#js-%EC%97%90%EC%BD%94-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%90%EB%8F%99-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"js 에코 시스템 자동 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS 에코 시스템 자동 바인딩</h3>\n<p>현재 <code class=\"tui-language-text\">#[wasm_bindgen]</code> 매크로의 단점 중 하나는 모든 것을 직접 실수 없이 작성해야 한다는 것이다. 이것은 종종 지루하고(실수하기 쉬운) 작업이지만 자동화 가능한 것이다.</p>\n<p>모든 웹 API들은 <a href=\"https://heycam.github.io/webidl/\">WebIDL</a>에 정의되어있고, <a href=\"https://github.com/alexcrichton/wasm-bindgen/issues/42\">WebIDL을 이용해 <code class=\"tui-language-text\">#[wasm_bindgen]</code> annotation을 생성하는 일</a>은 충분히 실현할 수 있다. 다시 말하면 위에서 우리가 한대로 <code class=\"tui-language-text\">alert</code> 함수를 정의할 필요 없이, 그냥 아래처럼만 사용하면 된다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"tui-language-rust\"><code class=\"tui-language-rust\"><span class=\"token attribute attr-name\">#[wasm_bindgen]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">greet</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token namespace\">webapi<span class=\"token punctuation\">::</span></span><span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token macro property\">format!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 경우, 오류 없는 <code class=\"tui-language-text\">webapi</code> crate가 WebIDL 스펙에 따라 자동 생성될 수 있다.</p>\n<p>한 발자국 더 나가서 Typescript 커뮤니티의 멋진 작업을 활용하면 <a href=\"https://github.com/alexcrichton/wasm-bindgen/issues/18\">TypeScript에서 <code class=\"tui-language-text\">#[wasm_bindgen]</code>을 생성할 수도 있다</a>. 이렇게 하면 npm에 등록된 어떤 TypeScript 패키지도 손쉽게 자동 바인딩할 수 있다!</p>\n<h3 id=\"js보다도-빠른-dom-성능\" style=\"position:relative;\"><a href=\"#js%EB%B3%B4%EB%8B%A4%EB%8F%84-%EB%B9%A0%EB%A5%B8-dom-%EC%84%B1%EB%8A%A5\" aria-label=\"js보다도 빠른 dom 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS보다도 빠른 DOM 성능</h3>\n<p>마지막으로 중요한 <code class=\"tui-language-text\">wasm-bindgen</code>의 염원: 초-빠른 DOM 조작 — 많은 JS 프레임워크들의 성배. 현재 DOM 함수 호출은 JavaScript에서 C++ 엔진으로 변환이 필요하므로 비싼 과정을 거쳐야 한다. 하지만 WebAssembly를 사용하면 그러한 과정이 필요 없다. WebAssembly는 잘... 까지는 모르겠지만, 어쨌거나 타입을 가지고 있다!</p>\n<p><code class=\"tui-language-text\">wasm-bindgen</code>은 미래의 WebAssembly <a href=\"https://github.com/WebAssembly/host-bindings\">host binding proposal</a>을 처음부터 염두에 두고 디자인되었다. WebAssembly의 이 기능이 가능해지면 <code class=\"tui-language-text\">wasm-bindgen</code>의 JS shim들 없이 함수를 호출할 수 있다. 더 나아가, WebAssembly의 호출은 타입을 가지고 있으므로, arguments의 유효성 검사(JS의 호출은 필요로 하는)가 필요 없다. 이로 인해, JS 엔진들이 적극적으로 WebAssembly의 DOM 조작을 최적화할 수 있다. 이때가 되면 <code class=\"tui-language-text\">wasm-bindgen</code>은 문자열 같은 다양한 타입들을 사용하기 편하게 할 뿐 아니라, DOM 조작에서 최고의 성능을 제공할 수 있다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>개인적으로 WebAssembly로 일하는 것이 꽤 재미있는데, 이는 커뮤니티 때문만은 아니고 발전이 아주 빠르기 때문이다. <code class=\"tui-language-text\">wasm-bindgen</code> 도구의 전망은 아주 밝다. 이것은 JS와 Rust 같은 언어의 연동을 훌륭히 지원할 뿐만 아니라, WebAssembly가 지속해서 발전하는데 발맞추어 장기적인 효용을 제공한다.</p>\n<h2 id=\"alex-crichton는\" style=\"position:relative;\"><a href=\"#alex-crichton%EB%8A%94\" aria-label=\"alex crichton는 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://hacks.mozilla.org/author/acrichtonmozilla-com/\">Alex Crichton</a>는</h2>\n<p>Alex는 Rust 코어 팀의 멤버로 2012년부터 Rust에서 일해왔다. 최근에는 WebAssembly Rust Working group이 Rust+Wasm이 최고의 경험을 줄 수 있도록 돕고 있다. Alex는 또한 Cargo(Rust 패키지 매니저), Rust standard library, Rust의 release와 CI에 필요한 인프라의 유지도 돕고 있다.</p>\n<p><a href=\"https://hacks.mozilla.org/author/acrichtonmozilla-com/\">Alex Crichton이 쓴 더 많은 글</a></p>\n<br>\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\"><img alt=\"크리에이티브 커먼즈 라이선스\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-sa/4.0/88x31.png\" /></a><br />이 저작물은 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\">크리에이티브 커먼즈 저작자표시-동일조건변경허락 4.0 국제 라이선스</a>에 따라 이용할 수 있습니다.","frontmatter":{"id":"ko_20180411","title":"JavaScript에서 Rust, 그리고 Rust에서 JavaScript - wasm-bindgen 이야기","description":"우리는 최근 WebAssembly 컴파일이 얼마나 빠른지, 얼마나 빠른 JS 라이브러리를 만들 수 있는지, 거기에 얼마나 더 작은 바이너리를 만들어 주는지 확인했다. 더욱이 우리는 Rust와 JavaScript 커뮤니티의 더 나은 협업을 위한 계획을 세웠고, 이것에는 다른 웹 프로그래밍 언어들을 위한 것도 포함되어있다. 이전 글에서도 슬쩍 말했지만, 나는 wasm-bidgen에 대해서 좀 더 자세하게 알아보려 한다.","date":"2018.04.11","author":"최규우","tags":["WebAssembly"],"thumbnail":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20180411","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}