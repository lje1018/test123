{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20160222","result":{"data":{"post":{"html":"<h1 id=\"2016년은-웹-스트림web-stream의-해다\" style=\"position:relative;\"><a href=\"#2016%EB%85%84%EC%9D%80-%EC%9B%B9-%EC%8A%A4%ED%8A%B8%EB%A6%BCweb-stream%EC%9D%98-%ED%95%B4%EB%8B%A4\" aria-label=\"2016년은 웹 스트림web stream의 해다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2016년은 웹 스트림(web stream)의 해다.</h1>\n<blockquote>\n<p>원문<br>\nJake Archibald, <a href=\"https://jakearchibald.com/2016/streams-ftw/\">https://jakearchibald.com/2016/streams-ftw/</a></p>\n</blockquote>\n<p><br><br></p>\n<p>그렇다. 신년 초부터 한해의 일에 대해 이야기한다는 것은 가벼운 일은 아니다. 그러나 웹 스트림 API의 잠재력은 나를 매우 흥분 시켰기에 그런 일을 가능하게 했다.</p>\n<p>요약하면, 스트림은 <a href=\"#cloud-to-butt\">\"cloud\"라는 단어를 \"butt\"로 변경</a> 하거나 <a href=\"#mpeg-to-gif\">MPEG를 GIF로 변환</a> 하는 작업과 같이 익숙한 일들을 할 수 있다. 그러나 가장 중요한것은 <a href=\"#fastest\">제공 내용을 가장 빠르게</a> 서비스 워커로 결합시킬 수 있다는 것이다.</p>\n<h2 id=\"스트림-과연-뭐에-좋은가\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EA%B3%BC%EC%97%B0-%EB%AD%90%EC%97%90-%EC%A2%8B%EC%9D%80%EA%B0%80\" aria-label=\"스트림 과연 뭐에 좋은가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트림, 과연 뭐에 좋은가?</h2>\n<p>좋은 것은 분명한데...</p>\n<p>프라미스(promise)는 단독 값에 대한 비동기 전송을 대체하는 가장 좋은 방법이다. 그러나 여러 값에 대한 전송이나 큰값을 분산하여 전송해야 하는 경우에는 좋은 방법이 아닐 수 있다.</p>\n<p>이미지를 가져오고  표현하기 원할때에는 다음의 절차대로 진행된다.</p>\n<ol>\n<li>네트워크로 부터 데이터를 가져온다.</li>\n<li>가져온 데이터를 가공하고 압축된 데이터를 raw pixel 데이터로 변환한다.</li>\n<li>화면에 보여준다.</li>\n</ol>\n<p>우리는 한번에 하나의 스탭씩 실행하거나 아니면 스트림을 이용할 수 있다.\n<img src=\"https://cloud.githubusercontent.com/assets/2888775/13210627/65b881e4-d974-11e5-8f75-204f63fb88a0.gif\" alt=\"streaming\"></p>\n<p>만약 우리가 비트단위로 핸들링하고 변환한다면, 이미지의 일부를 빨리 렌더링 하는 방법을 얻을 수 있다. 심지어 데이터를 병렬로 가져올 수 있기 때문에, 전체 이미지를 빠르게 렌더링하는 것도 가능하다. 이것이 스트리밍이다! 우리는 네트워크로부터 스트림을 읽고 압축데이터를 픽셀 데이터로 변환한 후 화면에 그리게 된다.</p>\n<p>당신은 이벤트로도 비슷한 성과를 얻을 수 있다. 그러나 스트림은 또다른 이점을 제공한다.</p>\n<ul>\n<li>시작/종료 지점 - 스트림은 무한이라고 하더라도 처리할 수 있다.</li>\n<li>읽지 않은 값의 버퍼링 - 반면에 리스너가 등록되기 전의 이벤트는 손실된다.</li>\n<li>파이핑(piping)을 통한 변경 - 당신은 비동기 시퀀스 형성과 함께 스트림을 파이핑 할 수 있다</li>\n<li>에러 핸들링 내장 - 에러는 파이프를 타고 아래로 전파될 것이다.</li>\n<li>취소 지원 - 그리고 취소 메시지는 파이프로 다시 전달된다.</li>\n<li>흐름 제어 - 당신은 리더(reader)의 속도에 반응할 수 있다.</li>\n</ul>\n<p>위의 항목 중 마지막 하나는 정말 중요하다. 다운로드와 영상을 표현하는데 스트림을 사용한다고 가정해보자. 만약에 초당 200 프레임의 비디오를 다운로드하고 디코딩 한다고 해도 화면에는 초당 24 프레임만 표현될 것이며 결국 디코드 프레임의 거대한 백로그와 메모리 부족의 결과만 얻게 될 것이다.</p>\n<p>여기가 흐름제어가 들어오는 곳이다. 렌더링을 핸들링하는 스트림은 초당 24회의 디코더 스트림으로 부터 프레임을 가져온다. 디코더는 읽혀지것 보다 프레임을 생성하는것이 더 빠르며 점점 느려진다고 알려져있다. 네트워크 스트림은 가져오는 데이터가 디코더에의해 읽혀지는 것 보다 빠르며 느리게 다운로드 된다고 알려져있다.</p>\n<p>스트림과 리더의 타이트한 관계 때문에 스트림은 오로지 하나의 리더만 가질 수 있다. 그러나 읽지 않은 스트림은 “티드(teed)”할 수 있는데, 이는 동일한 데이터를 두개의 스트림으로 나누는 것을 의미한다. 이 경우 티(tee)는 양 리더 모두를 통해 버퍼를 관리한다.</p>\n<p>좋다. 그것이 이론일 뿐이고 내 이야기에 전적으로 동의한다고 볼 수는 없지만, 당신이 계속해서 이야기를 듣길 바란다.</p>\n<p>브라우저 스트림은 기본적으로 많은 것을 로드한다. 다운로드하는 것 같은 페이지/이미지/비디오 등의 일부를 표시하는 브라우저를 볼 때마다 스트리밍 덕분이라는 것을 알아야 한다. 또한 그것은 최근에 스트림을 스크립트에 노출되게 한 <a href=\"https://streams.spec.whatwg.org/\">표준화 노력</a> 덕분이기도 하다.</p>\n<h2 id=\"스트림--패치fetch-api\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%BC--%ED%8C%A8%EC%B9%98fetch-api\" aria-label=\"스트림  패치fetch api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트림 + 패치(fetch) API</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response\">응답(response)</a> 객체는 <a href=\"https://fetch.spec.whatwg.org/#response-class\">패치 스펙(fetch spec)</a>에 정의된 대로, 다양한 형식으로 응답을 읽을 수 있게 한다. 하지만 <code class=\"tui-language-text\">response.body</code>는 근본적인 스트림에 엑세스 할 수 있게 한다.\n<code class=\"tui-language-text\">response.body</code>는 크롬의 현재 안정 버전에서 지원한다.</p>\n<p>스트림을 이용하면 메모리에 전체 응답을 유지하지 않고 헤더에 의존하지 않으면서 응답 내용의 길이를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token comment\">// fetch() returns a promise that</span>\n<span class=\"token comment\">// resolves once headers have been received</span>\n<span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// response.body is a readable stream.</span>\n  <span class=\"token comment\">// Calling getReader() gives us exclusive access to</span>\n  <span class=\"token comment\">// the stream's content</span>\n  <span class=\"token keyword\">var</span> reader <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">getReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> bytesReceived <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// read() returns a promise that resolves</span>\n  <span class=\"token comment\">// when a value has been received</span>\n  reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">processResult</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Result objects contain two properties:</span>\n    <span class=\"token comment\">// done  - true if the stream has already given</span>\n    <span class=\"token comment\">//         you all its data.</span>\n    <span class=\"token comment\">// value - some data. Always undefined when</span>\n    <span class=\"token comment\">//         done is true.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Fetch complete\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// result.value for fetch streams is a Uint8Array</span>\n    bytesReceived <span class=\"token operator\">+=</span> result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Received'</span><span class=\"token punctuation\">,</span> bytesReceived<span class=\"token punctuation\">,</span> <span class=\"token string\">'bytes of data so far'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Read some more, and call this function again</span>\n    <span class=\"token keyword\">return</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>processResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><a href=\"http://jsbin.com/vuqasa/edit?js,console\">데모 보기</a> (1.3mb)</p>\n<p>데모에서는 서버로부터 1.3mb의 gzip으로 압축된(압축전 7.7mb) HTML파일을 가져왔다.  그러나, 결과는 메모리에 저장되지 않는다. 각 조각의 사이즈는 기록되지만 조각들 자체는 GC(garbage collected)된다.</p>\n<p>result.value는 스트림이 제공하는 것은 무엇이든(string, number, date, ImageData, DOM엘리먼트, …) 간에 생성하지만, 이경우의 가져오는 스트림은 항상 이진 데이터 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\">Unit8Array</a>다. 전체 응답은 각각의 Unit8Array를 모아서 맞춘 것이다. 텍스트로 응답을 원한다면 아래 예제와 같이 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/TextDecoder\">TextDecoder</a>를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token keyword\">var</span> decoder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TextDecoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> reader <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">getReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// read() returns a promise that resolves</span>\n<span class=\"token comment\">// when a value has been received</span>\nreader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">processResult</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n    decoder<span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>stream<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Read some more, and recall this function</span>\n  <span class=\"token keyword\">return</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>processResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">{stream: true}</code>는 디코더의 버퍼 유지를 의미한다. 만약 <code class=\"tui-language-text\">result.value</code>가 UTF-8 코드 지점을 통과해 중간에서 종료된다면, <code class=\"tui-language-text\">♥</code>와 같은 문자는 3 bytes(<code class=\"tui-language-text\">[0xE2, 0x99, 0xA5]</code>)만 보여주게 된다.</p>\n<p>TextDecoder는 현재는 작고 볼품없지만 향후에는 변환 스트림(transform stream)이 될 가능성이 있다(한번의 변환 스트림은 정의되어있다). 변환 스트림은 <code class=\"tui-language-text\">.writable</code>에 쓰기 가능한 스트림과 <code class=\"tui-language-text\">.readable</code>에 읽을 수 있는 스트림 객체이다. 그것은 조각들을 쓰기가능하며 가공된 상태로 취해, 읽기 가능한 상태로 내보낸다. 변환 스트림을 사용예제는 다음과 같다.</p>\n<h6 id=\"hypothetical-future-code\" style=\"position:relative;\"><a href=\"#hypothetical-future-code\" aria-label=\"hypothetical future code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hypothetical future-code:</h6>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token keyword\">var</span> reader <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body\n  <span class=\"token punctuation\">.</span><span class=\"token function\">pipeThrough</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">TextDecoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nreader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// result.value will be a string</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>브라우저는 자신이 소유한 응답 스트림과 TextDocoder 변환 스트림 모두를 최적화할 수 있다.</p>\n<h4 id=\"가져오기fetch-취소하기\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0fetch-%EC%B7%A8%EC%86%8C%ED%95%98%EA%B8%B0\" aria-label=\"가져오기fetch 취소하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가져오기(fetch) 취소하기</h4>\n<p>스트림은 <code class=\"tui-language-text\">stream.cancel()</code>(패치의 경우 <code class=\"tui-language-text\">response.body.cancel()</code>을 사용한다)이나 <code class=\"tui-language-text\">reader.cancel()</code>을 사용하여 취소할 수 있다. 다운로드를 중지하여 반응을 얻어낸다.</p>\n<p><a href=\"https://jsbin.com/gameboy/edit?js,console\">데모 보기</a></p>\n<p>이 데모에서는 검색어로 큰 문서를 찾는데, 메모리에서 작은 일부분만을 유지하며, 일치하는 부분이 발견되면 가져오기를 멈춘다.</p>\n<p>어쨌든, 이 모든것은 2015년도 가능했던 일이다. 이제부터 재미있는 새로운 것에 대해 이야기하겠다.</p>\n<h2 id=\"자신의-읽을-수-있는-스트림을-생성하자\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%9D%BD%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EC%9E%90\" aria-label=\"자신의 읽을 수 있는 스트림을 생성하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자신의 읽을 수 있는 스트림을 생성하자</h2>\n<p>크롬 카나리아(Chrome Canary, 개발자 및 얼리어답터 용)에서 \"실험적인 웹 플랫폼 기능(<code class=\"tui-language-text\">Experimental web platform features</code>)\"을 활성화 시키면 바로 자신의 스트림(your own stream)을 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token keyword\">var</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadableStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">controller</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">pull</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">controller</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reason</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> queuingStrategy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"tui-language-text\">start</code>는 곧바로 호출된다.  이는 모든 기반 데이터 소스를 설정하는데 사용된다(문자열과 같은 이벤트, 다른 스트림 또는 변수 등에서 데이터를 얻을 때를 의미함). 만약 당신이 프라미스(promise)를 반환하고 거절한다면, 스트림을 통해 에러 신호를 보낼 것이다.</li>\n<li><code class=\"tui-language-text\">pull</code>은 스트림의 버퍼가 가득차지 않았을 때 호출되며, 가득찰 때 까지 호출된다. 다시말해 만약 당신이 프라미스를 반환하고 거절한다면, 스트림을 통해 에러 신호를 보낼 것이다. 또한, <code class=\"tui-language-text\">pull</code>은 완전한 프라미스가 반환될 때 까지 다시 호출되지 않을 것이다.</li>\n<li><code class=\"tui-language-text\">cancel</code>은 스트림이 취소되면 호출된다. 이는 모든 기본 데이터 소스를 취소 하는데 사용된다.</li>\n<li><code class=\"tui-language-text\">queuingStrategy</code>는 하나의 아이템에 기본적으로 얼마나 많은 스트림이 이론적으로 쌓이는지를 정의한다. - 더 자세한 사항은 <a href=\"https://streams.spec.whatwg.org/#blqs-class\">여기</a>를 참조하길 바란다.</li>\n</ul>\n<p>controller에 대해서는</p>\n<ul>\n<li><code class=\"tui-language-text\">controller.enqueue(whatever)</code> - 스트림 버퍼의 큐 데이터</li>\n<li><code class=\"tui-language-text\">controller.close()</code> - 스트림의 종료 신호</li>\n<li><code class=\"tui-language-text\">controller.error(e)</code> - 터미널 에러 신호</li>\n<li><code class=\"tui-language-text\">controller.desiredSize</code> - 남아있는 버퍼의 총량(버퍼가 가득차면 음수일 수 있음). 이 숫자는 <code class=\"tui-language-text\">queuingStrategy</code>를 사용하여 계산된다.</li>\n</ul>\n<p>그래서 나는 다음 예제와 같이 0.9보다 큰 숫자가 나올때 까지 매 초마다 랜덤 숫자가 생성되는 스트림 생성을 원했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token keyword\">var</span> interval<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadableStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">controller</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    interval <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// Add the number to the stream</span>\n      controller<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">></span> <span class=\"token number\">0.9</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Signal the end of the stream</span>\n        controller<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>interval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This is called if the reader cancels,</span>\n    <span class=\"token comment\">//so we should stop generating numbers</span>\n    <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>interval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><a href=\"https://jsbin.com/fahavoz/edit?js,console\">실행 결과를 보자.</a> (알림: 결과를 보려면 크롬 카나리아에서 <code class=\"tui-language-text\">chrome://flags/#enable-experimental-web-platform-features</code> 옵션을 활성화시켜야 함)</p>\n<p><code class=\"tui-language-text\">controller.enqueue</code>로 데이터를 통과 시키는 것은 직접 해보길 바란다. 위의 예제와 같이 보낼 데이터가 있을 때,  직접 만든 \"push source\" 스트림을 단순히 호출할 수 있다.<br>\n그대신에 <code class=\"tui-language-text\">pull</code>이 호출될 때 까지 기다릴 수 있다. 그런 후 기반 소스로 부터 수집한 데이타 신호를 사용한 다음 직접 만든 \"pull source\" 스트림을 대기열에 추가한다. 또는 원한다면, 두가지 방법을 조합할 수 도 있다.</p>\n<p><code class=\"tui-language-text\">controller.desiredSize</code>를 따르는 것은 가장 스트림이 효율적인 속도에 따라 데이터를 전달하는 것을 의미한다.  이것은 \"백프레셔(backpressure) 지원\"를 가지고 있다고 알려져 있는데, 이는 당신의 스트림이 리더의 읽는 속도에 반응한다는 것을 의미한다(이전의 비디오 디코딩 예제와 비슷함). 그러나 기기 메모리를 다 사용하지 않는 한 어떤 것도 <code class=\"tui-language-text\">desiredSize</code>를 무시하는 것은 중단시킬 수 없다. 해당 스펙은 <a href=\"https://streams.spec.whatwg.org/#example-rs-push-backpressure\">백프레셔와 스트림 생성하기</a>라는 좋은 예제를 갖고있다.</p>\n<p>그 자체로 스트림을 생성하는 것은 특히나 재미없다. 그리고 처음 사용하기 때문에,  지원하는 API들도 많지 않다. 그런것들 중 하나가 다음의 <code class=\"tui-language-text\">Response</code>다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span>readableStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>본문(<code class=\"tui-language-text\">body</code>)이 스트림인 HTTP 응답 객체를 생성할 수 있고, 서비스 워커로 부터 응답받은 것을 사용할 수 있다.</p>\n<h2 id=\"천천히-문자열-제공하기\" style=\"position:relative;\"><a href=\"#%EC%B2%9C%EC%B2%9C%ED%9E%88-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B8%B0\" aria-label=\"천천히 문자열 제공하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>천천히 문자열 제공하기</h2>\n<p><a href=\"https://jakearchibald.github.io/isserviceworkerready/demos/simple-stream/\">데모 보기</a> (알림: 결과를 보려면 크롬 카나리아에서 <code class=\"tui-language-text\">chrome://flags/#enable-experimental-web-platform-features</code> 옵션을 활성화시켜야 함) </p>\n<p>당신은 HTML 페이지가 천천히(계획적으로) 렌더링 되는것을 볼 수 있을 것이다. 이 응답은 전적으로 서비스 워커에서 발생시킨 것이다. 여기 그 코드가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token comment\">// In the service worker:</span>\nself<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetch'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> html <span class=\"token operator\">=</span> <span class=\"token string\">'…html to serve…'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">var</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadableStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">controller</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> encoder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TextEncoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// Our current position in `html`</span>\n      <span class=\"token keyword\">var</span> pos <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// How much to serve on each push</span>\n      <span class=\"token keyword\">var</span> chunkSize <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">function</span> <span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Are we done?</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pos <span class=\"token operator\">>=</span> html<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          controller<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// Push some of the html,</span>\n        <span class=\"token comment\">// converting it into an Uint8Array of utf-8 data</span>\n        controller<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>\n          encoder<span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>html<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>pos<span class=\"token punctuation\">,</span> pos <span class=\"token operator\">+</span> chunkSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// Advance the position</span>\n        pos <span class=\"token operator\">+=</span> chunkSize<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// push again in ~5ms</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>push<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\">// Let's go!</span>\n      <span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span>stream<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    headers<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'Content-Type'</span><span class=\"token operator\">:</span> <span class=\"token string\">'text/html'</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>브라우저에서 응답 본문을 읽을 때 <code class=\"tui-language-text\">Unit8Array</code>의 조각으로 얻을 것을 기대한다. 만일 플레인 문자열과 같이 어떤 다른것이 통과 된다면 그것은 실패한다. 고맙게도 <code class=\"tui-language-text\">TextEncoder</code>는 문자열을 가지고 문자열을 표현하는 바이트의 <code class=\"tui-language-text\">Unit8Array</code>로 반환할 수 있다.</p>\n<p><code class=\"tui-language-text\">TextDecode</code> 처럼, <code class=\"tui-language-text\">TextEncoder</code>는 앞으로 스트림으로 변환 될 것이다.</p>\n<h2 id=\"변환된-스트림-제공하기\" style=\"position:relative;\"><a href=\"#%EB%B3%80%ED%99%98%EB%90%9C-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B8%B0\" aria-label=\"변환된 스트림 제공하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변환된 스트림 제공하기</h2>\n<p>이미 말했듯이 변환 스트림은 아직 정의되지 않았다. 그러나 다른 스트림에서 데이터 소스를 공급하는 읽을 수 있는 스트림(readable stream)을 생성하여 비슷한 결과를 얻을 수 있다.</p>\n<h4 id=\"a-namecloud-to-buttacloud를-butt로\" style=\"position:relative;\"><a href=\"#a-namecloud-to-buttacloud%EB%A5%BC-butt%EB%A1%9C\" aria-label=\"a namecloud to buttacloud를 butt로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a name=\"cloud-to-butt\"></a>\"cloud\"를 \"butt\"로</h4>\n<p><a href=\"https://jakearchibald.github.io/isserviceworkerready/demos/transform-stream/\">데모 보기</a> (알림: 결과를 보려면 크롬 카나리아에서 chrome://flags/#enable-experimental-web-platform-features 옵션을 활성화시켜야 함)</p>\n<p>당신이 볼 수 있는 것은 <a href=\"https://jakearchibald.github.io/isserviceworkerready/demos/transform-stream/cloud.html\">이 페이지</a>(위키피디아에있는 클라우드 컴퓨팅 아티클에서 얻은)이지만, 모든 \"cloud\"라는 단어가 \"butt\"로 대체된 것이다. 스트림으로 하는 것의 이점은 원본을 다운로드 하는 동안 화면에 변환된 콘텐츠를 얻을 수 있다는 것이다.</p>\n<p>다음은 엣지 케이스 일부분의 상세내용을 포함한 코드가 있는 링크다.\n<a href=\"https://github.com/jakearchibald/isserviceworkerready/blob/master/src/demos/transform-stream/sw.js\">https://github.com/jakearchibald/isserviceworkerready/blob/master/src/demos/transform-stream/sw.js</a></p>\n<h4 id=\"a-namempeg-to-gifampeg에서-gif로\" style=\"position:relative;\"><a href=\"#a-namempeg-to-gifampeg%EC%97%90%EC%84%9C-gif%EB%A1%9C\" aria-label=\"a namempeg to gifampeg에서 gif로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a name=\"mpeg-to-gif\"></a>MPEG에서 GIF로</h4>\n<p>비디오 코덱은 정말 효율적이지만, 모바일에서 자동실행은 불가능하다. GIF는 자동실행이 가능하지만 비용이 크다. 진짜로 멍청한 솔루션이 여기에 있다.</p>\n<p><a href=\"https://jakearchibald.github.io/isserviceworkerready/demos/gif-stream/\">데모 보기</a> (알림: 결과를 보려면 크롬 카나리아에서 chrome://flags/#enable-experimental-web-platform-features 옵션을 활성화시켜야 함)</p>\n<p>MPEG 프레임 디코딩을 하는 동안 GIF의 첫번째 프레임이 표시될 수 있는 지금의 상황에는 스트리밍은 유용하다.</p>\n<p>그렇기 때문에 사용해야 하는 것이다! 26mb GIF를 오로지 0.9mb의 MPEG를 사용하여 전달하는데, 실시간으로 되지 않고 CPU를 많이 사용한다는 것을 제외하면 완벽하다! 브라우저는 모바일에서 비디오 자동실행을 정말 허용해야한다. 음소거를 사용할 경우는 특히나 그렇다. 이것은 크롬이 지금 당장 노력해야 핸다.</p>\n<p>완전 공개:  나는 데모에서 꼼수를 부렸다. 모든 MPEG를 시작전에 다운로드 받아놨다. 나는 네트워크로 부터 스트리밍을 얻길 원했지만 스킬이 부족하여(원문: <code class=\"tui-language-text\">OutOfSkillError</code>)로 실행할 수 없었다. 또한 GIF는 정말이지 다운로드 동안 반복하면 않아야 하지만, 지금은 반복되고 있다.</p>\n<h2 id=\"페이지-렌더-시간을-소모하여-멀티-소스로부터-하나의-스트림-생성하기\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A0%8C%EB%8D%94-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%86%8C%EB%AA%A8%ED%95%98%EC%97%AC-%EB%A9%80%ED%8B%B0-%EC%86%8C%EC%8A%A4%EB%A1%9C%EB%B6%80%ED%84%B0-%ED%95%98%EB%82%98%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"페이지 렌더 시간을 소모하여 멀티 소스로부터 하나의 스트림 생성하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 렌더 시간을 소모하여 멀티 소스로부터 하나의 스트림 생성하기</h2>\n<p>이것은 아마도 서비스워크 + 스트림 조합의 가장 현실적인 적용이다. 장점은 성능면에서 크다.</p>\n<p>몇개월 전에 나는 <a href=\"https://wiki-offline.jakearchibald.com/\">오프라인 우선 위키피디아</a>의 데모를 개발했다. 나는 빠르게 동작하며 현대적인 확장 기능이 추가된 정말 혁신적인 웹앱을 만들기를 원했다.</p>\n<p>OSX 의 네트워크 연결 컨디셔너를 사용하여 시뮬레이션한 손실 3G 연결 기반에 대해 성능과 수치적인 부분에 대해서 이야기하겠다.</p>\n<p>서비스 워커 없이 표현 컨텐츠는 서버로 보내졌다. 여기 성능에 많은 노력을 기울였고 그에 대한 성과를 얻었다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/2888775/13210633/73055a16-d974-11e5-9383-b6fb29b5ffaf.png\" alt=\"1\"></p>\n<p><a href=\"https://wiki-offline.jakearchibald.com/wiki/Google?use-url-flags&#x26;prevent-sw=1\">데모 보기</a></p>\n<p>나쁘지는 않았다. 약간의 오프라인 우선에 좋은 부분을 혼합하여 성능 더욱을 향상시킬 수 있는 서비스 워커를 추가했다. 그리고 결과는?</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/2888775/13210634/730669c4-d974-11e5-9641-5bcd2911aeef.png\" alt=\"2\"></p>\n<p><a href=\"https://wiki-offline.jakearchibald.com/wiki/Google?use-url-flags&#x26;client-render=1&#x26;prevent-streaming=1&#x26;no-prefetch\">데모 보기</a></p>\n<p>음... 우선 렌더링이 더 빨라졌다. 그러나 컨텐츠 렌더링 시에 큰 퇴보가 발생했다.</p>\n<p>가장 빠른 방법은 캐쉬에서 진입 페이지를 제공하는 것이다. 그러나 그것은 위키피디아의 모든 캐싱을 가지고 있어야 한다. 그대신에 나는 CSS, 자바스크립트 그리고 헤더를 제공했다. 빠른 초기 렌더링을 얻고 그런 후 문서의 내용을 가져오는 것에 대한 페이지의 자바스크립트 설정을 했다. 그리고 그곳이 내가 모든 성능을 잃어버린 클라이언트 사이드 렌더링이다.</p>\n<p>서버로부터 직접 제공받든 아니면 서비스 워커를 통하든, 다운로드된 HTML을 렌더링 한다. 그러나 나는 자바스크립트를 사용한 페이지로부터 내용을 가져왔다. 그런 후 스트리밍 파서를 우회하여 <code class=\"tui-language-text\">innerHTML</code>로 추가했다. 이 때문에 내용이 표시되기 전에 완전히 다운로드 되었고, 2초 더 느려졌다. 다운로드하는 컨텐츠가 많아질 수 록 스트리밍 성능 손해는 더 늘어날 것이다. 그러나 나에게는 불행하게도 위키피디아 문서는 매우 크다(구글 문서는 100k).</p>\n<p>이것이 내가 자바스크립트 기반의 웹 앱과 프레임워크에 대해 투털되는 이유다 - 그들은 0단계로 스트리밍을 버리는 경향이 있고 그 결과 성능이 더 안좋아진다.</p>\n<p>나는 프리패칭(prefetching)과 가짜 스트리밍을 사용하여 성능을 되돌리기 위해 노렸했다. 가짜 스트리밍은 특히나 더한 꼼수다. 페이지는 문서의 내용을 가져와 스트림으로 읽는다. 먼저 내용의 9k를 받아 <code class=\"tui-language-text\">innerHTML</code>로 추가하고 다시 나머지 내용을 추가한다. 이것은 일부 엘리먼트를 두번  생성하기 때문에 끔찍하지만, 그만큼의 가치는 있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/2888775/13210635/7307b8e2-d974-11e5-9c9a-ec28f078eea3.png\" alt=\"3\"></p>\n<p><a href=\"https://wiki-offline.jakearchibald.com/wiki/Google?use-url-flags&#x26;client-render=1\">데모 보기</a></p>\n<p>꼼수들은 문서 내용이 보여지는 시간을 개선하지만, 여전히 납득하기 힘들 만큼 서버 렌더링에 비해 뒤쳐진다. 뿐만아니라 <code class=\"tui-language-text\">innerHTML</code>을 사용하여 페이지에 추가된 내용은 일반적으로 구문 분석된 내용과 동일하게 동작하지 않는다. 특히 인라인 <code class=\"tui-language-text\">&lt;script&gt;</code>는 실행되지 않는다.</p>\n<p>여기가 스트림이 개입 할 곳이다. 빈 껍데기만 제공하고 JS에게 만드는 역할을 맡기는 대신 캐시로 부터 온 헤더에서 서비스 워커에게 스트림을 생성하도록 했다.그러나 본문은 네트워크로 부터 온다. 그것은 서버 렌더링과 같지만 서비스 워커를 이용한 것이다.</p>\n<p><a name=\"fastest\"></a><img src=\"https://cloud.githubusercontent.com/assets/2888775/13210636/730f8194-d974-11e5-816c-eea3c17ada9c.png\" alt=\"4\"></p>\n<p><a href=\"https://wiki-offline.jakearchibald.com/wiki/Google?sw-stream\">데모 보기</a> (알림: 결과를 보려면 크롬 카나리아에서 chrome://flags/#enable-experimental-web-platform-features 옵션을 활성화시켜야 함)</p>\n<p>서비스 워크 + 스트림 조합을 사용하는 것은 거의 짧은 순간에 첫번째 렌더링을 할 수 있다는 것을 의미한다. 그런다음 네트워크로 부터 내용의 작은양만 파이핑하여 일반 서버 렌더링을 수행하면 된다.</p>\n<p>내용은 일반적인 HTML 파서로 통과된다. 그래서 당신은 스트리밍을 얻게되고 그것은 수동으로 DOM으로 부터 추가된 컨텐츠를 얻는 것과 다르지 않다.</p>\n<h6 id=\"렌더링-시간-비교\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%8B%9C%EA%B0%84-%EB%B9%84%EA%B5%90\" aria-label=\"렌더링 시간 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 시간 비교</h6>\n<p><a href=\"http://www.youtube.com/watch?v=Cjo9iq8k-bc\"><img src=\"http://img.youtube.com/vi/Cjo9iq8k-bc/0.jpg\" alt=\"IMAGE ALT TEXT HERE\"></a></p>\n<h4 id=\"스트림-교차하기\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EA%B5%90%EC%B0%A8%ED%95%98%EA%B8%B0\" aria-label=\"스트림 교차하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트림 교차하기</h4>\n<p>결합된 스트림은 파이핑(piping)을 지원하지 않기 때문에, 스트림을 결합하는 것은 조금 지저분하게 수동으로 수행해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token keyword\">var</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadableStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">controller</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Get promises for response objects for each page part</span>\n    <span class=\"token comment\">// The start and end come from a cache</span>\n    <span class=\"token keyword\">var</span> startFetch <span class=\"token operator\">=</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/page-start.inc'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> endFetch <span class=\"token operator\">=</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/page-end.inc'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// The middle comes from the network, with a fallback</span>\n    <span class=\"token keyword\">var</span> middleFetch <span class=\"token operator\">=</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/page-middle.inc'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/page-offline-middle.inc'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">pushStream</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">stream</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Get a lock on the stream</span>\n      <span class=\"token keyword\">var</span> reader <span class=\"token operator\">=</span> stream<span class=\"token punctuation\">.</span><span class=\"token function\">getReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">return</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// Push the value to the combined stream</span>\n        controller<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// Read more &amp; process</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Get the start response</span>\n    startFetch\n      <span class=\"token comment\">// Push its contents to the combined stream</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token function\">pushStream</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">// Get the middle response</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> middleFetch<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">// Push its contents to the combined stream</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token function\">pushStream</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">// Get the end response</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> endFetch<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">// Push its contents to the combined stream</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token function\">pushStream</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">// Close our stream, we're done!</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> controller<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>출력물을 스트림하고 템플릿 안에 포함된 값을 스트림으로 처리하며 내용에 대한 파이핑(piping)과 심지어 즉석에서 HTML 이스케이핑하는 <a href=\"http://www.dustjs.com/\">Dust.js</a>와 같은 일부 템플릿팅 언어가 있다. 빠트린 것이라곤 웹 스트림 지원이다.</p>\n<h2 id=\"스트림의-미래\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%98-%EB%AF%B8%EB%9E%98\" aria-label=\"스트림의 미래 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트림의 미래</h2>\n<p>읽을 수 있는 스트림 외의 스펙이 아직 개발되고 있음에도, 이미 사용할 수 있다는 것은 매우 놀라운 일이다. 만약 컨텐츠가 많은 사이트의  성능을 개선하면서 구조의 근본적인 변화 없는 오프라인 우선 경험을 제공하기 원한다면, 서비스 워커로 스트림을 구성하는 것이 가장 쉬운 방법이 될 것이다. 그것은 어쨌든 내가 생각하는 블로그가 오프라인 우선 작업을 하게하는 방법이다!</p>\n<p>웹에서 초기의 스트림을 갖는 것은 우리가 브라우저가 이미 보유하고 있는 스트리밍 능력에 대해 스크립트로의 접근을 시작할 수 있다는 것을 의미한다. 다음과 같이…</p>\n<ul>\n<li>Gzip/무손실 압축(deflate)</li>\n<li>오디오/비디오 코덱</li>\n<li>이미지 코덱</li>\n<li>HTMl/XML 스트리밍 파서</li>\n</ul>\n<p>아직은 초기지만 만약 당신이 스트림에 대해 자신의 API를 준비하기 시작한다면, 일부 경우에 대해서 폴리필(polyfill)을 사용할 수 있는 <a href=\"https://github.com/whatwg/streams/tree/master/reference-implementation/\">참조 구현(reference implementation)</a>은 있다.</p>\n<p>스트리밍은 브라우저의 가장 큰 자산 중 하나다. 그리고 2016년은 자바스크립트에 의해 잠금 해제되는 해다.</p>","frontmatter":{"id":"ko_20160222","title":"2016년은 웹 스트림(web stream)의 해다.","description":"그렇다. 신년 초부터 한해의 일에 대해 이야기한다는 것은 가벼운 일은 아니다. 그러나 웹 스트림 API의 잠재력은 나를 매우 흥분 시켰기에 그런 일을 가능하게 했다. 요약하면, 스트림은 \"cloud\"라는 단어를 \"butt\"로 변경하거나 MPEG를 GIF로 변환하는 작업과 같이 익숙한 일들을 할 수 있다. 그러나 가장 중요한 것은 제공 내용을 가장 빠르게 서비스 워커로 결합시킬 수 있다는 것이다.","date":"2016.02.22","author":"강지웅","tags":["browser","performance"],"thumbnail":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20160222","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}