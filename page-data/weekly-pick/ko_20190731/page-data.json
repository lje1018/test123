{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20190731","result":{"data":{"post":{"html":"<p><img src=\"https://user-images.githubusercontent.com/37766175/62363267-f219ba80-b559-11e9-9943-855d42b2fc11.png\" alt=\"instruments\"></p>\n<h1 id=\"reactmemo-현명하게-사용하기\" style=\"position:relative;\"><a href=\"#reactmemo-%ED%98%84%EB%AA%85%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"reactmemo 현명하게 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo() 현명하게 사용하기</h1>\n<blockquote>\n<p>원문: <a href=\"https://dmitripavlutin.com/use-react-memo-wisely\">https://dmitripavlutin.com/use-react-memo-wisely</a></p>\n</blockquote>\n<p>유저들은 반응이 빠른 UI를 선호한다. 100ms 미만의 UI 응답 지연은 유저들이 즉시 느낄 수 있고, 100ms에서 300ms가 지연되면 이미 유저들은 상당한 지연으로 느낀다.</p>\n<p>UI 성능을 증가시키기 위해, React는 고차 컴퍼넌트(Higher Order Component, HOC) <code class=\"tui-language-text\">React.memo()</code>를 제공한다. 렌더링 결과를 메모이징(Memoizing)함으로써, 불필요한 리렌더링을 건너뛴다.</p>\n<p>이 글은 언제 <code class=\"tui-language-text\">React.memo()</code>가 성능을 향상하는데 도움이 되는지, 언제 불필요한지 구분하는 데 도움이 될 것이다.</p>\n<p>추가로 당신이 알아두면 좋을 쓸만한 메모이제이션(Memoization) 팁 또한 설명할 것이다.</p>\n<h2 id=\"1-reactmemo\" style=\"position:relative;\"><a href=\"#1-reactmemo\" aria-label=\"1 reactmemo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. React.memo()</h2>\n<p>React는 먼저 컴퍼넌트를 렌더링(rendering) 한 뒤, 이전 렌더된 결과와 비교하여 DOM 업데이트를 결정한다. 만약 렌더 결과가 이전과 다르다면, React는 DOM을 업데이트한다.</p>\n<p>다음 렌더링 결과와 이전 결과의 비교는 빠르다. 하지만 어떤 상황에서는 이 과정의 속도를 좀 더 높일 수 있다.</p>\n<p>컴퍼넌트가 <code class=\"tui-language-text\">React.memo()</code>로 래핑 될 때, React는 컴퍼넌트를 렌더링하고 결과를 메모이징(Memoizing)한다. 그리고 다음 렌더링이 일어날 때 <code class=\"tui-language-text\">props</code>가 같다면, React는 메모이징(Memoizing)된 내용을 재사용한다.</p>\n<p>예시를 살펴보자. 함수형 컴퍼넌트 <code class=\"tui-language-text\">Movie</code>가 <code class=\"tui-language-text\">React.memo()</code>로 래핑 되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Movie</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">,</span> releaseDate <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Movie title<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Release date<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>releaseDate<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> MemoizedMovie <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>Movie<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">React.memo(Movie)</code>는 새로 메모이징된 컴퍼넌트인 <code class=\"tui-language-text\">MemoizedMovie</code>를 반환한다. 한 가지 차이점을 제외하고 원래의 <code class=\"tui-language-text\">Movie</code> 컴퍼넌트와 같은 결과를 나타낼 것이다.</p>\n<p><code class=\"tui-language-text\">MemoizedMovie</code>의 렌더링 결과는 메모이징 되어있다. 만약 <code class=\"tui-language-text\">title</code>이나 <code class=\"tui-language-text\">releaseData</code> 같은 <code class=\"tui-language-text\">props</code>가 변경 되지 않는다면 다음 렌더링 때 메모이징 된 내용을 그대로 사용하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// 첫 렌더이다. React는 MemoizedMovie 함수를 호출한다.</span>\n<span class=\"token operator\">&lt;</span>MemoizedMovie\n  movieTitle<span class=\"token operator\">=</span><span class=\"token string\">\"Heat\"</span>\n  releaseDate<span class=\"token operator\">=</span><span class=\"token string\">\"December 15, 1995\"</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">></span>\n\n<span class=\"token comment\">// 다시 렌더링 할 때 React는 MemoizedMovie 함수를 호출하지 않는다.</span>\n<span class=\"token comment\">// 리렌더링을 막는다.</span>\n<span class=\"token operator\">&lt;</span>MemoizedMovie\n  movieTitle<span class=\"token operator\">=</span><span class=\"token string\">\"Heat\"</span>\n  releaseDate<span class=\"token operator\">=</span><span class=\"token string\">\"December 15, 1995\"</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>메모이징 한 결과를 재사용 함으로써, React에서 리렌더링을 할 때 가상 DOM에서 달라진 부분을 확인하지 않아 성능상의 이점을 누릴 수 있다.</p>\n<p>클래스 컴퍼넌트 또한 <a href=\"https://reactjs.org/docs/react-api.html#reactpurecomponent\">PureComponent</a>로 동일한 내용이 구현되어 있다.</p>\n<h3 id=\"11-props-동등-비교-커스터마이징\" style=\"position:relative;\"><a href=\"#11-props-%EB%8F%99%EB%93%B1-%EB%B9%84%EA%B5%90-%EC%BB%A4%EC%8A%A4%ED%84%B0%EB%A7%88%EC%9D%B4%EC%A7%95\" aria-label=\"11 props 동등 비교 커스터마이징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1 props 동등 비교 커스터마이징</h3>\n<p><code class=\"tui-language-text\">React.memo()</code>는 props 혹은 props의 객체를 비교할 때 <a href=\"https://github.com/facebook/react/blob/v16.8.6/packages/shared/shallowEqual.js\">얕은(shallow)</a> 비교를 한다.</p>\n<p>비교 방식을 수정하고 싶다면 <code class=\"tui-language-text\">React.memo()</code> 두 번째 매개변수로 비교함수를 만들어 넘겨주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>Component<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token function\">areEqual</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">areEqual(prevProps, nextProps)</code> 함수는 <code class=\"tui-language-text\">prevProps</code>와 <code class=\"tui-language-text\">nextProps</code>가 같다면 <code class=\"tui-language-text\">true</code>를 반환할 것이다.</p>\n<p>예를들어 <code class=\"tui-language-text\">Movie</code>의 <code class=\"tui-language-text\">props</code>가 동일한지 수동으로 비교해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">moviePropsAreEqual</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevMovie<span class=\"token punctuation\">,</span> nextMovie</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    prevMovie<span class=\"token punctuation\">.</span>title <span class=\"token operator\">===</span> nextMovie<span class=\"token punctuation\">.</span>title <span class=\"token operator\">&amp;&amp;</span>\n    prevMovie<span class=\"token punctuation\">.</span>releaseDate <span class=\"token operator\">===</span> nextMovie<span class=\"token punctuation\">.</span>releaseDate\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> MemoizedMovie2 <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>Movie<span class=\"token punctuation\">,</span> moviePropsAreEqual<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">moviePropsAreEqual()</code> 함수는 이전 <code class=\"tui-language-text\">props</code>와 현재 <code class=\"tui-language-text\">props</code>가 같다면 <code class=\"tui-language-text\">true</code>를 반환할 것이다.</p>\n<h2 id=\"2-언제-reactmemo를-써야할까\" style=\"position:relative;\"><a href=\"#2-%EC%96%B8%EC%A0%9C-reactmemo%EB%A5%BC-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"2 언제 reactmemo를 써야할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 언제 React.memo()를 써야할까</h2>\n<p><img src=\"https://dmitripavlutin.com/static/c07d2ce4ede6301197b9605a75ae9b4e/711ea/when-to-use-react-memo-infographic.jpg\" alt=\"image2.png\"></p>\n<h3 id=\"21-같은-props로-렌더링이-자주-일어나는-컴퍼넌트\" style=\"position:relative;\"><a href=\"#21-%EA%B0%99%EC%9D%80-props%EB%A1%9C-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EC%9E%90%EC%A3%BC-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%BB%B4%ED%8D%BC%EB%84%8C%ED%8A%B8\" aria-label=\"21 같은 props로 렌더링이 자주 일어나는 컴퍼넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 같은 props로 렌더링이 자주 일어나는 컴퍼넌트</h3>\n<p><code class=\"tui-language-text\">React.memo()</code>는 함수형 컴퍼넌트에 적용되어 같은 props에 같은 렌더링 결과를 제공한다.</p>\n<p><code class=\"tui-language-text\">React.memo()</code>를 사용하기 가장 좋은 케이스는 함수형 컴퍼넌트가 같은 <code class=\"tui-language-text\">props</code>로 자주 렌더링 될거라 예상될 때이다.</p>\n<p>일반적으로 부모 컴퍼넌트에 의해 하위 컴퍼넌트가 같은 props로 리렌더링 될 때가 있다.</p>\n<p>위에서 정의한 <code class=\"tui-language-text\">Movie</code>를 다시 사용해서 예시를 들어보자. 여기 <code class=\"tui-language-text\">Movie</code>의 부모 컴퍼넌트인 실시간으로 업데이트되는 영화 조회수를 나타내는 <code class=\"tui-language-text\">MovieViewsRealtime</code> 컴퍼넌트가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">MovieViewsRealtime</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">,</span> releaseDate<span class=\"token punctuation\">,</span> views <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Movie title<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span> releaseDate<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>releaseDate<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      Movie views<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>views<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 어플리케이션은 주기적(매초)으로 서버에서 데이터를 폴링(Polling)해서 <code class=\"tui-language-text\">MovieViewsRealtime</code> 컴퍼넌트의 <code class=\"tui-language-text\">views</code>를 업데이트한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"tui-language-jsx\"><code class=\"tui-language-jsx\"><span class=\"token comment\">// Initial render</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MovieViewsRealtime</span></span>\n  <span class=\"token attr-name\">views</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Forrest Gump<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">releaseDate</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>June 23, 1994<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span>\n\n<span class=\"token comment\">// After 1 second, views is 10</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MovieViewsRealtime</span></span>\n  <span class=\"token attr-name\">views</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Forrest Gump<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">releaseDate</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>June 23, 1994<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span>\n\n<span class=\"token comment\">// After 2 seconds, views is 25</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MovieViewsRealtime</span></span>\n  <span class=\"token attr-name\">views</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">25</span><span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Forrest Gump<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">releaseDate</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>June 23, 1994<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span>\n\n<span class=\"token comment\">// etc</span></code></pre></div>\n<p><code class=\"tui-language-text\">views</code>가 새로운 숫자가 업데이트 될 때 마다 <code class=\"tui-language-text\">MoviewViewsRealtime</code> 컴퍼넌트 또한 리렌더링 된다. 이때 <code class=\"tui-language-text\">Movie</code> 컴퍼넌트 또한 <code class=\"tui-language-text\">title</code>이나 <code class=\"tui-language-text\">releaseData</code>가 같음에도 불구하고 리렌더링 된다.</p>\n<p>이때가 <code class=\"tui-language-text\">Movie</code> 컴퍼넌트에 메모이제이션을 적용할 적절한 케이스다.</p>\n<p><code class=\"tui-language-text\">MovieViewsRealtime</code>에 메모이징된 컴퍼넌트인 <code class=\"tui-language-text\">MemoizedMovie</code>를 대신 사용해 성능을 향상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">MovieViewsRealtime</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">,</span> releaseDate<span class=\"token punctuation\">,</span> views <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>MemoizedMovie title<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span> releaseDate<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>releaseDate<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      Movie views<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>views<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"tui-language-text\">title</code> 혹은 <code class=\"tui-language-text\">releaseDate</code> props가 같다면, React는 <code class=\"tui-language-text\">MemoizedMovie</code>를 리렌더링 하지 않을 것이다. 이렇게 <code class=\"tui-language-text\">MovieViewsRealtime</code> 컴퍼넌트의 성능을 향상할 수 있다.</p>\n<blockquote>\n<p>컴퍼넌트가 같은 props로 자주 렌더링되거나, 무겁고 비용이 큰 연산이 있는 경우, <code class=\"tui-language-text\">React.memo()</code>로 컴퍼넌트를 래핑할 필요가 있다.</p>\n</blockquote>\n<p><a href=\"https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab\">profiling</a>을 통해 <code class=\"tui-language-text\">React.memo()</code>의 이점을 측정해봐라</p>\n<p><em>추가적으로 적절한 상황이 있다면 <a href=\"https://dmitripavlutin.com/use-react-memo-wisely\">이 글</a>의 댓글로 남겨주기 바란다!</em></p>\n<h2 id=\"3-언제-reactmemo를-사용하지-말아야-할까\" style=\"position:relative;\"><a href=\"#3-%EC%96%B8%EC%A0%9C-reactmemo%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"3 언제 reactmemo를 사용하지 말아야 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 언제 React.memo()를 사용하지 말아야 할까</h2>\n<p>만약 위에서 언급한 상황에 일치하지 않는다면 <code class=\"tui-language-text\">React.memo()</code>를 사용할 필요가 없을 가능성이 높다.</p>\n<p>경험적으로, 성능적인 이점을 얻지 못한다면 메모이제이션을 사용하지 않는것이 좋다.</p>\n<blockquote>\n<p>성능 관련 변경이 잘못 적용 된다면 성능이 오히려 악화될 수 있다. <code class=\"tui-language-text\">React.memo()</code>를 현명하게 사용하라.</p>\n</blockquote>\n<p>또한, 기술적으로는 가능하지만 클래스 기반의 컴퍼넌트를 <code class=\"tui-language-text\">React.memo()</code>로 래핑하는것은 적절하지 않다. 클래스 기반의 컴퍼넌트에서 메모이제이션이 필요하다면 <code class=\"tui-language-text\">PureComponent</code>를 확장하여 사용하거나, <code class=\"tui-language-text\">shouldComponentUpdate()</code> 메서드를 구현하는 것이 적절하다.</p>\n<h3 id=\"31-쓸모없는-props-비교\" style=\"position:relative;\"><a href=\"#31-%EC%93%B8%EB%AA%A8%EC%97%86%EB%8A%94-props-%EB%B9%84%EA%B5%90\" aria-label=\"31 쓸모없는 props 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1 쓸모없는 props 비교</h3>\n<p>렌더링될 때 <code class=\"tui-language-text\">props</code>가 다른 경우가 대부분인 컴포넌트를 생각해보면, 메모이제이션 기법의 이점을 얻기 힘들다.</p>\n<p><code class=\"tui-language-text\">props</code>가 자주 변하는 컴퍼넌트를 <code class=\"tui-language-text\">React.memo()</code>로 래핑할지라도, React는 두 가지 작업을 리렌더링 할 때마다 수행할 것이다.</p>\n<ol>\n<li>이전 <code class=\"tui-language-text\">props</code>와 다음 <code class=\"tui-language-text\">props</code>의 동등 비교를 위해 비교 함수를 수행한다.</li>\n<li>비교 함수는 거의 항상 <code class=\"tui-language-text\">false</code>를 반환할 것이기 때문에, React는 이전 렌더링 내용과 다음 렌더링 내용을 비교할 것이다.</li>\n</ol>\n<p>비교 함수의 결과는 대부분 <code class=\"tui-language-text\">false</code>를 반환하기에 <code class=\"tui-language-text\">props</code> 비교는 불필요하게 된다.</p>\n<h2 id=\"4-reactmemo-와-콜백-함수\" style=\"position:relative;\"><a href=\"#4-reactmemo-%EC%99%80-%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98\" aria-label=\"4 reactmemo 와 콜백 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. React.memo() 와 콜백 함수</h2>\n<p>함수 객체는 \"일반\" 객체와 동일한 비교 원칙을 따른다. 함수 객체는 오직 자신에게만 동일하다.</p>\n<p>몇가지 함수를 비교해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">sumFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> sum1 <span class=\"token operator\">=</span> <span class=\"token function\">sumFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> sum2 <span class=\"token operator\">=</span> <span class=\"token function\">sumFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sum1 <span class=\"token operator\">===</span> sum2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sum1 <span class=\"token operator\">===</span> sum1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sum2 <span class=\"token operator\">===</span> sum2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// => true</span></code></pre></div>\n<p><code class=\"tui-language-text\">sumFactory()</code>는 팩토리 함수이다. 이 함수는 2가지 숫자를 더해주는 화살표 함수를 반환한다.</p>\n<p>함수 <code class=\"tui-language-text\">sum1</code>과 <code class=\"tui-language-text\">sum2</code>는 팩토리에 의해 생성된 함수다. 두 함수 모두 두 숫자를 더해주는 함수이다. 그러나 <code class=\"tui-language-text\">sum1</code>과 <code class=\"tui-language-text\">sum2</code>는 다른 함수 객체이다.</p>\n<p>부모 컴퍼넌트가 자식 컴퍼넌트의 콜백 함수를 정의한다면, 새 함수가 암시적으로 생성될 수 있다. 이것이 어떻게 메모이제이션을 막는지 보고, 수정해보자.</p>\n<p><code class=\"tui-language-text\">Logout</code> 컴퍼넌트는 콜백 <code class=\"tui-language-text\">prop</code>인 <code class=\"tui-language-text\">onLogout</code>을 갖는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Logout</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> username<span class=\"token punctuation\">,</span> onLogout <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onLogout<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>Logout <span class=\"token punctuation\">{</span>username<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> MemoizedLogout <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>Logout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>함수의 동등성이란 함정 때문에, 메모이제이션을 적용할 때는 콜백을 받는 컴퍼넌트 관리에 주의해야한다. 리렌더를 할 때 마다 부모 함수가 다른 콜백 함수의 인스턴스를 넘길 가능성이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">MyApp</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> store<span class=\"token punctuation\">,</span> cookies <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"main\"</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>header<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>MemoizedLogout\n          username<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>store<span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">}</span>\n          onLogout<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> cookies<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>header<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>store<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>동일한 <code class=\"tui-language-text\">username</code> 값이 전달되더라고, <code class=\"tui-language-text\">MemoizedLogout</code>은 새로운 <code class=\"tui-language-text\">onLogout</code> 콜백 때문에 리렌더링을 하게 된다.</p>\n<p>메모이제이션이 중단되게 되는 것이다.</p>\n<p>이 문제를 해결하려면 <code class=\"tui-language-text\">onLogout</code> prop의 값을 매번 동일한 콜백 인스턴스로 설정해야만 한다.<a href=\"https://reactjs.org/docs/hooks-reference.html#usecallback\">useCallback()</a>을 이용해서 콜백 인스턴스를 보존시켜보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> MemoizedLogout <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>Logout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">MyApp</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> store<span class=\"token punctuation\">,</span> cookies <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> onLogout <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    cookies<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"main\"</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>header<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>MemoizedLogout username<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>store<span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">}</span> onLogout<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onLogout<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>header<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>store<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"tui-language-text\">useCallback(() =&gt; { cookies.clear() }, [])</code> 는 항상 같은 함수 인스턴스를 반환한다. <code class=\"tui-language-text\">MemoizedLogout</code>의 메모이제이션이 정상적으로 동작하도록 수정되었다.</p>\n<h2 id=\"5-reactmemo-은-성능-개선의-도구다\" style=\"position:relative;\"><a href=\"#5-reactmemo-%EC%9D%80-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%EC%9D%98-%EB%8F%84%EA%B5%AC%EB%8B%A4\" aria-label=\"5 reactmemo 은 성능 개선의 도구다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. React.memo() 은 성능 개선의 도구다</h2>\n<p>엄밀히 말하면, React에서는 성능 개선을 위한 하나의 도구로 메모이제이션을 사용한다.</p>\n<p>대부분의 상황에서 React는 메모이징 된 컴퍼넌트의 리렌더링을 피할 수 있지만, 렌더링을 막기 위해 메모이제이션에 의존하면 안된다.</p>\n<h2 id=\"6-결론\" style=\"position:relative;\"><a href=\"#6-%EA%B2%B0%EB%A1%A0\" aria-label=\"6 결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 결론</h2>\n<p><code class=\"tui-language-text\">React.memo()</code>는 함수형 컴퍼넌트에서도 메모이제이션의 장점을 얻게 해 주는 훌륭한 도구다. 올바르게 적용 된다면 변경되지 않은 동일한 prop에 대해 리렌더링을 하는 것을 막을 수 있다.</p>\n<p>다만, 콜백 함수를 prop으로 사용하는 컴퍼넌트에서 메모이징을 할 때 주의하라. 그리고 같은 렌더링을 할 때 이전과 동일한 콜백 함수 인스턴스를 넘기는지 확실히 하라.</p>\n<p>그리고 메모이제이션의 성능상 이점을 측정하기 위해 <a href=\"https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab\">profiling</a>을 사용하는 것을 잊지 말아라.</p>\n<p><em><code class=\"tui-language-text\">React.memo()</code> 사용 케이스에 대해 더 궁금한가? 그렇다면 <a href=\"https://dmitripavlutin.com/use-react-memo-wisely\">이 글</a>에 댓글을 남겨라!</em></p>","frontmatter":{"id":"ko_20190731","title":"React.memo() 현명하게 사용하기","description":"유저들은 반응이 빠른 UI를 선호한다. 100ms 미만의 UI 응답 지연은 유저들이 즉시 느낄 수 있고, 100ms에서 300ms가 지연되면 이미 유저들은 상당한 지연으로 느낀다. UI 성능을 증가시키기 위해, React는 고차 컴퍼넌트(Higher Order Component, HOC) `React.memo()`를 제공한다. 렌더링 결과를 메모이징(Memoizing)함으로써, 불필요한 리렌더링을 건너뛴다.","date":"2019.07.31","author":"한정","tags":["React","performance"],"thumbnail":"https://user-images.githubusercontent.com/37766175/62363267-f219ba80-b559-11e9-9943-855d42b2fc11.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20190731","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}