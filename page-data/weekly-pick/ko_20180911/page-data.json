{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20180911","result":{"data":{"post":{"html":"<h1 id=\"이벤트-리스너-캐시를-이용한-react-성능-향상\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%EB%84%88-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-react-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81\" aria-label=\"이벤트 리스너 캐시를 이용한 react 성능 향상 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이벤트 리스너 캐시를 이용한 React 성능 향상</h1>\n<blockquote>\n<p>저자 : Charles Stover / 웹사이트 : charlesstover.com / LinkedIn : <a href=\"https://www.linkedin.com/in/charles-stover\">https://www.linkedin.com/in/charles-stover</a> / Twitter : <a href=\"https://twitter.com/CharlesStover\">https://twitter.com/CharlesStover</a><br>\n역자 : 박정환(FE개발랩)<br>\n원문 : <a href=\"https://medium.com/@Charles_Stover/cache-your-react-event-listeners-to-improve-performance-14f635a62e15\">https://medium.com/@Charles_Stover/cache-your-react-event-listeners-to-improve-performance-14f635a62e15</a></p>\n</blockquote>\n<p>자바스크립트의 객체와 함수가 참조형이라는 개념은 React의 성능에 직접적인 영향을 끼침에도 불구하고 많이 다뤄지지 않고 있다. 예를들어, 내용이 완전히 같은 함수를 두 개 만들더라도 두 함수는 절대 같지 않다. 다음과 같이 작성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">functionOne</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello world!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">functionTwo</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello world!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nfunctionOne <span class=\"token operator\">===</span> functionTwo<span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>하지만, 아래 코드처럼 이미 만들어진 함수를 변수에 할당한 결과는 다를 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">functionThree</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello world!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> functionFour <span class=\"token operator\">=</span> functionThree<span class=\"token punctuation\">;</span>\nfunctionThree <span class=\"token operator\">===</span> functionFour<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>객체에서 또한 동일하게 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> object1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> object2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> object3 <span class=\"token operator\">=</span> object1<span class=\"token punctuation\">;</span>\nobject1 <span class=\"token operator\">===</span> object2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nobject1 <span class=\"token operator\">===</span> object3<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>다른 언어들을 사용해본 경험이 있다면 포인터라는 개념이 친숙할 것이다. 객체를 만들거나 기기의 메모리에 무언가를 할당할 때 마다 어떤 일이 일어나는 것일까? <code class=\"tui-language-text\">object1 ={}</code>에 대해 먼저 말해보면, 조금 전에 우리는 <code class=\"tui-language-text\">object1</code>을 위한 한 덩어리의 바이트를 사용자의 RAM에 생성했다. <code class=\"tui-language-text\">object1</code>을 RAM의 key-value 쌍을 가리키는 주소라고 생각하면 이해하기 쉬울 것이다. 그리고 <code class=\"tui-language-text\">object2 = {}</code>에 대해 얘기해보면 <code class=\"tui-language-text\">object2</code>를 위한 한 덩어리의 <em>또 다른</em> 바이트를 사용자의 RAM에 만들었다. 그렇다면 <code class=\"tui-language-text\">object1</code>의 <em>주소</em> 는 <code class=\"tui-language-text\">object2</code>와 같을까? 아니다. 이것이 두 변수의 동일 비교에서 <code class=\"tui-language-text\">false</code> 가 반환되는 이유이다. 각각의 key-value 쌍 내용은 정확히 같지만, 그 메모리의 주소는 다르다.</p>\n<p><code class=\"tui-language-text\">object3 = object1</code>를 이용해서 할당하게 되면 <code class=\"tui-language-text\">object3</code>에 <code class=\"tui-language-text\">object1</code>의 주소를 할당하게 된다. 다시 말해 <code class=\"tui-language-text\">obejct3</code>는 새로운 객체가 아니다. <code class=\"tui-language-text\">object1</code>과 같은 메모리에 있다. 다음과 같이 작성해서 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> object1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> object3 <span class=\"token operator\">=</span> object1<span class=\"token punctuation\">;</span>\nobject3<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\nobject1<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>이번 예제에서는 메모리에 객체를 생성해서 그 객체를 <code class=\"tui-language-text\">object1</code>에 할당했다. 그리고 <code class=\"tui-language-text\">object3</code>에 그 객체를 할당했다. <code class=\"tui-language-text\">object3</code>를 변경하게 되면, 메모리상의 값을 변경하는 것이기 때문에 메모리 주소를 참조하는 모든 곳에서 영향을 받는다. <code class=\"tui-language-text\">object1</code> 또한 같은 메모리를 가리키므로 값이 변경된 걸 확인할 수 있다. </p>\n<p>이 오류는 초급 개발자들 사이에서 흔히 일어나며, 이 오류만으로도 심층적인 튜토리얼을 만들 수 있을 것이다. 하지만 이 글은 React 성능에 대한 내용만을 다루고 있으며, 더 숙련된 개발자들도 변수의 참조 값에 의한 영향을 고려하지 못해 이 부분에서 오류를 범하기도 한다. </p>\n<p>이것이 React와 무슨 관련이 있을까? React는 성능을 끌어올리기 위해 똑똑한 방법으로 연산을 줄인다. 컴포넌트의 <code class=\"tui-language-text\">props</code>나 <code class=\"tui-language-text\">state</code>가 변경되지 않으면 <code class=\"tui-language-text\">render</code>의 출력 또한 변경되지 않을 것이라고 가정한다. 다시 말해, 모든 것들이 전과 같다면 변경되는 것 또한 없다는 말이다. 변경이 없다면, <code class=\"tui-language-text\">render</code>가 반환하는 출력 또한 같아야 한다. 그러므로 <code class=\"tui-language-text\">render</code>를 수행하는 귀찮은 일은 건너뛴다. 이것이 React를 더 빨라지게 한다. 컴포넌트는 필요할 때만 다시 그려진다.</p>\n<p>React는 자바스크립트와 같은 방법으로 <code class=\"tui-language-text\">props</code>와 <code class=\"tui-language-text\">state</code>가 같은지 판단한다. 단순히 <code class=\"tui-language-text\">==</code>연산자로 확인한다. React는 객체가 같은지 확인하기 위해 깊게 비교하지 않는다. 깊은 비교라는 용어는 메모리 주소만 비교하는 것과는 반대로, 각 객체의 key-value 쌍을 모두 비교하는 것을 말한다. React는 객체의 참조가 같은지 확인하는 얕은 비교라고 불리는 방법을 사용한다. </p>\n<p>만약 컴포넌트의 <code class=\"tui-language-text\">prop = { x: 1 }</code> 을 새로운 객체인 <code class=\"tui-language-text\">{ x: 1 }</code>로 바꾼다면, React는 컴포넌트를 다시 그릴 것이다. 왜냐하면 두 객체의 참조가 가리키는 메모리가 다르기 때문이다. 만약 컴포넌트의 <code class=\"tui-language-text\">prop</code>을 위 코드의 <code class=\"tui-language-text\">object1</code>에서 <code class=\"tui-language-text\">object3</code>로 바꾸면 React는 컴포넌트를 다시 그리지 않는다. 마찬가지로, 두 객체가 같은 참조이기 때문이다.</p>\n<p>자바스크립트의 함수도 같은 방법으로 취급된다. React가 같은 구현에 다른 메모리에 있는 함수를 받는다면, 컴포넌트는 다시 그려질 것이다. 만약 반대로 React가 같은 참조의 함수를 받는다면, 다시 그려지지 않을 것이다. </p>\n<p>아래의 코드는 안타깝게도 코드리뷰에서 많이 볼 수 있는 시나리오다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>PureComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">instructions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>do<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">'Click the button: '</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Do NOT click the button: '</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>instructions<span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">&lt;</span>Button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 컴포넌트는 아주 간결하다. <code class=\"tui-language-text\">Button</code> 컴포넌트가 있고, 그것이 클릭 되었을 때 경고창이 뜬다. 설명서에 나와 있지 않더라도 사용자는 클릭할 것이다. 그리고 <code class=\"tui-language-text\">SomeComponent</code>는 <code class=\"tui-language-text\">do={true}</code>나 <code class=\"tui-language-text\">do={false}</code> <code class=\"tui-language-text\">prop</code>으로 제어된다. </p>\n<p><code class=\"tui-language-text\">SomeComponent</code>가 <code class=\"tui-language-text\">true</code>나 <code class=\"tui-language-text\">false</code>로 토글되면 다시 그려지게 되고, 버튼 컴포넌트도 다시 그려진다! <code class=\"tui-language-text\">onClick</code> 핸들러 함수는 같더라도 매 <code class=\"tui-language-text\">render</code>함수 호출마다 새로 생성된다. 이는 <code class=\"tui-language-text\">render</code>함수 내부에서 핸들러를 생성하기 때문에 매 <code class=\"tui-language-text\">render</code>마다 새로운 메모리에 함수가 생성된다. 새로운 메모리 주소의 참조가 <code class=\"tui-language-text\">&lt;Button /&gt;</code>으로 넘어가고, 아무런 변경이 없지만 <code class=\"tui-language-text\">Button</code>은 다시 그려진다.</p>\n<h1 id=\"해결책\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EA%B2%B0%EC%B1%85\" aria-label=\"해결책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해결책</h1>\n<p>함수가 해당 컴포넌트에 의존하지 않는다면(<code class=\"tui-language-text\">this</code> 컨텍스트를 사용하지 않음), 컴포넌트의 외부에 함수를 정의할 수 있다. 함수가 사용되는 조건이 같다면, 컴포넌트의 모든 인스턴스는 같은 함수 참조를 사용할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">createAlertBox</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>PureComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">instructions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>do<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">'Click the button: '</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Do NOT click the button: '</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>instructions<span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">&lt;</span>Button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>createAlertBox<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이전 예제와는 반대로 <code class=\"tui-language-text\">createAlertBox</code>는 매 <code class=\"tui-language-text\">render</code>마다 같은 메모리에 있는 참조를 반환한다. 그러므로 <code class=\"tui-language-text\">Button</code> 컴포넌트는 절대로 다시 그려지지 않는다. </p>\n<p><code class=\"tui-language-text\">Button</code>컴포넌트는 작은 컴포넌트라서 그리는 시간이 오래 걸리지 않는다. 하지만 이런 인라인 함수가 크고 복잡하고 그리는 데 오래 걸리는 컴포넌트에 있다면, React 애플리케이션을 아주 느리게 만들 수 있다. 이런 함수들은 컴포넌트의 <code class=\"tui-language-text\">render</code> 함수에서 정의하지 않는 것이 좋다. </p>\n<p>반대로 함수가 컴포넌트에 의존한다면, 컴포넌트 밖에 함수를 정의할 수 없다. 이럴 땐 컴포넌트의 메서드로 만들어 이벤트 핸들러로 넘겨주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>PureComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function-variable function\">createAlertBox</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">instructions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>do<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">'Click the button: '</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Do NOT click the button: '</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>instructions<span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">&lt;</span>Button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>createAlertBox<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런 경우, <code class=\"tui-language-text\">SomeComponent</code>의 모든 인스턴스는 각기 다른 경고창을 가질 것이다. <code class=\"tui-language-text\">Button</code> 컴포넌트의 클릭 이벤트 리스너는 <code class=\"tui-language-text\">SomeComponent</code> 에서 고유해야 한다. <code class=\"tui-language-text\">createAlertBox</code> 메서드를 넘기므로, <code class=\"tui-language-text\">SomeComponent</code>가 다시 그려지더라도 <code class=\"tui-language-text\">Button</code> 컴포넌트와는 상관없다. 심지어 <code class=\"tui-language-text\">message</code>가 바뀌더라도 상관이 없다. <code class=\"tui-language-text\">createAlertBox</code>의 메모리 주소가 변하지 않으면, <code class=\"tui-language-text\">Button</code> 컴포넌트도 다시 그려지지 않는다. 이렇게 애플리케이션의 다시 그려지는 속도가 빨라지게 된다. </p>\n<p>하지만 사용하는 함수가 동적으로 변경된다면 어떻게 할까? </p>\n<h1 id=\"해결책-고급\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EA%B2%B0%EC%B1%85-%EA%B3%A0%EA%B8%89\" aria-label=\"해결책 고급 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해결책 (고급)</h1>\n<p>아래 코드는 매우 보편적인 사례이다. 한 개의 컴포넌트에서 각기 다른 다수의 동적 이벤트 리스너가 있는 상황이다. 그중에서도 배열을 매핑하는 상황이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>PureComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">listItem</span> <span class=\"token operator\">=></span>\n          <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>listItem<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>Button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>listItem<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런 경우, 버튼 컴포넌트 숫자에 맞는 이벤트 리스너들 변수들이 있다. 그리고 <code class=\"tui-language-text\">SomeComponent</code>가 만들어질 때는 각 함수가 무엇인지 알 수 없을 수도 있다. 이런 수수께끼를 어떻게 해결할까? </p>\n<p>메모이제이션(memoization), 아니 더 쉬운 말로 캐싱을 사용하자. 각 고유한 값마다 함수를 생성하고 캐싱하자. 다시 그려질 때 필요한 참조 값은 이전에 캐싱한 함수의 참조를 그대로 이용한다. </p>\n<p>아래 코드는 위의 설명에 대한 구현이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>PureComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// SomeComponent의 각 인스턴스는 인스턴스마다 고유한 클릭 핸들러들을 캐싱한다.</span>\n  clickHandlers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 고유 식별자에 따른 클릭 핸들러를 반환한다. 없다면 생성하고 반환한다.</span>\n  <span class=\"token function\">getClickHandler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">key</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// 고유 식별자에 대한 이벤트 핸들러를 만들지 않았다면, 새로 생성한다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clickHandlers<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clickHandlers<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clickHandlers<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">listItem</span> <span class=\"token operator\">=></span>\n          <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>listItem<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>Button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClickHandler</span><span class=\"token punctuation\">(</span>listItem<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>배열에 있는 각 아이템은 <code class=\"tui-language-text\">getClickHandler</code> 메서드를 통해 이벤트 리스너를 받는다. 이 메서드는 처음 실행 시엔 고윳값에 해당하는 함수가 있는지 확인한 후, 함수가 없다면 함수를 새로 생성한 후 해당 고윳값을 키로 삼고 함수를 값으로 저장한다. 그리고 저장한 함수를 반환한다. 이후에 이 메서드를 같은 고윳값으로 실행하면 새로운 함수를 생성하지 않는다. 그 대신 메모리상에 미리 생성해둔 함수의 참조를 반환한다. </p>\n<p>그 결과, <code class=\"tui-language-text\">SomeComponent</code>가 다시 그려질 때 <code class=\"tui-language-text\">Button</code>도 같이 그려지는 일은 일어나지 않는다. 그리고 <code class=\"tui-language-text\">prop.list</code>에 새로운 아이템을 추가하면 동적으로 새로운 버튼에 대한 이벤트 리스너를 생성한다. </p>\n<p>만약 한 개 이상의 변수로 각 이벤트 핸들러가 결정되기 위한 고유 식별자를 만들려면 조금 고민을 해야 할 것이다. 그렇다고 해도, 매핑된 각 JSX 객체에 고유한 키 <code class=\"tui-language-text\">prop</code>을 생성하는 일은 그리 어렵지 않다. </p>\n<p>식별자로 배열의 인덱스를 사용하는 것은 위험할 수 있다. 배열의 인덱스를 식별자로 사용한다면, 리스트의 순서를 변경하거나 아이템을 제거하는 경우 잘못된 결과를 얻을 수 있다. 만약 <code class=\"tui-language-text\">[&#39;soda&#39;, &#39;pizza&#39;]</code> 배열을 <code class=\"tui-language-text\">[&#39;pizza&#39;]</code>로 바꾼다면 캐싱한 이벤트 리스너가 <code class=\"tui-language-text\">listeners[0] = () =&gt; alert(&#39;soda)</code> 이므로, 사용자가 0번째 인덱스의 아이템을 클릭했을 때 <code class=\"tui-language-text\">&#39;soda&#39;</code>라고 경고창이 뜰 것이다. 이것이 React가 배열의 인덱스를 <code class=\"tui-language-text\">key</code> <code class=\"tui-language-text\">prop</code>으로 사용하지 말라고 권고하는 이유다.</p>\n<h1 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h1>\n<p>이 글이 좋다면 박수를 쳐주길 바란다(역: 원 글이 작성된 Medium 서비스의 좋아요 버튼 같은 기능이다). 두 번 쳐주는 것도 좋다. 쉽고, 빠르며 심지어 공짜다! 그리고 관련된 질문이나 조언이 있다면 아래에 댓글로 남겨주길 바란다. </p>\n<p>필자의 다른 칼럼을 읽고 싶다면 <a href=\"https://www.linkedin.com/in/charles-stover\">LinkedIn</a>, <a href=\"https://twitter.com/CharlesStover\">Twitter</a>를 팔로우하거나, <a href=\"https://charlesstover.com/\">필자의 포트폴리오인 CharlesStover.com</a>를 확인해보길 바란다.</p>","frontmatter":{"id":"ko_20180911","title":"이벤트 리스너 캐시를 이용한 React 성능 향상","description":"자바스크립트의 객체와 함수가 참조형이라는 개념은 React의 성능에 직접적인 영향을 끼침에도 불구하고 많이 다뤄지지 않고 있다. 예를들어, 내용이 완전히 같은 함수를 두 개 만들더라도 두 함수는 절대 같지 않다. 다음과 같이 작성해보자. 다른 언어들을 사용해본 경험이 있다면 포인터라는 개념이 친숙할 것이다. 객체를 만들거나 기기의 메모리에 무언가를 할당할 때 마다 어떤 일이 일어나는 것일까?","date":"2018.09.11","author":"박정환","tags":["React","performance"],"thumbnail":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20180911","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}