{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20200429","result":{"data":{"post":{"html":"<h1 id=\"노드와-gatsbyjs에서-크롬으로-자식-프로세스를-디버깅하는-방법\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C%EC%99%80-gatsbyjs%EC%97%90%EC%84%9C-%ED%81%AC%EB%A1%AC%EC%9C%BC%EB%A1%9C-%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"노드와 gatsbyjs에서 크롬으로 자식 프로세스를 디버깅하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드와 Gatsby.js에서 크롬으로 자식 프로세스를 디버깅하는 방법</h1>\n<blockquote>\n<p>원문 : <a href=\"https://indepth.dev/how-to-debug-a-child-process-in-node-and-gatsby-js-with-chrome/\">https://indepth.dev/how-to-debug-a-child-process-in-node-and-gatsby-js-with-chrome/</a></p>\n</blockquote>\n<p><img src=\"https://res.cloudinary.com/indepth-dev/image/fetch/w_1000,f_auto/https://admin.indepth.dev/content/images/2020/03/anti-debugging-blog-1200x628.jpg\"></p>\n<p><em>이 글에서는 Gatsby.js에서 사용하는 <code class=\"tui-language-text\">jest-worker</code> 패키지를 수정하고 크롬 개발자 도구를 사용해 사용 가능한 자식 프로세스(child process)를 디버깅하는 방법을 소개할 것이다.</em></p>\n<p>나는 지난 몇 주 동안 <a href=\"https://www.gatsbyjs.org/docs/overview-of-the-gatsby-build-process/\">Gatsby 빌드</a> 프로세스의 내부 구조를 파악하는 데 시간을 보냈다. 그 과정에서 서버측에서 Redux 스토어를 사용해 빌드 프로세스의 다른 액터들과 통신하는 것과 같은 흥미로운 접근법들을 발견했다. 조만간 이 내용에 대해 깊게 다룬 시리즈를 연재할 예정이다.</p>\n<p>디버깅을 할 때 문제가 되었던 것 중 하나는, 노드의 자식 프로세스에 의존하는 Gatsby 기능이었다. 이 기능은 각 정적 페이지를 위해 HTML 빌드를 병렬로 실행하는 데 사용되었다. 자바 또는 C++와 같은 언어에서 병렬화는 보통 스레드를 사용하여 처리하지만, 자바스크립트는 스레드가 없기 때문에 여러 자식 프로세스를 생성하여 병렬로 노드 작업을 처리한다. 더 자세한 내용은 <a href=\"https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/\">여기</a>에서 확인할 수 있다.</p>\n<p>Node.js는 자식 프로세스를 생성하기 위해 두 개의 주요 모듈을 가진다. <a href=\"https://nodejs.org/api/child_process.html\">child_process</a>와 새 모듈인 <a href=\"https://nodejs.org/api/worker_threads.html\">worker_threads</a>는 부모 프로세스와 자식 프로세스 사이에서 메모리를 공유하여 다른 언어의 스레드들을 에뮬레이트한다.</p>\n<p>내부를 살펴보면, Gatsby는 병렬로 빌드를 실행하기 위해 <code class=\"tui-language-text\">jest-workers</code> 패키지를 사용한다. 이는 <a href=\"https://github.com/gatsbyjs/gatsby/blob/ce53d812491e673dfa4b8e328cb041a4d4a943bc/packages/gatsby/src/utils/worker/pool.js#L1\"><code class=\"tui-language-text\">WorkerPool</code>을 구현</a>하여 쉽게 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> Worker <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">jest-worker</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>default<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> cpuCoreCount <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">gatsby-core-utils</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">create</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">./child</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    numWorkers<span class=\"token operator\">:</span> <span class=\"token function\">cpuCoreCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    forkOptions<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      silent<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  create\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 패키지는 기본적으로 노드의 child<em>process 모듈을 사용하지만, 워커의 인스턴스를 생성할 때 <code class=\"tui-language-text\">enableWorkerThreads: true</code>로 설정하면 `worker</em>threads` 모듈로 <a href=\"https://www.npmjs.com/package/jest-worker#experimental-worker\">변경할 수 있다</a>.</p>\n<blockquote>\n<p>이 글은 프론트엔드와 백엔드 개발자 모두에게 유용할 것이다. Gatsby.js에 특별히 관심이 없다면, 다음 장은 건너뛰고 \"노드에서 자식 프로세스를 디버깅하기 위해 jest-workers를 수정하는 방법\"으로 넘어간다.</p>\n</blockquote>\n<h2 id=\"gatsbyjs에서-자식-프로세스를-디버깅하는-방법-찾기\" style=\"position:relative;\"><a href=\"#gatsbyjs%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%B0%BE%EA%B8%B0\" aria-label=\"gatsbyjs에서 자식 프로세스를 디버깅하는 방법 찾기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gatsby.js에서 자식 프로세스를 디버깅하는 방법 찾기</h2>\n<p>나는 수년간 프론트엔드 프레임워크와 라이브러리의 소스를 탐색하면서, 소스에서 디버깅과 리버스 엔지니어링(reverse-engineering)에 대해 많은 것을 배웠다고 생각한다. 디버깅과 리버스 엔지니어링에 대한 정보는 <a href=\"https://indepth.dev/\">inDepth.dev</a>에 게시된 <a href=\"https://indepth.dev/level-up-your-reverse-engineering-skills/\">\"당신의 리버스 엔지니어링 스킬 올리기\"</a> 글에 공유되어 있다.</p>\n<p>Gatsby 디버깅을 시작하기 위해 Gatsby CLI인 <code class=\"tui-language-text\">gatsby new gatsby-site</code>를 사용해 프로젝트를 생성한다. 노드의 <a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\">디버깅 인스펙터(debug inspector)를 활성화</a>하여 애플리케이션을 실행하기 위해 다음 명령어를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ node --inspect-brk node_modules/gatsby/dist/bin/gatsby.js build</code></pre></div>\n<p>그런 다음 <code class=\"tui-language-text\">chrome://inspect</code>에서 프로세스를 찾아서 <code class=\"tui-language-text\">inspect</code>를 클릭한다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-70.png\"></p>\n<p>첫 번째 줄에서 디버거가 일시 정지된 상태에서 크롬 개발자 도구를 열고 컨트롤러를 사용해 계속 실행한다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-71.png\"></p>\n<p>여기서 생성된 자식 프로세스를 디버깅할 수 없었다. 처음에 언급했듯이, Gatsby는 이 기술을 사용해 렌더링 부분을 빌드 단계에서 실행한다.</p>\n<p>탐험의 일환으로, 다음과 같이 <code class=\"tui-language-text\">Header</code> 컴포넌트에 <code class=\"tui-language-text\">debugger</code> 구문을 추가했다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*fUhYZhfO-19V_qUQYOryIg.png\"></p>\n<p>디버깅 모드에서 프로세스를 실행하고, 첫 번째 줄에서 디버거를 일시 정지하여 크롬 개발자 도구를 연 다음 \"Resume\" (F8) 버튼을 눌렀다. 놀랍게도 컴포넌트 안에 추가한 중단점(breakpoint)에서 멈추지 않고 빌드가 끝났다. 중단점을 통과한게 처음은 아니라서 그냥 이 코드가 실행되지 않는다고 추측했다.</p>\n<p><strong><code class=\"tui-language-text\">Header</code> 컴포넌트 내 코드는 별도의 자식 프로세스에서 실행되고 크롬 디버거는 이 자식 프로세스에 연결되지 않는다는 것을 이해하기까지 시간이 꽤 걸렸다.</strong></p>\n<p>디버깅이 되지 않는 것은 좋지 않았다. 스크립트를 디버깅할 수 없다면 세부 내용도 이해할 수 없기 때문이다. 검색을 했더니 크롬이 자식 프로세스에 연결되지 않는다는 몇 가지 이슈를 발견했다.</p>\n<p>첫 번째 해결 방법은 생성된 자식 프로세스에서 Gatsby가 실행한 <a href=\"https://github.com/gatsbyjs/gatsby/blob/49fd769f695ccfa6e990e3eaae7c886f073db19b/packages/gatsby/src/utils/worker/render-html.js#L16\"><code class=\"tui-language-text\">renderHTML</code></a> 함수를 사용해 <code class=\"tui-language-text\">render-html.js</code> 파일 전체를 간단하게 복사하는 것이었다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-72.png\"></p>\n<p>그리고 필요한 파라미터를 전달하는 노드 디버거를 사용해 이 함수를 수동으로 트리거 한다. 그러나 이 방법은 굉장히 불편하고 생산적이지 않았다. 에러를 피하기 위해 이 프로세스에 전달할 환경 변수를 매번 알아내야 했기 때문이다.</p>\n<p>이 시점에서 내가 쓴 <a href=\"https://indepth.dev/this-will-make-you-more-efficient-at-debugging-webpack-unspecified-build-errors/\">Webpack 빌드 디버깅</a> 글을 보면, node_modules에서 노드 디버거와 함께 사용할 자바스크립트 파일을 찾는 방법을 설명했었다. 그러면서 노드 디버거로 필요한 파일 위치를 알아내는 방법으로 <a href=\"https://github.com/GoogleChromeLabs/ndb\">ndb</a>를 노드 디버거로 사용하는 것이 합리적이라는 답변을 받았다. 이렇게 긴 명령어를 쓰는 대신</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ node --inspect-brk node_modules/webpack/bin/webpack.js</code></pre></div>\n<p>이렇게 간단하게 쓰면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ ndb webpack</code></pre></div>\n<p>이 도구를 탐구하다가 몇 가지 흥미로운 기능을 발견했다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-73.png\"></p>\n<p>이것은 정확하게 필요로 했던 기능이었다. Gatsby로 디버거를 실행하기 위해 다음과 같이 테스트 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ ndb gatsby build</code></pre></div>\n<p><code class=\"tui-language-text\">ndb</code>는 크롬의 다크모드처럼 보이는 디버깅 환경을 시작했다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-74.png\"></p>\n<p>이번에는 컴포넌트 내 중단점이 실행을 멈추게 했다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-75.png\"></p>\n<p>그랬더니 생성된 모든 프로세스를 아주 편리하게 보여주었다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-76.png\"></p>\n<p>그러나 <code class=\"tui-language-text\">ndb</code>는 버그가 조금 있었고, 다음과 같은 문제가 발생했었다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-77.png\"></p>\n<p>약간의 문제는 있었지만, <code class=\"tui-language-text\">ndb</code>는 여전히 유용한 도구였다. 하지만 더 나은 도구가 필요했다.</p>\n<h2 id=\"노드에서-자식-프로세스를-디버깅하기-위해-jest-workers-수정하는-방법\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-jest-workers-%EC%88%98%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"노드에서 자식 프로세스를 디버깅하기 위해 jest workers 수정하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드에서 자식 프로세스를 디버깅하기 위해 jest-workers 수정하는 방법</h2>\n<p>이 문제를 <a href=\"https://twitter.com/victorsavkin\">Victor</a>와 논의했다. 그는 자식 프로세스를 포크(fork)한 코드로 수정하고, 자식 프로세스에 <code class=\"tui-language-text\">inspect-brk</code> 옵션을 넘기도록 제안했다.</p>\n<p><code class=\"tui-language-text\">jest-workers</code>를 사용한 아주 기본적인 애플리케이션에서 가능성을 먼저 찾기로 했다. 나는 보통 기술을 분리하고 각각 분리된 단위로 사용하려고 노력한다. 이렇게 하면 나중에 각 기술들이 어떻게 결합되고 시스템의 어떤 부분이 문제를 일으키지는지 이해하는 데 도움이 되기 때문이다.</p>\n<p><code class=\"tui-language-text\">jest-worker</code>의 <a href=\"https://www.npmjs.com/package/jest-worker\">문서</a>를 찾아서 문서에서 설명하는 첫 번째 예제를 사용해보았다. 예제에서 ECMAScript 모듈을 CommonJS로 변경해야 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> Worker <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"jest-worker\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>default<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./worker\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> numWorkers<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> worker<span class=\"token punctuation\">.</span><span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"Hello, Alice\"</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>parent.js</em></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">hello</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">param</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">debugger</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"Hello, \"</span> <span class=\"token operator\">+</span> param<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>worker.js</em></p>\n<p><code class=\"tui-language-text\">worker.js</code> 파일에서 내보낸 <code class=\"tui-language-text\">hello</code> 함수 안에 debugger 구문을 추가하고 디버그 모드로 스크립트를 실행시켰다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ node --inspect-brk index.js</code></pre></div>\n<p><strong>예상했던 것처럼 <code class=\"tui-language-text\">hello</code> 함수가 자식 프로세스에서 실행되기 때문에 디버거는 중단점에서 멈추지 않았다.</strong></p>\n<p>정확하게 코드를 수정할 방법을 찾아야 했다. 내 생각에는 디버깅 모드에서 현재 프로세스를 실행하면 노드에 <code class=\"tui-language-text\">--inspect-brk</code> 옵션을 넘기는 것이었다. 그래서 모든 자식 프로세스에서 동일한 옵션을 넘겨야된다고 가정했다.</p>\n<p><code class=\"tui-language-text\">--inspect-brk</code>을 실행하면 인스펙터 에이전트가 기본 호스트인 <code class=\"tui-language-text\">127.0.0.1</code>에 붙고 기본 포트 <code class=\"tui-language-text\">9229</code>로 수신할 수 있다. 여러 개의 디버거는 같은 포트 번호에서 실행될 수 없으므로, 각 자식 프로세스에 다른 포트 번호를 표시할 수 있어야 했다. 그것이 바로 내가 한 일이었다.</p>\n<p><code class=\"tui-language-text\">node_modules\\jest-worker\\build\\workers\\ChildProcessWorker.js</code>를 찾아서 다음 코드를 추가했다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-78.png\"></p>\n<p>직접 해보고 싶다면 이 코드를 복사하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> execArgv <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>execArgv<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">value</span> <span class=\"token operator\">=></span> <span class=\"token operator\">!</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"inspect-brk\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> randromNumber <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">9</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nexecArgv<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"--inspect-brk=:700\"</span> <span class=\"token operator\">+</span> randromNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 이미지에서 보여지는 것처럼 <code class=\"tui-language-text\">fork</code> 메서드에서 업데이트된 <code class=\"tui-language-text\">execArgv</code>를 넘기는 것을 잊으면 안된다.</p>\n<p>또한 기존 구현 코드 내 jest가 모든 <code class=\"tui-language-text\">inspect</code>와 <code class=\"tui-language-text\">debug</code> 플래그를 제거하는 것도 여기에서 확인할 수 있다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-79.png\"></p>\n<p>수정한 작은 부분은 <code class=\"tui-language-text\">inspect-brk</code> 옵션과 <a href=\"https://nodejs.org/docs/latest/api/process.html#process_process_argv\">argV</a>를 통해서 자식 프로세스를 임의로 생성된 마지막 번호의 포트를 간단하게 넘기도록 추가한 것이다. <code class=\"tui-language-text\">inspect-brk</code>를 넘겼기 때문에 노드가 첫 번째 줄에서 자식 프로세스를 일시 중지시킬 것이라고 가정했다. 자식 프로세스는 디버거를 연결할 때까지 기다릴 것이고 어떤 실행 로직도 놓지지 않을 것이다.</p>\n<p>부모 프로세스를 위해서 기본 포트 번호 대신 <code class=\"tui-language-text\">7000</code> 포트 번호를 사용하기로 했다. 코드를 수정한 후 다음 명령어를 실행했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"tui-language-sh\"><code class=\"tui-language-sh\">$ node - inspect-brk=:7000 index.js</code></pre></div>\n<h2 id=\"크롬-설정\" style=\"position:relative;\"><a href=\"#%ED%81%AC%EB%A1%AC-%EC%84%A4%EC%A0%95\" aria-label=\"크롬 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>크롬 설정</h2>\n<p>이 작업이 끝나면, 옵션으로 넘긴 포트 번호 <code class=\"tui-language-text\">7001~7009</code>로 연결하도록 크롬에서 설정을 해야한다. 방법은 다음과 같다. <code class=\"tui-language-text\">chrome://inspect</code>에서 <code class=\"tui-language-text\">Configure</code> 버튼을 클릭한다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-80.png\"></p>\n<p>그리고 포트 번호를 추가한다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-81.png\"></p>\n<p>새로운 포트를 추가하려면 추가할 때마다 다이얼로그를 다시 열어야 한다. 대안책으로, 단순하게 수정한 코드에서 포트 번호를 기록할 수 있다. 그런 다음 크롬 디버거 설정에서 하나의 포트만 추가하면 된다.</p>\n<p>포트 번호 <code class=\"tui-language-text\">7000</code>을 추가하면 부모 프로세스를 볼 수 있다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-82.png\"></p>\n<p>디버거를 연결하고 실행을 계속하면, 예상대로 새로운 자식 프로세스가 목록에 나타난다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-83.png\"></p>\n<p>크롬 개발자 도구에서 가져온 <code class=\"tui-language-text\">inspect</code>를 클릭하고 child_process 모듈 안에서 코드를 정지시킨다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-84.png\"></p>\n<p>실행을 재개하면, <code class=\"tui-language-text\">hello</code> 함수 안에서 중단된다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-85.png\"></p>\n<p>예상하고 있었던 일이었고, 내 머릿속에 도파민이 흐르는 것을 느꼈다. 나는 항상 재미있는 것을 찾을 때 행복하다고 느낀다.</p>\n<h2 id=\"gatsbyjs-내에서-jest-worker-수정하기\" style=\"position:relative;\"><a href=\"#gatsbyjs-%EB%82%B4%EC%97%90%EC%84%9C-jest-worker-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"gatsbyjs 내에서 jest worker 수정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gatsby.js 내에서 jest-worker 수정하기</h2>\n<p>스탠드얼론 버전의 애플리케이션을 성공적으로 수정한 다음, Gatsby 애플리케이션에서 <code class=\"tui-language-text\">jest-worker</code>를 수정하기 위해 같은 기술을 쉽게 적용할 수 있었다.</p>\n<p>Gatsby에서 자식 프로세스를 디버깅하려면 Gatsby 프로젝트 안에서 <code class=\"tui-language-text\">node_modules\\jest-worker\\build\\workers\\ChildProcessWorker.js</code>를 찾아 위에서 본 것과 같은 코드를 추가한다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*oVkUNKbaopJjGuM9WCfckw.png\"></p>\n<p>기본적으로 <code class=\"tui-language-text\">jest-workers</code>는 기기에서 감지한 CPU 코어 수 만큼 자식 프로세스를 생성한다. 이것은 <code class=\"tui-language-text\">os</code> 모듈을 사용해 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> os <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"os\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">cpus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>내 경우에 CPU 코어 수는 8이었다.</p>\n<p>그래서 프로세스로 <code class=\"tui-language-text\">chrome://inspect</code>를 열었을 때 8개의 자식 프로세스가 생성되어 있을 것이라고 예상했었지만, 4개만 생성되어 있었다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-87.png\"></p>\n<p>포트 번호가 <code class=\"tui-language-text\">[1–10]</code>까지 생성되어 있었기 때문에 충돌이 나면서 한 인스턴스가 다른 인스턴스를 대체했기 때문이라고 생각했다. 모든 인스턴스를 확인하고 싶다면, 충돌 가능성을 줄이기 위해 포트 번호 범위를 늘려야 한다. 하지만 크롬에 모든 포트 번호를 추가하는게 불가능한 경우가 있을 수 있다. 쉬운 해결 방법은 간단하게 포트 번호를 기록하고 노드 인스펙터가 사용하는 포트 번호만 추가하는 것이다.</p>\n<p>그러나 Gatsby에서 자식 프로세스를 디버깅할 때, 여러 IP 주소에 연결하도록 크롬을 설정하는 번거로움을 피하기 위해 1개의 자식 프로세스만 생성하는 것을 추천한다. 그렇게 하기 위해서 <code class=\"tui-language-text\">node_modules\\gatsby\\dist\\utils\\worker\\pool.js</code>에 아래 코드를 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">create</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">./child</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// numWorkers: cpuCoreCount(true),</span>\n  numWorkers<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">&lt;</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span> specify the number <span class=\"token keyword\">of</span> child workers equal to <span class=\"token number\">1</span>\n  forkOptions<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    silent<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또 다른 흥미로운 세부 사항은 <strong>컴포넌트가 포함된 페이지를 빌드하기 위해 생성된</strong> 프로세스를 클릭해야 한다는 것이다. 그렇지 않으면 자식 프로세스가 생성되더라도 중단점에서 멈추지 않는다. 중단점에서 멈추려면 맞는 것을 찾기 전에 프로세스 중에 아무거나 클릭해야 할 것이다. 컴포넌트로 페이지를 렌더링 자식 프로세스를 찾기 전에 처음 두 개를 클릭했다. 마침내 중단점에서 멈췄다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*XHRk9MErLZNy0D1i3_Y1ig.png\"></p>\n<p>작은 힌트로, <code class=\"tui-language-text\">node_modules\\gatsby\\dist\\utils\\worker\\render-html.js</code> 파일에서 <code class=\"tui-language-text\">renderHTML</code> 함수 내 <code class=\"tui-language-text\">paths</code> 변수를 확인하면 렌더링 된 페이지들을 확인할 수 있다.</p>\n<p><img src=\"https://admin.indepth.dev/content/images/2020/03/image-88.png\"></p>\n<p>모든 파일에서 일시 정지하려면 중단점을 추가한다. 특정 페이지에서만 정지하고 싶다면 다음과 같은 조건문을 추가하면 된다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Qbl5T9nWaRzb0N9BDDb1lA.png\"></p>\n<p>또는 <a href=\"https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints#conditional-loc\">조건부 중단점</a>을 추가한다.</p>\n<p>이 코드를 포크해서 즐겁게 디버깅을 해보길 바란다! <a href=\"https://community.indepth.dev/t/how-to-debug-a-child-process-in-node-and-gatsby-js-with-chrome/270\">indepth.community</a>에 질문이나 각 주제에 대한 당신의 생각을 공유해보라.</p>","frontmatter":{"id":"ko_20200429","title":"노드와 Gatsby.js에서 크롬으로 자식 프로세스를 디버깅하는 방법","description":"이 글에서는 Gatsby.js에서 사용하는 jest-worker 패키지를 수정하고 크롬 개발자 도구를 사용해 사용 가능한 자식 프로세스(child process)를 디버깅하는 방법을 소개할 것이다.","date":"2020.04.29","author":"류선임","tags":["nodejs","devtool","opensource"],"thumbnail":"https://res.cloudinary.com/indepth-dev/image/fetch/w_1000,f_auto/https://admin.indepth.dev/content/images/2020/03/anti-debugging-blog-1200x628.jpg"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20200429","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}