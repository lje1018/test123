{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20151214","result":{"data":{"post":{"html":"<h1 id=\"github의-atom에디터-마커기능-성능-향상-사례\" style=\"position:relative;\"><a href=\"#github%EC%9D%98-atom%EC%97%90%EB%94%94%ED%84%B0-%EB%A7%88%EC%BB%A4%EA%B8%B0%EB%8A%A5-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81-%EC%82%AC%EB%A1%80\" aria-label=\"github의 atom에디터 마커기능 성능 향상 사례 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Github의 Atom에디터 '마커'기능 성능 향상 사례</h1>\n<blockquote>\n<p>원문<br>\nNathan Sobo, <a href=\"https://blog.atom.io/2015/06/16/optimizing-an-important-atom-primitive.html\">https://blog.atom.io/2015/06/16/optimizing-an-important-atom-primitive.html</a></p>\n</blockquote>\n<p><br><br></p>\n<p>지난 몇 달 동안 에디터의 성능 최적화 작업을 진행했다. 진행 도중 '마커' 기능 개선하는 약간은 어려운 이슈를 해결하는 작업이 계획되었다. '마커'는 논리적 영역을 지정하여 수정과 상관 없이 계속 추적하는 기능이다. 예를 들어 아래 gif 에서 녹색 영역이 '마커' 인데 텍스트가 변경되어도 계속 녹색으로 지정되어 있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770582/991c3fb4-a245-11e5-99f1-2086b9128748.gif\" alt=\"Marker example\"></p>\n<p>'마커'는 에디터에서 가장 많이 쓰는 기본적인 기능이다. 하이라이팅 된 검색 결과를 변경할때에도 쓰고, Snippet기능에선 텍스트가 변경될때마다 tap stop 을 추적하는데 쓰이고, 철자 검사 기능에서 문제가 된 단어를 마킹하고 다시 검사할때도 쓰이고, 에디터 자체에서도 selection과 cursor를 구현하는데 쓴다. '마커'는 지금 나열한 기능들 외에도 상당히 많이 쓰는 기능이다.</p>\n<p>하지만 '마커'는 지난 출시 버전들에서 '찾아 바꾸기'와 같은 한번에 많은 '마커'를 만들어내야 하는 기능에 최악의 성능 이슈를 발생시키는 원인이었다. 때문에 지난 몇 달간 개선 작업을 진행했고 진행 내역을 공유하고자 글을 썼다.</p>\n<h2 id=\"마커가-느린-이유\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%BB%A4%EA%B0%80-%EB%8A%90%EB%A6%B0-%EC%9D%B4%EC%9C%A0\" aria-label=\"마커가 느린 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>'마커'가 느린 이유</h2>\n<p>'마커'의 성능 최적화 작업을 이해하기 위해 먼저 기존 구현의 문제점을 짚고 넘어가려고 한다. 버퍼가 변경될때마다 단순히 모든 '마커'를 순회하며 위치를 조정했었다. 여기에 설상가상으로 range 쿼리의 데이터 구조 내의 모든 '마커'에 대해 위치를 조정했고 이는 O(n*log(n))의 복잡도가 되었다. (n이 '마커'의 수이다)</p>\n<p>'마커'가 그렇게 많지 않을때는 이 방법의 성능은 어느정도 괜찮았다. 하지만 '마커'가 굉장히 많이 나타날 수 있는 특정 상황에서는 심각한 문제가 되었다. 예를 들어 대용량의 문서에서 사용자가 '찾아 바꾸기' 로 'e'를 타이핑했을 때 하이라이팅을 위해 '마커'를 만든다. 매 키스트로크때마다 '마커' 업데이트에 기다리기 어려운 고통스러운 시간이 흘렀다. 다음 스크린샷은 Atom 0.198.0 버전에서 jQuery 소스 파일의 'e'에 개행을 할 때의 CPU 프로파일이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770591/d53635cc-a245-11e5-9cb8-e554edb51381.png\" alt=\"CPU profile before refactoring marker feature\"></p>\n<h2 id=\"성능-개선\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0\" aria-label=\"성능 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능 개선</h2>\n<p>성능 문제를 해결하기 위해 '마커'를 조금 더 덜 집중적으로 사용하기로 했다. 예를 들어 검색 결과 '마커'를 실제로 화면에 보이는 영역에 대해서만 만들고 스크롤되었을 때 업데이트 하도록 하는것이다. 하지만 '마커'는 매우 중요한 기능이기 때문에 어떤 악조건에서도 쉽게 사용할 수 있는 추상적 기능을 제공하는 것이 포인트이다.</p>\n<p>'마커'의 가장 큰 문제점은 위치를 단순한 절대값으로 만들어 두고 각 '마커'들이 업데이트 될 때 강제적으로 계산한다는 점이었다. 하지만 모든 '마커'의 위치를 매번 전부 계산할 필요는 없다. 대부분의 경우 화면에 실제로 보이는 '마커'의 위치만 알면 되고, 그렇게 되면 화면을 다시 그릴때까지의 시간동안 계산하게 할 수 있게 되었다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770592/e4371488-a245-11e5-8c26-5b5b4c8bafbb.png\" alt=\"Update markers that only visible on screen\"></p>\n<p>우린 버퍼가 변경될때마다 모든 '마커'를 계산하는 방법보다 이 계산을 선택적으로 할 수 있도록 만들어야 했다. 실제적으로 필요한 계산 외 나머지를 필요해지기 전까지 지연시키는 것이다. 이를 위해 우리는 '마커'의 위치를 다른 방법으로 표현하도록 수정해야 했다.</p>\n<h3 id=\"상대적-위치-표현\" style=\"position:relative;\"><a href=\"#%EC%83%81%EB%8C%80%EC%A0%81-%EC%9C%84%EC%B9%98-%ED%91%9C%ED%98%84\" aria-label=\"상대적 위치 표현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상대적 위치 표현</h3>\n<p>문제를 해결하기 위한 키 포인트를 그림으로 나타내 보았다. 문장이 수정되는 초기 시점에 각 '마커'의 절대적인 위치는 변경된다. 하지만 각 '마커'의 간격은 아직 남아있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770609/583bb2b2-a246-11e5-9834-4fb5d23bc20a.png\" alt=\"d\"></p>\n<p>'마커' 사이의 텍스트가 수정되기 전 까지 이 간격은 계속 유지된다. 이 사실을 버퍼가 변경되기 전에 대부분의 계산을 지연하는 데 활용할 수 있다는 사실을 깨달았다.</p>\n<p>이전에 언급했던것 처럼 '마커'의 위치는 아래 그림과 같이 절대적으로 표현되고 있었다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770617/72feb9d2-a246-11e5-8aa1-8ad0f4bf393e.png\" alt=\"e\"></p>\n<p>대신 '마커' 서로간의 거리를 나타내는 방식으로 변경했다. 이를 위해서 버퍼를 여러 구역을 분리했다. 분리된 구역들은 몇 개의 문자가 사용되고 있는지에 대한 '넓이'를 저장하고 있다. 그리고 '마커'의 경우 별도로 ID를 지정하도록 했다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770621/868e9d6e-a246-11e5-9e60-a25a575103b3.png\" alt=\"f\"></p>\n<p>'마커'는 여러 방법으로 겹칠 수 있기 때문에 구역은 하나 이상의 '마커' ID를 가질 수 있게 되었고 같은 '마커' ID가 연속된 여러 구역에 나타날 수 있게 되었다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770623/93c98cf0-a246-11e5-81c3-9d79812be6e3.gif\" alt=\"g\"></p>\n<h3 id=\"쓰기\" style=\"position:relative;\"><a href=\"#%EC%93%B0%EA%B8%B0\" aria-label=\"쓰기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쓰기</h3>\n<p>이 변경으로 인해 텍스트의 변경을 표현하기 위해서 변경이 이뤄진 단일 구역과 그 다음 구역에만 얼만큼 변경되었는지를 적용하면 되었다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770626/a7cd5e3e-a246-11e5-8da4-418b2ba7995b.gif\" alt=\"h\"></p>\n<p>이 구현의 문제점은 '마커'의 범위를 찾기 위해선 시작점부터 구역을 하나하나 찾아야 한다는 점이었다. 또한 버퍼가 변경될 때 어떤 구역의 extent가 변경되어야 하는지 찾는 것도 문제였다. 이 문제를 해결하지 않는 한 '마커'업데이트 동작의 복잡도는 O(n)을 벗어날 수 없기 때문이다.</p>\n<h3 id=\"읽기\" style=\"position:relative;\"><a href=\"#%EC%9D%BD%EA%B8%B0\" aria-label=\"읽기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>읽기</h3>\n<p>이 단계에서 문제가 되었던 선형 검색을 제거하기 위해 '마커'를 저장하는 구조를 단순 리스트에서 B트리 형태로 바꿨다. B트리를 구현하는데는 많은 방법이 있지만, 약간 수정된 버전의 B+트리를 사용했다.</p>\n<p>트리 검색의 기본적인 개념은 노드들이 하위 노드들에 대한 필수 정보만 유지하고 있고 검색해 내려가면서 검색 범위를 큰 폭으로 줄일 수 있다는 점이다. 우리가 사용한 트리는 각 노드들의 하위 노드를 포함해 총 몇 글자의 너비를 가지고 있는지와 하위 노드들의 '마커' ID를 중첩한 정보를 가지고 있다. 이 화려한 중복 트리는 아래와 같이 생겼다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770735/80c6e38e-a249-11e5-8019-5adf8e4cddb6.png\" alt=\"i\"></p>\n<p>이 구조는 다양한 작업을 좀 더 효율적으로 처리할 수 있도록 해 준다 (O(n)보다 O(log(n))에 가깝다). 텍스트가 삽입될 때 모든 구역을 전부 훑지 않아도 된다. 대신 각 구역의 요약 정보를 토대로 실제 변경이 필요한 구역으로 직접 찾아갈 수 있게 되었다.</p>\n<p>예를 들어 글자를 22번 인덱스에 삽입한다고 할 때 아래처럼 extent를 참고하여 원하는 구역으로 바로 갈 수 있는 것이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770740/9b53d25c-a249-11e5-8655-b0918f4adfba.gif\" alt=\"j\"></p>\n<p>이 정도는 규모가 작은 형태여서 크게 차이가 없는 것처럼 보인다. 하지만 이 트리가 커질수록 이 접근법은 많은 노드를 건너뛸수 있게 해 준다. 아래는 얼마나 많은 노드를 건너뛸 수 있는지 볼 수 있는 예이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770743/a8a2e1d2-a249-11e5-8575-2c4cb0ffca72.gif\" alt=\"k\"></p>\n<p>만약 특정 '마커'의 범위를 찾아야 할 경우 역시 '마커'를 가진 노드를 찾아 내려가면 된다.</p>\n<p>이 방법은 range 쿼리에도 적용할 수 있다. 주어진 범위 내의 '마커' 세트를 반환하는 것이다. 결과적으로 그려야 할 '마커'의 수를 큰 수에서 작은 수로 줄여내는 것이다. 편집기가 임의의 마커들을 강제로 그리도록 한 후 실제로 보이는 '마커'에 대해서만 효율적인 계산을 수행하고 나머지는 신경쓰지 않는 것이다.</p>\n<p>이 방법은 jQuery의 소스에서 모든 'e'를 개행하는 과정에서 아래의 CPU프로파일 결과를 보여주었다. 전체 수행 시간이 800ms 에서 50ms대로 줄었다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269564/11770752/c44a8700-a249-11e5-9f6e-62d995270e36.png\" alt=\"l\"></p>\n<p>언급한 내용들은 전체 최적화 과정에서 일부 내용일 뿐이다. 하지만 전체 구현의 기본적인 아이디어라고 볼 수 있다. <a href=\"https://github.com/atom/text-buffer/blob/0855c8c5e36faf252b8be467a8a67c2dce28bafa/src/marker-index.coffee\">marker-index Class</a>가 B+Tree를 구현하고 있고, <a href=\"https://github.com/atom/text-buffer/blob/0855c8c5e36faf252b8be467a8a67c2dce28bafa/src/marker-store.coffee\">marker-store-wrapper Class</a>에서 상세 구현을 볼 수 있다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>에디터 초기의 최적화는 주로 DOM인터렉션에 관한 내용이 많았다. 이런 렌더링 성능 향상에 대한 내용도 앞으로 많이 올릴 생각이다. 이 글을 통해 조금 더 깊은 시스템에 대한 나용을 다룰 수 있었다. Electron과 Node 의 통합은 Atom에디터의 성능 이슈를 가진 일부 컴포넌트에 대해 C++ 코드를 사용할 수 있는 기능을 제공하긴 하지만 이번 '마커'에 대한 내용은 단순히 알고리즘 개발만으로 가능한 성능 개선의 좋은 예다. Atom 데이터는 몇달 전보다 많이 빨라졌고 본문의 내용과 같은 성능 개선 작업을 계속 진행하고 있다.</p>","frontmatter":{"id":"ko_20151214","title":"Github의 Atom에디터 '마커'기능 성능 향상 사례","description":"지난 몇 달 동안 에디터의 성능 최적화 작업을 진행했다. 진행 도중 '마커' 기능 개선하는 약간은 어려운 이슈를 해결하는 작업이 계획되었다. '마커'는 논리적 영역을 지정하여 수정과 상관 없이 계속 추적하는 기능이다. 예를 들어 아래 gif 에서 녹색 영역이 '마커' 인데 텍스트가 변경되어도 계속 녹색으로 지정되어 있다.","date":"2015.12.14","author":"김민형","tags":["performance"],"thumbnail":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20151214","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}