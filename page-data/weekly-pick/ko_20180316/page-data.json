{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20180316","result":{"data":{"post":{"html":"<h1 id=\"redux-saga-channel\" style=\"position:relative;\"><a href=\"#redux-saga-channel\" aria-label=\"redux saga channel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux-Saga: Channel</h1>\n<p>이번 글에서는 Redux-Saga의 Channel(이하 채널)에 대해 정리해보고자 한다. 채널은 Redux-Saga의 초기 버전에서부터 고려했던 API는 아니다. 그런데 <a href=\"https://stackoverflow.com/questions/34859932/can-i-use-redux-sagas-es6-generators-as-onmessage-listener-for-websockets-or-ev\">Stackoverflow에서 외부 이벤트를 Saga와 어떻게 연결하냐</a>는 질문에서 채널의 필요성이 표면적으로 나타나기 시작했다. 핵심은 Push 기반과 Pull 기반 동작이다.</p>\n<p>WebSocket과 같은 외부 이벤트들은 일반적으로 리스너를 등록하는 <code class=\"tui-language-text\">on(type, listener)</code> 형태의 Push 기반 로직을 작성한다. 하지만 Redux-Saga는 <code class=\"tui-language-text\">take(pattern)</code>를 통해 액션을 끌어오는 Pull 기반 로직을 작성한다. 이런 차이 때문에 초기에 개발자들은 외부 이벤트를 Saga로 연결해 로직을 작성하는데 많은 어려움을 겪었다.</p>\n<p>채널은 이런 다른 두 방식을 잘 연결해준다.</p>\n<h2 id=\"push와-pull\" style=\"position:relative;\"><a href=\"#push%EC%99%80-pull\" aria-label=\"push와 pull permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Push와 Pull</h2>\n<p>Push와 Pull은 일상생활에 아주 밀접하고 자연스럽게 녹아있다. 휴대폰을 생각해보자. 가만히 있어도 휴대폰 알림창에는 날씨, 뉴스, 메일, 문자 알림 등이 쉴 새 없이 쏟아진다. 휴대폰은 우리에게 정보를 밀어 넣는다. 바로 Push 기반 동작이다. 웹 서핑은 이와 반대다. 웹 브라우저를 실행하고, 갖고자 하는 정보를 서버에게 요청한다. 서버는 우리가 요청한 정보를 돌려준다. 우리가 직접 정보를 서버로부터 끌어온다. Pull 기반 동작이다. 차이점은 정보의 흐름을 누가 통제하느냐에 있다.</p>\n<p>Saga에 WebSocket과 같은 외부 이벤트를 연결하기 위해서는 이들의 Push 동작을 Pull 동작으로 변경할 수 있어야 한다. 먼저 간단히 아래와 같은 코드들을 생각해볼 수 있을 것 같다.</p>\n<h3 id=\"push-처리\" style=\"position:relative;\"><a href=\"#push-%EC%B2%98%EB%A6%AC\" aria-label=\"push 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Push 처리</h3>\n<p>다음은 일반적으로 흔히 사용하는 리스너 형태의 이벤트 처리 코드다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">pushHandle</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> pushHandle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"push---pull-처리\" style=\"position:relative;\"><a href=\"#push---pull-%EC%B2%98%EB%A6%AC\" aria-label=\"push   pull 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Push -> Pull 처리</h3>\n<p>이제 이 이벤트 처리 코드를 Pull 동작과 같은 형태로 바꾼다. 요점은 메시지를 저장했다가 필요할 때 가져오는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> receivedMessage<span class=\"token punctuation\">;</span>\n\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">message</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  receivedMessage <span class=\"token operator\">=</span> message<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">pullHandle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// receivedMessage를 가지고 처리</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ...</span>\n<span class=\"token comment\">// 이제 언제 어디선가 필요할 때 pullHandle을 호출한다.</span></code></pre></div>\n<h3 id=\"단순한-pull-처리에는-문제가-있다\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%88%9C%ED%95%9C-pull-%EC%B2%98%EB%A6%AC%EC%97%90%EB%8A%94-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EC%9E%88%EB%8B%A4\" aria-label=\"단순한 pull 처리에는 문제가 있다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단순한 Pull 처리에는 문제가 있다.</h3>\n<p>일단 저장하면, 나중에 필요할 때 가져와(Pull) 사용할 수 있다. 하지만 문제가 있다. 메시지가 언제 도착할지 모른다. <strong>Push에 해당하는 <code class=\"tui-language-text\">pushHandle</code>은 항상 메시지가 존재한다는 보장을 받지만, <code class=\"tui-language-text\">pullHandle</code>에서는 메시지가 있을 수도 있고 없을 수도 있다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">pullHandle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>receivedMessage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ... 메시지가 아직 없다. 실패.</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// receivedMessage를 가지고 처리</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>항상 이렇게 실패처리가 포함돼야 하는 것은 매우 비효율적이고 유지보수가 어렵다. 더 나은 방법을 찾아야 한다.</p>\n<h3 id=\"deferred를-활용한-pull-message\" style=\"position:relative;\"><a href=\"#deferred%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-pull-message\" aria-label=\"deferred를 활용한 pull message permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deferred를 활용한 Pull message</h3>\n<p>갑자기 무슨 Deferred인가 싶겠지만, Deferred는 위 문제 해결의 열쇠가 될 수 있다. Deferred는 Promise와 매우 긴밀한 객체다. 만약 Deferred가 무엇인지 잘 모르겠다면, <a href=\"https://api.jquery.com/category/deferred-object/\">jQuery 1.5부터 등장한 Deferred</a>를 잠시 살펴보자. 간단히 개념만 설명해보자면, Promise는 약속을 만드는 자가 약속을 지킨다. 반면 Deferred는 단순히 계약서만 만든다. Deferred의 계약을 지킬 의무는 다른 이가 가질 수 있다.</p>\n<p>Deferred를 Pull 처리에 적용하면 다음과 같은 Promise를 가질 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> deferred<span class=\"token punctuation\">;</span>\n\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">message</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deferred<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    deferred<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    deferred <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">pullMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>deferred<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    deferred <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    deferred<span class=\"token punctuation\">.</span>promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      deferred<span class=\"token punctuation\">.</span>resolve <span class=\"token operator\">=</span> resolve<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> deferred<span class=\"token punctuation\">.</span>promise<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">pullHandle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">pullMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 메시지를 가져와 처리</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 메시지의 도착을 <code class=\"tui-language-text\">pullMessage</code> 함수로 항상 보장할 수 있다. 물론 그냥 봐선 비동기적인 코드인 것은 변하지 않았다, 하지만 Saga의 이펙트와 함께 사용한다면 달라진다. 이 <strong><code class=\"tui-language-text\">pullMessage</code> 함수를 Saga에서 <code class=\"tui-language-text\">Call</code> 이펙트와 사용한다면, Push 기반의 비동기적이었던 로직을 이제 Pull 기반의 동기적인 로직으로 처리할 수 있다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">pullHandle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>pullMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 메시지 처리</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"채널\" style=\"position:relative;\"><a href=\"#%EC%B1%84%EB%84%90\" aria-label=\"채널 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>채널</h2>\n<p>이렇게 Push 동작을 Pull 동작으로 바꾸고 보니, 일반화를 시킬 수 없을까 하는 의문이 든다. Redux-Saga를 사용하는 여러 개발자는 <a href=\"https://en.wikipedia.org/wiki/Communicating_sequential_processes\">CSP(Communicating Sequential Processes)</a>의 <code class=\"tui-language-text\">채널</code>을 제안했다. CSP에는 핵심이 되는 두 가지 추상화가 있다. <code class=\"tui-language-text\">프로세스</code>와 <code class=\"tui-language-text\">채널</code>이다. <code class=\"tui-language-text\">프로세스</code>와 <code class=\"tui-language-text\">채널</code>은 Saga에 잘 어울리는 추상화다.</p>\n<ul>\n<li>프로세스: 동시적(concurrently)으로 수행되는 독립적인 작업이다. 각 코드는 순차적(sequential)으로 처리된다.</li>\n<li>채널: FIFO의 큐다. 각 프로세스는 채널을 통해 데이터를 주고받으며 통신한다. 채널에 <code class=\"tui-language-text\">put</code> 연산으로 데이터를 추가하고, <code class=\"tui-language-text\">take</code> 연산으로 데이터를 가져온다.</li>\n</ul>\n<p>그리고 위 프로세스는 각 <code class=\"tui-language-text\">Saga</code>에 부합한다. 메인테이너인 <a href=\"https://github.com/yelouafi\">yelouafi</a>는 이런 CSP를 부분적으로 차용하여 <a href=\"https://github.com/redux-saga/redux-saga/issues/254\">Redux-Saga의 채널 API를 디자인</a>했다(가장 초기의 채널 구현은 <a href=\"https://github.com/redux-saga/redux-saga/blob/v0.10.0/src/internal/channel.js\">v0.10.0의 channel.js</a>에서 확인할 수 있다).</p>\n<h3 id=\"채널-간단히-살펴보기-upload-progress\" style=\"position:relative;\"><a href=\"#%EC%B1%84%EB%84%90-%EA%B0%84%EB%8B%A8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-upload-progress\" aria-label=\"채널 간단히 살펴보기 upload progress permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>채널 간단히 살펴보기: Upload progress</h3>\n<p>서비스 개발에 <code class=\"tui-language-text\">Redux-Saga</code>를 사용하면서 파일 업로드 기능이 있다고 가정하자. 십중팔구 업로드 프로그레스 표현에 잠시나마 고민하게 될 것이다. 아마 다음처럼 <code class=\"tui-language-text\">store.dispatch</code>를 직접 호출하는 경우를 생각할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">uploadSaga</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  xhr<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"progress\"</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">ev</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n    store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> progress<span class=\"token operator\">:</span> ev<span class=\"token punctuation\">.</span>loaded <span class=\"token operator\">/</span> ev<span class=\"token punctuation\">.</span>total <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>스토어에 대한 의존성을 추가해 <code class=\"tui-language-text\">store.dispatch</code>를 직접 호출하는, 조금 마음에 들지 않는 상황이 먼저 떠오른다. 그런데 더 큰 문제가 있다. Saga가 아닌, 외부 스코프로 함수가 분리된 것이다. 제너레이터(정확히는 Redux-Saga 미들웨어)의 처리 흐름에서 벗어나기 때문에, 여러 다른 이펙트들과 조합하여 로직을 풍부하게 구성할 수 없다.</p>\n<p>이제 채널을 이용해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">uploadSaga</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> progressChan <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">putProgressToChannel</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>loaded<span class=\"token punctuation\">,</span> total<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> progressChan<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>loaded<span class=\"token operator\">/</span>total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    xhr<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'progress'</span><span class=\"token punctuation\">,</span> putProgressToChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">yield</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> progress <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>progressChan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 스토어에 대한 직접적인 의존성이 없어졌다.</span>\n        <span class=\"token comment\">// 여기에서 take, call 등 여러 이펙트들과 함께 풍부한 로직을 구현을 할 수 있다.</span>\n        <span class=\"token keyword\">yield</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>progress<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"외부-이벤트-연결-websocket\" style=\"position:relative;\"><a href=\"#%EC%99%B8%EB%B6%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%97%B0%EA%B2%B0-websocket\" aria-label=\"외부 이벤트 연결 websocket permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>외부 이벤트 연결: WebSocket</h3>\n<p>WebSocket과의 연결에 대한 내용은 이전에 \"<a href=\"http://meetup.toast.com/posts/114\">Redux-Saga에서의 WebSocket(socket.io) 이벤트 처리</a>\"라는 글로 한번 소개한 적이 있었다. 다만 저 글에서는 채널 자체에 대한 설명을 자세히 하지 않고, 채널 API를 활용하는 방식을 중심으로 설명했다. 이번 글을 읽고 다시 저 글을 읽는다면 조금 더 쉽게 읽을 수 있을 것이다.</p>\n<h3 id=\"동시-작업-load-balancing\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C-%EC%9E%91%EC%97%85-load-balancing\" aria-label=\"동시 작업 load balancing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시 작업: Load-balancing</h3>\n<p>채널을 꼭 외부 이벤트에만 연결해야 하는 것은 아니다. 채널은 기본적으로 각 프로세스간의 통신을 위해 추상화된 개념이다. 그래서 채널을 외부 이벤트에 연결하는 것이 아니라, 같은 작업을 동시에 여러 개 수행시키면서 이들의 로드-밸런싱을 목적으로 사용할 수도 있다.</p>\n<p>예를 들어 이미지 섬네일을 요청하는 작업을 한다고 생각해보자.</p>\n<ul>\n<li>섬네일을 만들어야 할 이미지는 수백/수천 개가 있다.</li>\n<li>최대한 빠르게 사용자에게 보여주고 싶지만, 한 번에 수백/수천 개의 요청을 처리하기에는 무리가 있다.</li>\n<li>3개 정도의 Worker를 만들어, 경쟁적으로 이미지 섬네일을 요청하도록 하자.</li>\n</ul>\n<p>간단히 생각해보면 버퍼와 카운팅 변수 가지고 처리할 수도 있을 것 같다. 하지만 구현을 해보면 알겠지만 그리 깔끔하지 않다. 현재 동작하는 Worker가 몇 개인지, 버퍼에 추가 요청이 있는지 없는지 매번 확인하고 처리해야 한다. 혹시라도 조건 체크를 잘못하거나 카운팅을 잘못 계산한다면 수많은 버그를 유발할 수 있다.</p>\n<p>그렇다고 걱정하지 말자. 우리는 채널을 통해 안전하고 더 멋지고 훌륭한 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">NUMBER_OF_WORKERS</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">requestWatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> chan <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">NUMBER_OF_WORKERS</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>requestWorker<span class=\"token punctuation\">,</span> chan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> payload <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token constant\">REQUEST_THUMBNAIL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">yield</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>chan<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">requestWoker</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chan</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> payload <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">take</span><span class=\"token punctuation\">(</span>chan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 서버에 섬네일 요청 및 응답 처리</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>각 Worker는 독립적으로 수행될 것이다. 각각의 처리 속도는 중요하지 않다. 쉬고 있는 Worker들은 알아서 곧바로 다음 요청을 처리할 것이다. 또 우리는 Worker를 동적으로 생성하지 않아도 된다.</p>\n<h3 id=\"더-알아보기---api-v0160\" style=\"position:relative;\"><a href=\"#%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0---api-v0160\" aria-label=\"더 알아보기   api v0160 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>더 알아보기 - API (v0.16.0)</h3>\n<p>Reudx-Saga에서 제공하는 채널과 버퍼는 API문서에 잘 나타나 있다. <strong>아래 설명은 0.16.0 버전을 기준으로 한다.</strong></p>\n<ul>\n<li>\n<p><a href=\"https://redux-saga.js.org/docs/api/#channel\">Channel Interface</a></p>\n<ul>\n<li><a href=\"https://redux-saga.js.org/docs/api/#channelbuffer\">channel</a>: 채널 인터페이스를 구현한 팩토리 함수. 채널은 일반적인 메시지를 <code class=\"tui-language-text\">put</code>, <code class=\"tui-language-text\">take</code> 할 수 있고 버퍼를 적용할 수 있다.</li>\n<li><a href=\"https://redux-saga.js.org/docs/api/#eventchannelsubscribe-buffer-matcher\">eventChannel</a>: 이벤트 채널 팩토리 함수. 이벤트 채널은 외부 이벤트와의 연결을 담당하도록 한다. Subscribe / Unsubscribe를 할 수 있고, 버퍼나 Matcher(=필터)를 적용할 수 있다.</li>\n</ul>\n</li>\n<li><a href=\"https://redux-saga.js.org/docs/api/#actionchannelpattern-buffer\">이펙트 - actionChannel</a>: 액션 채널 이펙트. 액션 채널은 특정 액션만을 받는 채널로 제한하고, 버퍼를 적용할 수 있다.</li>\n<li><a href=\"https://redux-saga.js.org/docs/api/#buffer\">Buffer Interface</a>: 채널에 적용하는 버퍼 인터페이스로 Redux-Saga에서는 <a href=\"https://redux-saga.js.org/docs/api/#buffers\">5가지 버퍼를 제공</a>한다.</li>\n</ul>\n<h3 id=\"더-알아보기---v100-채널-미리보기\" style=\"position:relative;\"><a href=\"#%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0---v100-%EC%B1%84%EB%84%90-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0\" aria-label=\"더 알아보기   v100 채널 미리보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>더 알아보기 - v1.0.0 채널 미리보기</h3>\n<p>아마도, 1.0.0 버전부터 채널은 <code class=\"tui-language-text\">multicast</code>, <code class=\"tui-language-text\">unicast</code> 채널 두 가지가 있을 것이다. <code class=\"tui-language-text\">multicast</code>가 새롭게 추가된 채널이다.</p>\n<ul>\n<li>multicast: 버퍼가 없고, Matcher를 처리할 수 있다. => 대기 중인 taker들은 모두 메시지를 받기 때문에 버퍼는 따로 필요하지 않다.</li>\n<li>unicast: 버퍼가 있고, Matcher를 처리할 수 없다. 기존의 <code class=\"tui-language-text\">channel</code>이나 <code class=\"tui-language-text\">eventChannel</code>은 모두 Matcher가 사라진다.</li>\n</ul>\n<p>그래서 사실 위에서 언급한 <a href=\"#%EC%99%B8%EB%B6%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%97%B0%EA%B2%B0:-WebSocket\">외부 이벤트 연결: WebSocket</a> 글 내용 중 matcher를 처리하는 부분은 이제 사용하지 말아야 한다. <code class=\"tui-language-text\">multicast 채널</code>의 Matcher나, 일반 <code class=\"tui-language-text\">eventChannel</code>의 Subscribe 함수 내부에서 충분히 처리할 수 있다.</p>\n<p>v1.0.0의 채널은 <a href=\"https://github.com/redux-saga/redux-saga/pull/824\">Redux-Saga#PR 824</a>와 <a href=\"https://github.com/redux-saga/redux-saga/releases/tag/v1.0.0-beta.0\">릴리스 노트</a>에서 그 내용을 더 파악해볼 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>Redux-Saga의 채널은 외부 이벤트와의 연결 때문에 개발을 시작했다. 그리고 그 내용은 CSP의 채널과 매우 유사하다. 그런데도 <code class=\"tui-language-text\">Blocking-Put</code>과 같은 동작은 공식적으로 지원하지는 않으려 한다. 그 이유로는 이 기능이 필요한 경우가 많지 않으며, 교착상태를 유발할 수 있다. 또한, 구현은 더 복잡해질 것이고, 사람들이 API를 이해하는데 난이도가 더 올라갈 수 있다는 것이다. 필자도 실제로 지금까지 Redux-Saga를 활용하여 앱을 개발하면서 <code class=\"tui-language-text\">Blocking-Put</code>과 같은 기능은 필요하지 않았다. 개인적으로 꽤 타당한 결정이라는 생각이 들었다.</p>\n<p>이번에 Redux-Saga의 채널을 정리하면서 CSP의 내용도 어느 정도 공부하게 됐고 스스로 많은 도움이 됐다. 여러분에게도 이 글이 조금이나마 도움이 되길 바란다.</p>","frontmatter":{"id":"ko_20180316","title":"Redux-Saga - Channel","description":"이번 글에서는 Redux-Saga의 Channel(이하 채널)에 대해 정리해보고자 한다. 채널은 Redux-Saga의 초기 버전에서부터 고려했던 API는 아니다. 그런데 Stackoverflow에서 외부 이벤트를 Saga와 어떻게 연결하냐는 질문에서 채널의 필요성이 표면적으로 나타나기 시작했다. 핵심은 Push 기반과 Pull 기반 동작이다.","date":"2018.03.16","author":"이민규","tags":["Redux","React"],"thumbnail":"https://image.toast.com/aaaadh/alpha/2017/techblog/ReduxSagaLogoCompact_thumbnail.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20180316","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}