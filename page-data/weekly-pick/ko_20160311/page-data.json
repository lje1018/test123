{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20160311","result":{"data":{"post":{"html":"<h1 id=\"자바스크립트의-스코프와-클로저\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%8A%A4%EC%BD%94%ED%94%84%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80\" aria-label=\"자바스크립트의 스코프와 클로저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트의 스코프와 클로저</h1>\n<h3 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h3>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/15454578/fb3be3e2-2077-11e6-9ec2-c6553a77c74c.png\" alt=\"javascript-overview\"></p>\n<p>기본적으로 자바스크립트는 ECMAScript 언어 명세를 따르고있다. 이 명세 <strong>8장의 실행코드와 실행컨텍스트부분에서 스코프에 관한 동작 방식을 확인</strong>할 수 있으며, 또 중요한 개념인 1급 객체로서의 함수는 그 특징을 명세의 전반적인 부분에서 나타내고 있다. 그리고, <strong>클로저(Closure)에 대한 정의는 없다.</strong> 클로저는 자바스크립트가 채용하고 있는 기술적 기반 혹은 컨셉으로, 자바스크립트는 클로저를 이용하여 스코프적 특징과 일급 객체로서의 함수에 대한 명세를 구현한 것이다.</p>\n<h2 id=\"스코프\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스코프</h2>\n<p>김춘수 시인의 \"꽃\"이라는 시를 보면, 어떤 하나의 몸짓은 이름을 통해 의미를 부여받고 꽃이 된다.</p>\n<p>프로그래밍도 마찬가지로 변수나 함수에 이름을 부여하여 의미를 갖도록 한다. <em>만약 이름이 없다면, 변수나 함수는 다만 그저 하나의 메모리 주소에 지나지 않는다.</em> 그래서 프로그램은 \"이름:값\"의 대응표를 만들어 사용한다. 이 대응표의 이름을 가지고 코드를 보다 쉽게 이해하고, 또 이름을 통해 값을 저장하고, 다시 가져와 수정한다.</p>\n<p>초기 프로그래밍 언어는 이 대응표를 프로그램 전체에서 하나로 관리했는데, 여기에는 이름 충돌의 문제가 있었다. 그래서 충돌을 피하기 위해, 각 언어마다 \"스코프\"라는 규칙을 만들어 정의하였다. <strong>그렇게 스코프 규칙은 언어의 명세(Specification)가 되었다.</strong></p>\n<p>자바스크립트도 마찬가지로 자신의 스코프 규칙이 있다.<br>\n자바스크립트(ES6)는 <code class=\"tui-language-text\">함수 레벨과 블록 레벨</code>의 <code class=\"tui-language-text\">렉시컬 스코프</code>규칙을 따른다.</p>\n<h3 id=\"스코프-레벨\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BD%94%ED%94%84-%EB%A0%88%EB%B2%A8\" aria-label=\"스코프 레벨 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스코프 레벨</h3>\n<p>자바스크립트는 전통적으로 함수 레벨 스코프를 지원해왔고, 얼마전까지만 해도 블록 레벨 스코프는 지원하지 않았다. 하지만 가장 최신 명세인 ES6(ECMAScript 6)부터 블록 레벨 스코프를 지원하기 시작했다.</p>\n<h4 id=\"함수-레벨-스코프\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"함수 레벨 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 레벨 스코프</h4>\n<p>자바스크립트에서 <code class=\"tui-language-text\">var</code>키워드로 선언된 변수나, <code class=\"tui-language-text\">함수 선언식</code>으로 만들어진 함수는 <code class=\"tui-language-text\">함수 레벨 스코프</code>를 갖는다. 즉, 함수 내부 전체에서 유효한 식별자가 된다.</p>\n<p>아래 코드는 아무런 문제없이 <code class=\"tui-language-text\">blue</code>를 출력한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> color <span class=\"token operator\">=</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// blue</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>만약 <code class=\"tui-language-text\">var color</code>가 블록 레벨 스코프였다면, <code class=\"tui-language-text\">color</code>는 <code class=\"tui-language-text\">if</code>문이 끝날때 파괴되고 <code class=\"tui-language-text\">console.log</code>에서 잘못된 참조로 에러가 발생할 것이다. 그렇지만 <code class=\"tui-language-text\">color</code>는 함수 레벨의 스코프이기 때문에 <code class=\"tui-language-text\">foo</code> 함수 내부 어디에서든 에러 발생 없이 참조할 수 있다.</p>\n<h4 id=\"블록-레벨-스코프\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"블록 레벨 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블록 레벨 스코프</h4>\n<p>ES6의 <code class=\"tui-language-text\">let</code>, <code class=\"tui-language-text\">const</code>키워드는 블록 레벨 스코프 변수를 만들어 준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> color <span class=\"token operator\">=</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// blue</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError: color is not defined</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">let color</code>를 <code class=\"tui-language-text\">if</code>블록 내부에서 선언하였다. 때문에 <code class=\"tui-language-text\">if</code>블록 내부에서 참조할 수 있으며, 그 밖의 영역에서 잘못된 참조로 에러가 발생한다.</p>\n<h4 id=\"var-vs-let-const\" style=\"position:relative;\"><a href=\"#var-vs-let-const\" aria-label=\"var vs let const permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"tui-language-text\">var</code> vs <code class=\"tui-language-text\">let</code>, <code class=\"tui-language-text\">const</code></h4>\n<p>ES6가 표준화되면서, 블록 레벨과 함수 레벨을 모두 지원하게 되었다. \"You don't know JS\" 시리즈의 저자인 Kyle Simpson은 <code class=\"tui-language-text\">var</code>, <code class=\"tui-language-text\">let</code>, <code class=\"tui-language-text\">const</code>가 서로 다르기에 필요한 상황에 알맞게 사용할 줄 알아야 한다고 설명하고 있다.</p>\n<p>그렇지만 요즈음 ES6 코드 대부분은 <code class=\"tui-language-text\">var</code>를 사용하지 않는다. <code class=\"tui-language-text\">var</code>는 <code class=\"tui-language-text\">let</code>과 <code class=\"tui-language-text\">const</code>로 모두 대체가 가능하고, <code class=\"tui-language-text\">var</code>자체가 함수 레벨의 스코프를 가지기 때문에 블록 레벨 스코프보다 더 많은 혼란을 야기하기 때문이다.</p>\n<h3 id=\"렉시컬-스코프\" style=\"position:relative;\"><a href=\"#%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"렉시컬 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렉시컬 스코프</h3>\n<p>렉시컬 스코프(Lexical scope)는 보통 동적 스코프(Dynamic scope)와 많이 비교한다.</p>\n<p>위키피디아를 보면 동적 스코프와 렉시컬 스코프를 다음과 같이 정의하고 있다.</p>\n<ul>\n<li>\n<p>동적 스코프</p>\n<blockquote>\n<p>The name resolution depends upon the program state when the name is encountered which is determined by the execution context or calling context.</p>\n</blockquote>\n</li>\n<li>\n<p>렉시컬 스코프 (정적 스코프(Static scope) 또는 수사적 스코프(Rhetorical scope))</p>\n<blockquote>\n<p>The name resolution depends on the location in the source code and the lexical context, which is defined by where the named variable or function is defined.</p>\n</blockquote>\n</li>\n</ul>\n<p>동적 스코프는 프로그램의 런타임 도중의 실행 컨텍스트나 호출 컨텍스트에 의해 결정되고, 렉시컬 스코프에서는 소스코드가 작성된 그 문맥에서 결정된다. 현대 프로그래밍에서 대부분의 언어들은 렉시컬 스코프 규칙을 따르고 있다.</p>\n<p>동적 스코프와 렉시컬 스코프는 자바스크립트와 Perl을 비교하여 확인할 수 있다. 아래는 자바스크립트와 Perl로 같은 코드를 작성하였을 때 나오는 결과이다.\n<img src=\"https://cloud.githubusercontent.com/assets/12269563/15454657/51c5a16a-207a-11e6-91d7-f44bc5945007.png\" alt=\"lexical-scope-js\"></p>\n<p>자바스크립트는는 렉시컬 스코프 규칙을 통해 <code class=\"tui-language-text\">global, global</code>을 출력하였으며, Perl은 동적 스코프 규칙을 통해 <code class=\"tui-language-text\">local, global</code>을 출력하였다. (참고로 Perl에서 <code class=\"tui-language-text\">local</code>대신 <code class=\"tui-language-text\">my</code>키워드를 사용하면 변수의 유효범위를 제한하여, 자바스크립트와 같은 결과를 얻을 수 있다.)</p>\n<p>렉시컬 스코프 규칙을 따르는 자바스크립트의 함수는 <strong>호출 스택과 관계없이 각각의 (<code class=\"tui-language-text\">this</code>를 제외한)대응표를 소스코드 기준으로 정의하고, 런타임에 그 대응표를 변경시키지 않는다.</strong> (사실 런타임에 렉시컬 스코프를 수정할 수 있는 방법들(<code class=\"tui-language-text\">eval</code>, <code class=\"tui-language-text\">with</code>)이 있지만, 권장하지 않는다.)</p>\n<h3 id=\"중첩-스코프스코프-체인-또는-스코프-버블\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EC%B2%A9-%EC%8A%A4%EC%BD%94%ED%94%84%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8-%EB%98%90%EB%8A%94-%EC%8A%A4%EC%BD%94%ED%94%84-%EB%B2%84%EB%B8%94\" aria-label=\"중첩 스코프스코프 체인 또는 스코프 버블 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중첩 스코프(스코프 체인 또는 스코프 버블)</h3>\n<p>우리가 말하는 이 자바스크립트의 스코프는 ECMAScript 언어 명세에서 렉시컬 환경(<code class=\"tui-language-text\">Lexical environment</code>)과 환경 레코드(<code class=\"tui-language-text\">Environment Record</code>)라는 개념으로 정의되었다.</p>\n<blockquote>\n<p>6.2.5 The Lexical Environment and Environment Record Specification Types</p>\n<p>The Lexical Environment and Environment Record types are used to explain the behaviour of name resolution in nested functions and blocks. These types and the operations upon them are defined in 8.1.</p>\n</blockquote>\n<p>간단하게 그림으로 표현해보면 아래와 같은 형태로 볼 수 있다.\n<img src=\"https://cloud.githubusercontent.com/assets/12269563/15632669/0827e896-25d5-11e6-8fa7-8faa0378af98.png\" alt=\"execution-context\"></p>\n<p>앞에서 설명한 \"이름:값의 대응표\"가 환경 레코드와 같다고 볼 수 있고, 렉시컬 환경은 이 환경 레코드와 상위 렉시켤 환경(Outer lexical environment)에 대한 참조로 이루어진다.</p>\n<p>현재-렉시컬 환경의 대응표(환경 레코드)에서 변수를 찾아보고, 없다면 바깥 렉시컬 환경을 참조하여 찾아보는 식으로 중첩 스코프가 가능해진다. 이 중첩 스코프 탐색은 해당하는 이름을 찾던가 아니면 바깥 렉시컬 환경 참조가 <code class=\"tui-language-text\">null</code>이 될때 탐색을 멈춘다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/15632676/43078732-25d5-11e6-80c7-d32a3965e242.png\" alt=\"scope-chain\"></p>\n<p>참고: ECMA-262 Edition3를 보면 자바스크립트의 스코프적 특징은 <code class=\"tui-language-text\">Scope chain</code>(=list)과 <code class=\"tui-language-text\">Activation Object</code>등의 개념으로 설명하였다. 그리고 이 설명들이 전반적으로 널리 알려졌지만, 이 다음 명세인 ECMA262 Edition5부터는 <code class=\"tui-language-text\">Lexical Environment</code>와 <code class=\"tui-language-text\">Environment Record</code>의 개념으로 스코프를 설명하고 있다.</p>\n<h2 id=\"호이스팅\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85\" aria-label=\"호이스팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호이스팅</h2>\n<p>전통적인 자바스크립트 스코프의 특징은 다음 두 가지라는 것을 알았다.</p>\n<ul>\n<li>렉시컬 스코프</li>\n<li>함수 레벨 스코프 (+ 블록 레벨 스코프-ES6)</li>\n</ul>\n<p>그럼 아래와 같은 상황에선 어떤 값이 출력될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> a<span class=\"token punctuation\">;</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">2</code>가 정상적(?)으로 출력된다.<br>\n그럼 다음은 어떨지 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이번에는 <code class=\"tui-language-text\">undefined</code>가 출력된다. 조금 어이없다고 느낄 수 있지만, 사실 알고보면 어이없는 일은 아니다.</p>\n<p>자바스크립트 엔진은 코드를 인터프리팅 하기전에 그 코드를 먼저 컴파일한다. <code class=\"tui-language-text\">var a = 2;</code>를 하나의 구문으로 생각할 수도 있지만, 자바스크립트는 다음 두 개의 구문으로 분리하여 본다.</p>\n<ol>\n<li><code class=\"tui-language-text\">var a;</code></li>\n<li><code class=\"tui-language-text\">a = 2;</code></li>\n</ol>\n<p>변수 선언(생성) 단계와 초기화 단계를 나누고, 선언 단계에서는 그 선언이 소스코드의 어디에 위치하든 해당 스코프의 컴파일단계에서 처리해버리는 것이다. (언어 스펙상으로 변수는 렉시컬 환경이 인스턴스화되고 초기화될때 생성된다고 한다.) 때문에 이런 <strong>선언단계가 스코프의 꼭대기로 호이스팅(\"끌어올림\")되는 작업</strong>이라고 볼 수 있는것이다.</p>\n<p>참고: 블록스코프인 <code class=\"tui-language-text\">let</code>도 호이스팅이 된다. 그렇지만 선언전에 참조할 경우 <code class=\"tui-language-text\">undefined</code>를 반환하지 않고 ReferenceError를 발생시키는 특징이 있다.</p>\n<blockquote>\n<p><strong>Temporal dead zone and errors with let</strong></p>\n<p>In ECMAScript 2015, let will hoist the variable to the top of the block. However, referencing the variable in the block before the variable declaration results in a ReferenceError. The variable is in a \"temporal dead zone\" from the start of the block until the declaration is processed.</p>\n</blockquote>\n<h2 id=\"클로저closure\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\" aria-label=\"클로저closure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저(Closure)</h2>\n<p>자바스크립트에서 (언어 명세에 없는) 클로저에 대한 정의는 꽤 많은 사람들이 가장 궁금해하는 부분이다.</p>\n<p>아래는 실제 v8엔진의 클로저 테스트코드와 사람들이 말하는 클로저의 의미들이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/15812823/4a48f024-2bf4-11e6-9e2d-9b7c5f5ebdc5.png\" alt=\"closure-overview\"></p>\n<p>종합해보면 함수가 무언가를 기억하고 그것을 다시 사용한다는 것을 알 수 있지만, 여전히 모호하게 느껴진다. 이 모호함을 없애기 위해 클로저의 탄생부터 알아봐야 할 것 같다.</p>\n<p>클로저가 가장 처음 등장한 1964년, <a href=\"https://en.wikipedia.org/wiki/Peter_Landin\">Peter J. Landin</a>의 논문(<a href=\"http://comjnl.oxfordjournals.org/content/6/4/308\">The Mechanical Evaluation of Expressions</a>)을 보면 클로저를 다음과 같이 정의하고 있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/15813143/68e63fac-2bf7-11e6-958c-6d26dd912a4d.png\" alt=\"closure\"></p>\n<p>위 정의를 토대로, 클로저를 현대 프로그래밍에서 다음과 같이 해석하여 정의할 수 있을것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">   클로저 =\n     함수 + 함수를 둘러싼 환경(Lexical environment)</code></pre></div>\n<p>함수를 둘러싼 환경이라는것이 바로 앞에서 설명했던 렉시컬 스코프이다. 함수를 만들고 그 함수 내부의 코드가 탐색하는 스코프를 함수 생성 당시의 렉시컬 스코프로 고정하면 바로 클로저가 되는것이다.</p>\n<p>이제 이 클로저가 자바스크립트에 어떻게 녹아들어갔는지 살펴보도록 하자.</p>\n<h3 id=\"자바스크립트의-클로저\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80\" aria-label=\"자바스크립트의 클로저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트의 클로저</h3>\n<ul>\n<li>자바스크립트에서 클로저는 함수가 생성되는 시점에 생성된다.<br>\n= 함수가 생성될 때 그 함수의 렉시컬 환경을 포섭(closure)하여 실행될 때 이용한다.</li>\n</ul>\n<p>따라서 개념적으로 자바스크립트의 모든 함수는 클로저이지만, 실제로 우리는 <strong>자바스크립트의 모든 함수를 전부 클로저라고 부르지는 않는다.</strong></p>\n<p>다음 예시들을 통해서 클로저를 조금 더 정확히 파악할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> color <span class=\"token operator\">=</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">bar</code>함수는 <code class=\"tui-language-text\">우리가 부르는 클로저</code>일까 아닐까?</p>\n<p>일단 <code class=\"tui-language-text\">bar</code>는 <code class=\"tui-language-text\">foo</code>안에 속하기 때문에 <code class=\"tui-language-text\">foo</code>스코프를 외부 스코프(outer lexical environment) 참조로 저장한다. 그리고 <code class=\"tui-language-text\">bar</code>는 자신의 렉시컬 스코프 체인을 통해 <code class=\"tui-language-text\">foo</code>의 <code class=\"tui-language-text\">color</code>를 정확히 참조할 것이다.</p>\n<p>그럼 클로저라 볼 수 있지 않을까?</p>\n<p><em>아니다. 우리가 부르는 클로저라고 하기에는 약간 거리가 있다.</em> <code class=\"tui-language-text\">bar</code>는 <code class=\"tui-language-text\">foo</code>안에서 정의되고 실행되었을 뿐, <code class=\"tui-language-text\">foo</code>밖으로 나오지 않았기 때문에 클로저라고 부르지 않는다.</p>\n<p>대신, 다음 코드는 우리가 실제로 부르는 클로저를 나타내고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">var</span> color <span class=\"token operator\">=</span> <span class=\"token string\">\"red\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> color <span class=\"token operator\">=</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> bar<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> baz <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span>\n<span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 4</span></code></pre></div>\n<ol>\n<li><code class=\"tui-language-text\">bar</code>는 <code class=\"tui-language-text\">color</code>를 찾아 출력하는 함수로 정의되었다.</li>\n<li>그리고 <code class=\"tui-language-text\">bar</code>는 outer environment 참조로 foo의 environment를 저장하였다.</li>\n<li><code class=\"tui-language-text\">bar</code>를 <code class=\"tui-language-text\">global</code>의 <code class=\"tui-language-text\">baz</code>란 이름으로 데려왔다.</li>\n<li><code class=\"tui-language-text\">global</code>에서 <code class=\"tui-language-text\">baz(=bar)</code>를 호출했다.</li>\n<li><code class=\"tui-language-text\">bar</code>는 자신의 스코프에서 <code class=\"tui-language-text\">color</code>를 찾는다.</li>\n<li>없다. 자신의 outer environment 참조를 찾아간다.</li>\n<li>outer environment인 foo의 스코프를 뒤진다. <code class=\"tui-language-text\">color</code>를 찾았다. 값은 <code class=\"tui-language-text\">blue</code>이다.</li>\n<li>때문에 당연히 <code class=\"tui-language-text\">blue</code>가 출력된다.</li>\n</ol>\n<p>이게 바로 클로저다. 그냥 단순하게 보면 \"이 당연하게 왜?\"라고 생각할 수 있지만, 조금 더 자세히 따져보도록 하자.</p>\n<p>일단 중요한 부분은 2~4번, 그리고 7번이다. <strong><code class=\"tui-language-text\">bar</code>는 자신이 생성된 렉시컬 스코프에서 벗어나 global에서 <code class=\"tui-language-text\">baz</code>라는 이름으로 호출이 되었고, 스코프 탐색은 현재 실행 스택과 관련 없는 <code class=\"tui-language-text\">foo</code>를 거쳐 갔다.</strong> <code class=\"tui-language-text\">baz</code>를 <code class=\"tui-language-text\">bar</code>로 초기화 할 때는 이미 <code class=\"tui-language-text\">bar</code>의 <code class=\"tui-language-text\">outer lexical environment</code>를 <code class=\"tui-language-text\">foo</code>로 결정한 이후이다. 때문에, <code class=\"tui-language-text\">bar</code>의 생성과 직접적인 관련이 없는 <code class=\"tui-language-text\">global</code>에서 아무리 호출하더라도 여전히 <code class=\"tui-language-text\">foo</code>에서 <code class=\"tui-language-text\">color</code>를 찾는 것이다. 이런 <code class=\"tui-language-text\">bar(또는 baz)</code>와 같은 함수를 우리는 클로저라고 부른다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/15634032/6cf112dc-25f5-11e6-874c-3107235c777c.png\" alt=\"closure\"></p>\n<p>여기에서 다시한번 강조하지만 JS의 스코프는 렉시컬 스코프, 즉 이름의 범위는 소스코드가 작성된 그 문맥에서 바로 결정되는 것이다.</p>\n<p>추가로, <code class=\"tui-language-text\">foo</code>의 렉시컬환경 인스턴스는 <code class=\"tui-language-text\">foo();</code>수행이 끝난 이후 GC가 회수해야 하는데 사실을 그렇지 않다. 앞에 설명했듯 <code class=\"tui-language-text\">bar</code>는 여전히 바깥 렉시컬 환경인 <code class=\"tui-language-text\">foo</code>의 렉시컬 환경을 계속 참조하고있고, 이 <code class=\"tui-language-text\">bar</code>는 <code class=\"tui-language-text\">baz</code>가 여전히 참조하고 있기 때문이다.(<code class=\"tui-language-text\">baz(=bar) -&gt; foo</code>)</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/15634093/96894122-25f6-11e6-909e-66f5acb5dedb.png\" alt=\"gc-closure\"></p>\n<h3 id=\"유명하고-또-유명한-반복문-클로저\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EB%AA%85%ED%95%98%EA%B3%A0-%EB%98%90-%EC%9C%A0%EB%AA%85%ED%95%9C-%EB%B0%98%EB%B3%B5%EB%AC%B8-%ED%81%B4%EB%A1%9C%EC%A0%80\" aria-label=\"유명하고 또 유명한 반복문 클로저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유명하고 또 유명한 반복문 클로저</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 코드는 1, 2, 3, ... 9를 0.1초마다 출력하는 것이 목표였는데, 결과로는 <code class=\"tui-language-text\">10</code>이 9번 출력되었다. 왜일까?</p>\n<p><code class=\"tui-language-text\">timer</code>는 클로저로 언제 어디서 어떻게 호출되던지 항상 상위 스코프인 <code class=\"tui-language-text\">count</code>에게 <code class=\"tui-language-text\">i</code>를 알려달라고 요청할 것이다. 그리고 <code class=\"tui-language-text\">timer</code>는 0.1초 후 호출된다. 그런데 첫 0.1초가 지날 동안 이미 <code class=\"tui-language-text\">i</code>는 <code class=\"tui-language-text\">10</code>이 되었다. 그리고 <code class=\"tui-language-text\">timer</code>는 0.1초 주기로 호출될 때마다 항상 <code class=\"tui-language-text\">count</code>에서 <code class=\"tui-language-text\">i</code>를 찾는다. 결국, <code class=\"tui-language-text\">timer</code>는 이미 <code class=\"tui-language-text\">10</code>이 되어버린 <code class=\"tui-language-text\">i</code>만 출력하게 된다.</p>\n<p>그럼 의도대로 1~9까지 차례대로 출력하고 싶으면 어떻게 해야할까?</p>\n<ol>\n<li>새로운 스코프를 추가하여 반복시마다 그곳에 각각 따로 값을 저장하는 방식</li>\n<li>ES6에서 추가된 블록 스코프를 이용하는 방식</li>\n</ol>\n<p>이렇게 두 가지가 있을 것이다.</p>\n<p>다음 코드는 원래 의도대로 동작한다.</p>\n<p>1.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">countingNumber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>countingNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>2.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">timer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>니시오 히로카즈, 『코딩을 지탱하는 기술』, 김완섭, 비제이퍼블릭(2013)</li>\n<li>니콜라스 자카스, 『JavaScript for Web Developers』, 한선용, 인사이트(2013)</li>\n<li>카일 심슨, 『You don't know JS - 스코프와 클로저』, 최병현, 한빛미디어(2015)</li>\n<li>ECMAScript 2015 Language Specification, <a href=\"http://www.ecma-international.org/ecma-262/6.0/\">http://www.ecma-international.org/ecma-262/6.0/</a></li>\n<li>Wikipedia, 『Scope』, <a href=\"https://en.wikipedia.org/wiki/Scope_(computer_science\">https://en.wikipedia.org/wiki/Scope_(computer_science</a>)</li>\n<li>『Temporal dead zone and errors with let』 <br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let</a></li>\n<li>『var, let, const』 <br>\n<a href=\"https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75\">https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75</a></li>\n</ul>","frontmatter":{"id":"ko_20160311","title":"자바스크립트의 스코프와 클로저","description":"기본적으로 자바스크립트는 ECMAScript 언어 명세를 따르고있다. 이 명세 **8장의 실행코드와 실행컨텍스트부분에서 스코프에 관한 동작 방식을 확인할 수 있으며, 또 중요한 개념인 1급 객체로서의 함수는 그 특징을 명세의 전반적인 부분에서 나타내고 있다. 그리고, 클로저(Closure)에 대한 정의는 없다. 클로저는 자바스크립트가 채용하고 있는 기술적 기반 혹은 컨셉으로, 자바스크립트는 클로저를 이용하여 스코프적 특징과 일급 객체로서의 함수에 대한 명세를 구현한 것이다.","date":"2016.03.11","author":"이민규","tags":["ecmascript"],"thumbnail":"https://cloud.githubusercontent.com/assets/12269563/15454578/fb3be3e2-2077-11e6-9ec2-c6553a77c74c.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20160311","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}