{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/en_20200708","result":{"data":{"post":{"html":"<h1 id=\"a-programmers-attitude-towards-effective-test-cases\" style=\"position:relative;\"><a href=\"#a-programmers-attitude-towards-effective-test-cases\" aria-label=\"a programmers attitude towards effective test cases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A Programmer's Attitude Towards Effective Test Cases</h1>\n<p>It is always a crowd's favorite to ask questions like <strong>\"how should one test private methods?\"</strong> and <strong>\"Should one test private methods?\"</strong> on different communities, and I have long thought to organize my thoughts and to write a summary for such questions. The topic itself is relatively straightforward, but the answer may differ from one developer to another. Especially, the topic seems extra divided in the international forums. However, in essence, this question can be boiled down to what effective test cases are.</p>\n<p>Private methods were drafted within the object oriented perspective, and functions hidden in the closures, in the sense that they access the exposed functions from within, are products of the same concept. These ideas can all be categorized as encapsulated items that are hidden behind the module's external interface, and can be called internal implementation for the sake of simplicity. Now the question remains, should you test the internal implementations? To save you some time, the answer is \"no.\" Well, actually the answer is \"yes,\" and by now it is fair for you to wonder what I'm on. You must refrain from directly writing test cases for internal implementations and should only test the exposed external interfaces. In conclusion, <strong>they must be tested.</strong></p>\n<p>It is acceptable to write temporary test cases for internal implementations to automate the repetitive tests, but the final code should only contain test cases regarding the external interface.</p>\n<p>You can write test cases that reflect the current situation, but you must keep only the test cases for the future.</p>\n<h2 id=\"so-whats-the-gist-physicist\" style=\"position:relative;\"><a href=\"#so-whats-the-gist-physicist\" aria-label=\"so whats the gist physicist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>So, what's the gist, physicist?</h2>\n<p>From now on, let's consider the act of testing to be writing test cases to automate the tests for a certain module. I will not blabber on and on about numerous benefits of testing, as the benefits are clear and can be found anywhere with ease. Different developers emphasize different benefits of testing, and I will also not differentiate between unit tests and integrated tests. This article purely discusses automated test codes. Such tests may or may not utilize TDD methodology.</p>\n<p>It has been around seven years since I began pursuing the TDD pattern, the methodology of seriously utilizing tests. Since then, my thoughts on testing have become ever more clear. <strong>The sole purpose of testing is to assist the developer (project).</strong> In reality, it hardly matters how a developer writes the test cases, as long as they benefit the developer in any way. Therefore, whether to include internal implementations in testing is up to the individual developer and one's preferences need not be questioned. Therefore, the developer has the freedom to test the private methods if the developer finds it necessary. Regarding this sentiment, no one, not even Mr. Kent Beck, Martin, or Uncle Bob should have a say. However, freedom is only exercisable when working alone. When you are working on a project with a team, it's a whole new world.</p>\n<p>I must admit that I sometimes write test cases for the internal implementations. But this only holds true for temporary cases. It is acceptable to write test cases to automate the divided test routines, and it is often the case when you adhere to the TDD process where you start off by testing external interfaces and ending up testing the internal implementations. In some cases, the interface may even be removed or combined. <strong>The test cases that directly test the internal implementations must be removed and assimilated into tests for external interfaces according to the changes in the module.</strong></p>\n<h2 id=\"the-dangers-of-self-satisfaction\" style=\"position:relative;\"><a href=\"#the-dangers-of-self-satisfaction\" aria-label=\"the dangers of self satisfaction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Dangers of Self Satisfaction</h2>\n<p><strong>Directly testing the internal implementations devalues the future worth of the test cases.</strong> In other words, they are of no help. While it may feel like you're writing test cases, you must never be sucked into the Red-Green-Refactoring cycle as illustrated by TDD without truly understanding the benefits of test cases like a code junkie addicted on dopamine. Sometimes, the test cases may not be helpful.</p>\n<p>If you have personal experience, you will have a visceral understanding of the fact that it is exponentially easier to test internal implementations rather than to test using the external interfaces. Furthermore, testing internal implementations feels more intuitive, resulting in a higher code-to-satisfaction rate. It may be our instinct to write test cases to get a quick view of the whole picture, and such test cases leave you in a state of pride and euphoria. However, to reiterate, not all test cases are always helpful. <strong>The fewer the test cases, the better. The value of tests are measured by the efficiency of optimizing the maximal effect with minimal test cases.</strong> The opposite scenario with innumerable test cases will hinder the project by interfering with every minuscule step along the way. Such micromanagement is sure to cause an adverse attitude towards testing.</p>\n<p>The number of unnecessary test cases and the value of necessary test cases are inversely related, and the trust of the project's test cases will plummet. <strong>As soon as the project loses its trust in its test cases, the test cases become a hinderance that matches the legacy codes in annoyance.</strong> You'll end up in a place where you can't stop writing test cases nor removing test cases while maintaining zero value. Or, the worst case scenario, you may have persuaded yourself that the test cases are beneficial.</p>\n<h2 id=\"the-relationship-between-the-module-and-the-test-cases\" style=\"position:relative;\"><a href=\"#the-relationship-between-the-module-and-the-test-cases\" aria-label=\"the relationship between the module and the test cases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Relationship Between the Module and the Test Cases</h2>\n<p>The modules within the application have respective responsibilities and can be modified in terms of features or replaced with a better performing module. They are the software version of small cogs in a larger machine.</p>\n<p>Outdated cog can be replaced with a cog that is lighter, faster, or safer. Here, the larger machine does not care one bit about the unnecessary details of the cog like its color or material as long as the cog fits and works. It is simply satisfied with the fact that the cog is able to maintain its function. Therefore, the only thing that needs to be tested before replacing an older cog with a new cog is whether the cog functions expectedly with other cogs.</p>\n<p>The test cases ensure that each module can maintain its responsibility upon modifying or adding new features. Furthermore, it can provide a sense of trustworthiness of the larger machine known as the application when the internal implementations have been refactored, modified, or even replaced.</p>\n<p>Therefore, the test cases must ensure that the entire system can perform expectedly regardless of which module is being tested. It hardly matters what the cog looks like or what the cog is made of. It doesn't even matter whether the cog is actually a cog within a cog like a set of Russian dolls. The user must only be aware of the exposed externalities of the cog and must be able to utilize what is made public to them. Such is the function and the responsibility of the cog. Test cases can also be considered to be the module's users. <strong>The test cases must test for the module's unchanging responsibility, not the changeable internal implementations.</strong> If the external interface that enables the module to adequately perform its duties are constantly changing, it is a sign that there are design flaws in the application.</p>\n<p>Modules must always maintain the external interface regardless of the internal implementations; in other words, it must be able to be replaced with a module with the identical function and responsibilities. The test cases that seeks to test the modules should only be aware of the module's abstract responsibilities. In doing so, this acknowledges the modules' diversity and autonomy.</p>\n<p>If you think you've seen this somewhere else, you are correct. This is Dependency Inversion Principle (SOLID aka DIP). While it is not identical in the literal sense, the equality stands in terms of the purpose and the effect. <strong>The test cases must look at the modules as the modules' user, and the test cases must not depend on the module's internal details. It must rely on the abstractness.</strong> The tests must target the abstract responsibilities not the modules. This is how you ensure flexible test cases and ultimately, this is how you <em>test any module that share the same interfaces.</em></p>\n<p><strong>If there are still modules that you think need to be tested internally, it is likely a signal that the module may need to be separated as an independent module with its own responsibilities.</strong> If the internal implementation can be extracted as an independent class or a module, test cases can be written to test the external interface for this entity. Such is a good example of modifying the internal implementation to be an external interface.</p>\n<p><strong>Consider the test case to be the module's user.</strong> The user does not need to know the internal implementation of the module. This is the relationship between the test case and the module, and the test case is also a module that has the target module as a dependency.</p>\n<h2 id=\"effective-test-cases\" style=\"position:relative;\"><a href=\"#effective-test-cases\" aria-label=\"effective test cases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Effective Test Cases</h2>\n<p>The effective test cases can be inspected from two different perspectives: the present and the future.</p>\n<p>The test cases written for the <strong>present</strong> automate the tests for the current code. This can manage different input values and can reduce the time spent on checking the results. It is possible for the internal implementations (or what you thought were external interfaces) to be tested during this process simply because it is beneficial from the perspective of task automation. Furthermore, as more test cases pile up, it can prevent the side effects of newer codes interefering with the original codes.</p>\n<p>While TDD does not directly help with the application's structural design, it can be incredibly beneficial in terms of managing the roles and responsibilities of the modules within a cooperative framework. Throughout this process, the separation between the ins and outs of the program is made clearer. Writing test cases before the actual program signifies programming from the users' perspective.</p>\n<p>The test cases written for the <strong>future</strong> not only describe the target module's roles and responsibilities but also must become a detailed user's manual. The simple act of reading the description must provide the user with a complete understanding of the test cases--brief yet to the point. Furthermore, if there are changes in functionality or additions to the target module, the test cases must automatically ensure that the changes are in compliant with the existing specs in order to minimize the possible risks. In the extreme sense, it must be able to ensure the same functionality even after having changed the module entirely.</p>\n<p><strong>Regardless of whether you follow the TDD cycle or not, in order to maximize the efficiency of writing test cases, you must write test cases for the present while translating it to be future oriented as the project progresses.</strong> Clearly, you can begin with writing future oriented test cases. The important thing is to remove unnecessary test cases and to improve better tests along the way.</p>\n<p>If you have adopted the TDD pattern or test automation for a project, you must commit to developing and refactoring tests as well as modules continuously. <em>The test cases are what allows the modules to maintain the external interface while optimizing the internal codes to be faster and lighter.</em> Since there cannot be a perfect code to begin with, the test cases must also evolve to be faster, lighter, and more intuitive. <strong>Test cases are modules that test other modules.</strong> They must be given the respect that they deserve. The mere act of writing test cases does not automatically make the program better. It can even be a hurdle and an annoyance. You must continuously strive to make better test cases and to come up with better testing methods.</p>\n<p>\"The single ultimate way to come up with effective test cases\" for all projects does not exist. Only the best given the project's situation can exist. <strong>Understanding the benefits the test cases offer and what test cases can be of help is the bare minimum of writing appropriate test cases for the project and the stating point.</strong></p>\n<h2 id=\"test-the-internal-implementation-only-through-public-interface\" style=\"position:relative;\"><a href=\"#test-the-internal-implementation-only-through-public-interface\" aria-label=\"test the internal implementation only through public interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Test the Internal Implementation Only Through Public Interface</h2>\n<p>As I have previously mentioned, the test cases should not have direct knowledge of the internal implementations, and the internal implementations should only be tested through the public interfaces. The internal implementations are bound to be used by the public interfaces. If not, such codes should be removed. While it may be easier to test the internal implementations directly, we must remember that we are not writing test cases just for the sake of writing test cases. We are writing test cases to get the benefits of test automation by writing the tests.</p>\n<p>Amidst the debate on \"whether or not to test the internal implementations,\" there are some who claim that testing the internal implementations through the external interface makes it harder to test for the completeness of the program. <strong>This is because it is difficult to understand the range of the internal implementations that are being tested.</strong> Here, I offer you a little tip. <strong>The coverage is the metric designed to be used exactly for this purpose.</strong> It is not merely a tool to see which programmer has written good test cases.</p>\n<p>Coverage is a metric that one can refer to when there are difficulties in determining the range of tests in cases like using the public interface to test the internal implementations. While it does not validate the quality of the tests, it can validate the quantity of the tests appropriately. It is necessary to keep in mind that one can write a completely useless test case and still achieve near 100% in terms of coverage. <strong>While the coverage does not guarantee quality, it provides an outline for which parts of the modules the test cases have been written and for which parts of the modules to write the next test cases.</strong> The coverage is exactly as advertised. Some people ask you ambitious questions like how much coverage you have when you tell people that you are following a TDD pattern, but when you consider the underlying intent of the question, (I'll hold my tongue and any further judgements.)</p>\n<p>If you are developer seriously intent on implementing TDD pattern or test automations for a project, you'll more likely be interested in the separation of what is testable and what is not. The separation of testability can be thought of in terms of standard, method, and consensus, but I will refrain from going into more detail in this article.</p>\n<h2 id=\"closing-remarks\" style=\"position:relative;\"><a href=\"#closing-remarks\" aria-label=\"closing remarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Closing Remarks</h2>\n<p>In conclusion, it is my belief that the test cases and modules should be weighted equally. They are, in essence, modules that are responsible for testing other modules. If you think of the relationship between the test cases and the modules to be a relationship between two modules, you'll get a better understanding of how the test cases should treat the target modules.</p>\n<p>For a front-end developer, test automation was one of the harder subjects. The test cases written in codes are more suitable for situations where the inputs and outputs consist of programmable data. To front-end developers, the side effects or visible results that cannot be quantified with data have always posed difficult challenges. Fortunately, with the advancements in front end came front end testing technology. With the numerous options, now, the challenge is to determine which option would yield the best results.</p>\n<p>As is the commonly accepted fact in the programming landscape, there is not an ultimate solution, but the tests and methodologies will continue to evolve as independent fields of software development. We must not forget that the most important thing amidst all the changes is the test efficiency. We must continue to look at things objectively. Only the <em>tests that are truly beneficial</em> can help you. <em>Tests that seem helpful</em> may end up coming back to haunt you.</p>","frontmatter":{"id":"en_20200708","title":"A Programmer's Attitude Towards Effective Test Cases","description":"It is always a crowd's favorite to ask questions like \"how should one test private methods?\" and \"Should one test private methods?\" on different communities, and I have long thought to organize my thoughts and to write a summary for such questions.","date":"2020.07.08","author":"Sungho Kim","tags":["test"],"thumbnail":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"en_20200708","lang":"en"}},"staticQueryHashes":["2997033868","414700122","542722004"]}