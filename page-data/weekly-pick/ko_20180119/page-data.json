{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20180119","result":{"data":{"post":{"html":"<h1 id=\"redux-saga-제너레이터와-이펙트\" style=\"position:relative;\"><a href=\"#redux-saga-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%99%80-%EC%9D%B4%ED%8E%99%ED%8A%B8\" aria-label=\"redux saga 제너레이터와 이펙트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux-Saga: 제너레이터와 이펙트</h1>\n<p><a href=\"/test123/weekly-pick/ko_20171124\">지난 글</a>에서 Redux-Saga와 사이드 이펙트를 가지고 공부 겸 정리 겸 글을 작성했다. 이번 글에선 Redux-Saga에서 사용하는 제너레이터함수, 이펙트에 대해 정리해보려 한다. 제너레이터함수는 협력적이고, run-to-completion이 아니며, 그렇다고 비동기도 아닌 그런 함수다. 그리고 이펙트는 Redux-Saga의 가장 중심이 되는 특징이다. 마치 Redux의 Action처럼 단순한, 일반적인 객체인데 개발자에겐 어마어마한 마법을 보여준다. 그리고 대부분의 서비스 로직을 이 이펙트로 작성한다. 이 두 가지를 이해한다면 이제 Redux-Saga는 <code class=\"tui-language-text\">뭔지 모르겠는데 엄청 대단해 보이는 것</code>에서 <code class=\"tui-language-text\">엄청 대단한 건데 난 이해함ㅋ</code>이 될거라 생각한다.</p>\n<h2 id=\"제너레이터\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"제너레이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제너레이터</h2>\n<p>Redux-Saga는 제너레이터를 아름답게 사용한다. Redux-Saga의 Saga가 바로 <code class=\"tui-language-text\">제너레이터함수</code>다. Redux-Saga의 설명을 이어나가기 위해 제너레이터에 대해 간단히 알아보는 게 좋겠다.</p>\n<p>개인적으로 명칭에 (아주 조금) 집착한다. 많은 사람이 <code class=\"tui-language-text\">제너레이터</code>와 <code class=\"tui-language-text\">제너레이터함수</code>를 구분하지 않거나, 이를 <code class=\"tui-language-text\">제너레이터</code>와 <code class=\"tui-language-text\">이터레이터</code>로 잘못 구분하는데, 이를 먼저 정확히 짚고 넘어가고 싶다. 그리고 이 글에서는 시각적 구분을 위해 <code class=\"tui-language-text\">제너레이터함수</code> 단어에서 함수를 띄어 쓰지 않고 붙여 쓰겠다.</p>\n<p>우선 요약하면 <em>제너레이터는 제너레이터함수의 반환이다</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">myGeneratorFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> generator <span class=\"token operator\">=</span> <span class=\"token function\">myGeneratorFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>generator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>generator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>generator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<p>우리가 <code class=\"tui-language-text\">function*</code> 키워드로 작성하는 함수는 제너레이터가 아닌 <code class=\"tui-language-text\">제너레이터함수</code>다. 그리고 이 제너레이터함수를 호출하면 반환되는 객체가 바로 <code class=\"tui-language-text\">제너레이터</code>다. 제너레이터는 <code class=\"tui-language-text\">이터레이터(Iterator)</code> 프로토콜과 <code class=\"tui-language-text\">이터러블(Iterable)</code> 프로토콜을 따른다.</p>\n<p>이터러블 프로토콜은 단순히 <code class=\"tui-language-text\">obj[Symbol.iterator]: Function =&gt; Iterator</code>로 표현할 수 있다. 객체는 이터레이터 심볼 키값에 이터레이터를 반환하는 메서드를 가지고 있다면 이터러블이다.</p>\n<p>이터레이터 프로토콜도 단순하다. 객체가 <code class=\"tui-language-text\">next</code>라는 메서드를 가지고 있고, 그 결과로 <code class=\"tui-language-text\">IteratorResult</code> 라는 객체를 반환하면 된다. 반환되는 IteratorResult는 <code class=\"tui-language-text\">{done: boolean, value: any}</code> 형태의 단순한 객체다.</p>\n<p>이러한 이터러블, 이터레이터에 대한 정확한 정의는 <a href=\"https://www.ecma-international.org/ecma-262/8.0/index.html#sec-control-abstraction-objects\">ECMAScript의 명세 - 25장</a>에 있으니 괜찮다면 간단히 살펴봐도 좋다. (참고로, Redux-Saga에서 많이 사용하는 <code class=\"tui-language-text\">takeEvery</code>, <code class=\"tui-language-text\">takeLatest</code> 등의 helper는 제너레이터를 사용하지 않고 이터레이터 객체를 직접 만들어 사용한다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">/* 제너레이터는 이터레이터 프로토콜을 따른다. */</span>\n\n<span class=\"token comment\">// 1. \"function\"</span>\n<span class=\"token keyword\">typeof</span> generator<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 2. {done: boolean, value: any} 반환</span>\ngenerator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//-----//</span>\n\n<span class=\"token comment\">/* 제너레이터는 이터러블 프로토콜을 따른다. */</span>\n\n<span class=\"token comment\">// 1. \"function\"</span>\n<span class=\"token keyword\">typeof</span> generator<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 2. 이터레이터가 반환된다.</span>\n<span class=\"token keyword\">const</span> iterator <span class=\"token operator\">=</span> generator<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typeof</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {done: boolean, value: any}</span></code></pre></div>\n<p>한 가지 재밌는 점은, 제너레이터는 이터러블이면서 이터레이터라는 것인데, 이터러블에서 반환하는 이터레이터가 바로 자기 자신이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">/* \n  제너레이터의 이터러블 구현은 아래처럼 정말 간단할 것이다.\n  generator[Symbol.iterator] = () => this;\n*/</span>\ngenerator <span class=\"token operator\">===</span> generator<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<h3 id=\"제너레이터함수---caller와-callee\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%ED%95%A8%EC%88%98---caller%EC%99%80-callee\" aria-label=\"제너레이터함수   caller와 callee permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제너레이터함수 - Caller와 Callee</h3>\n<ul>\n<li>제너레이터함수는 Callee, 이를 호출하는 함수는 Caller다.</li>\n<li>Caller는 Callee가 반환한 제너레이터를 가지고 로직을 수행한다.</li>\n<li>Caller는 Callee의 <code class=\"tui-language-text\">yield</code> 지점에서 다음 진행 여부/시점을 제어한다.</li>\n</ul>\n<p>Caller는 Callee를 호출하는 책임뿐 아니라 Callee 내부 로직 수행에 대한 제어권을 갖는다(더 진행하지 않거나, 에러를 발생시킬 수도 있다). 흔히 Caller를 <code class=\"tui-language-text\">Runner</code>라는 이름으로 부르기도 하는데, 이전에 우리 위클리에서 작성했던 \"<a href=\"/test123/weekly-pick/ko_20160729\">Generator in Practice - [1부] 기본 속성과 Runner</a>\"를 한번 읽어보자. (제너레이터 자체에도 관심이 있다면 \"<a href=\"/test123/weekly-pick/ko_20160408\">ES6의 제너레이터를 사용한 비동기 프로그래밍</a>\" 글도 읽어보길 추천한다.)</p>\n<p>Redux-Saga 입장으로 보면 미들웨어는 Caller이고, 우리가 작성한 Saga는 Callee다.</p>\n<h3 id=\"redux-saga와-제너레이터\" style=\"position:relative;\"><a href=\"#redux-saga%EC%99%80-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"redux saga와 제너레이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux-Saga와 제너레이터</h3>\n<p>지금까지 제너레이터함수, Caller(=Runner)와 Callee에 대해 간단히 알아보았다. 그리고 Redux-Saga에서 말하는 <strong>Saga는 바로 제너레이터함수다.</strong> 그럼 왜 Saga를 제너레이터함수로 구현할까? 이는 곧 Redux-Saga가 이펙트라 부르는 것들을 어떻게 만들고 사용하는지와 연관된다. 우리가 Redux-Saga를 사용한다는 것은 곧 <strong>Redux-Saga 미들웨어에 우리의 Saga를 등록하고 수행시킨다</strong>는 뜻이다. 미들웨어는 Saga를 끊임없이 동작시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// Saga의 초기화, 시작 코드에는 항상 \"run\"이 있다.</span>\nmiddleware<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>RootSaga<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Saga는 제너레이터함수이고, 미들웨어는 Saga에게 yield 값을 받아서 또 다른 어떤 동작을 수행할 수 있다. <strong>Saga는 명령을 내리는 역할만 하고, 실제 어떤 직접적인 동작은 미들웨어가 처리할 수 있다는 뜻이다.</strong> <code class=\"tui-language-text\">redux-thunk</code>와의 가장 큰 차이점이다.</p>\n<p>비교를 위해 간단한 redux-thunk 비동기 함수를 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">asyncIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">async</span> <span class=\"token parameter\">dispatch</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">\"INCREMENT\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 함수는 스스로 비동기적인 처리를 직접 수행한다. 저 함수에 대한 테스트가 필요하다면, 1초를 기다리고 dispatch 하는 것을 어떻게 증명할지 생각해보자. 딱히 마음에 드는 방법은 떠오르지 않는다. 문제는 함수 내부에 비동기적인 로직이 그대로 녹아있다는 것이다.</p>\n<p>Saga에서 다음과 같이 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">asyncIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Saga는 아래와 같이 간단한 형태의 명령만 yield 한다.</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>delay<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {CALL: {fn: delay, args: [1000]}}</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">\"INCREMENT\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//  {PUT: {type: 'INCREMENT'}}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"tui-language-text\">call</code>이든 <code class=\"tui-language-text\">put</code>이든 모두 직접적인 처리를 하지 않는다(call, put은 이펙트 생성자(Effect creator)라 부른다). 명령을 만들어주기만 하고, 이 명령에 따른 직접적인 처리는 모두 미들웨어가 한다. 그래서 이런 Saga는 테스트도 정말 간단하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// TestCase</span>\n<span class=\"token comment\">// 실제로 Delay 시키는게 아니라 이에 대한 명령뿐이므로 테스트에서 1초씩 기다릴 필요가 없다.</span>\n<span class=\"token comment\">// 단지 어떤 명령이 내려지는지만 확인하면 된다.</span>\n\n<span class=\"token keyword\">const</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">asyncIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>delay<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">\"INCREMENT\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그리고 Saga에서 비동기 처리가 아무리 복잡해도 대부분은 <code class=\"tui-language-text\">if</code>, <code class=\"tui-language-text\">else</code>, <code class=\"tui-language-text\">for</code>와 같은 간단한 코드만으로 구현할 수 있다. 스코프가 복잡해지는 것도 아니다. Redux-Saga는 이런 이점을 위해 제너레이터함수를 Saga로 사용한다.</p>\n<h2 id=\"이펙트\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%ED%8E%99%ED%8A%B8\" aria-label=\"이펙트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이펙트</h2>\n<p>이펙트는 미들웨어에 의해 수행되는 명령을 담고 있는 자바스크립트 객체라고 생각하면 된다. 앞서 잠깐 살펴본 <code class=\"tui-language-text\">call</code>이나 <code class=\"tui-language-text\">put</code> 모두 이펙트 생성자고, 생성된 이펙트는 모두 일반 자바스크립트 객체일 뿐이다. 이펙트 생성자는 항상 일반 객체를 만들기만 하고, 어느 다른 동작도 수행하지 않는다. <strong>Saga는 명령을 담고 있는, 이펙트라 부르는 순수한 객체를 yield 할 것이고, 미들웨어는 이런 명령들을 해석해 처리하고, 그 결과를 다시 Saga에 돌려준다.</strong> 예를 들어 <code class=\"tui-language-text\">call(fn, arg1, arg2)</code> 이펙트를 Saga에서 yield 했다면, 미들웨어는 <code class=\"tui-language-text\">fn(arg1, arg2);</code>으로 수행하고 그 결과를 다시 Saga에 전달한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269563/35209011-8472866a-ff8e-11e7-8ce8-fe4868fdbbf9.png\" alt=\"saga-middleware-flow\"></p>\n<p>물론 Saga는 반드시 이펙트만을 yield 해야 하는 것은 아니다. 일반적인 Promise도 yield 할 수 있고, 미들웨어는 이 역시도 훌륭히 resolve나 reject를 기다려줄 것이다. 하지만 이런 비동기 로직을 Saga 내부에서 직접 처리하면 테스트, 여러 다른 이펙트들과의 상호작용이 어렵다. thunk에서 크게 달라지는 점이 없다. 때문에 되도록 이펙트만을 yield 하는 Saga를 작성하길 추천한다.</p>\n<p>Saga의 이펙트는 10가지 이상으로 우리가 활용하는 데 큰 문제가 없을 만큼 다양하다. 비록 이 글에서 이펙트들을 하나하나 설명하진 못했지만, <a href=\"https://redux-saga.js.org/docs/api#effect-creators\">Effect creators</a> API를 참고한다면 Saga를 적극적으로 활용하는 데 많은 도움이 될 것이다. 이펙트는 단순히 테스트만을 위해서 만든 것이 아니다. 이런 이펙트들은 pulling이나, non-blocking, blocking, parallel 등의 다양한 특징들을 가지고 있고, 이런 특징들을 이용해서 정말 수많은 동작들을 손쉽게 처리할 수 있다. 공식 문서의 <a href=\"https://redux-saga.js.org/docs/advanced/\">Advanced Concepts</a>에 그 내용들이 잘 나타나 있다.</p>\n<p>그리고 최근 <a href=\"https://github.com/redux-saga/redux-saga/releases/tag/v1.0.0-beta.0\">1.0 beta 릴리스</a>에 이펙트 미들웨어가 추가됐다. 이는 기본적으로 제공해주는 이펙트가 아닌 커스텀한 이펙트를 만들어 활용할 수도 있다는 뜻이다. 이펙트를 직접 만들어 사용하는 것은 어렵지 않다. 지금까지 우리는 Redux의 액션을 마음껏 사용해왔으니, 이런 일반 객체를 다루는 것에 익숙해져 있을 것이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>Redux-Saga는 비교적 생소한 제너레이터 기반의 미들웨어로 진입 장벽이 높게 느껴지는 것은 맞다. 적어도 <code class=\"tui-language-text\">redux-thunk</code>에 비교해선 훨씬 높다. 하지만 제너레이터를 이해하고, Redux-Saga를 조금 더 친근하게 바라본다면 이런 활용성에 이 정도로 쉽게 사용할 수 있는 라이브러리도 없지 않을까 싶다.</p>\n<p>이펙트 외에도 Redux-Saga를 배우거나 활용하는 내용은 정말 많이 남아있다. 채널도 그중 하나인데, 채널의 경우 정말 활용성이 높기도 하고, 이번 1.0 beta 릴리스에서 Redux-Saga 자체적으로도 개념을 따로 정리하기도 했다.</p>\n<p>아직 <code class=\"tui-language-text\">redux-thunk</code>에서 여러 복잡한 처리들로 고생한다면, 이젠 정말 Redux-Saga를 활용해보는 것도 적극적으로 추천한다.</p>","frontmatter":{"id":"ko_20180119","title":"Redux-Saga - 제너레이터와 이펙트","description":"지난 글에서 Redux-Saga와 사이드 이펙트를 가지고 공부 겸 정리 겸 글을 작성했다. 이번 글에선 Redux-Saga에서 사용하는 제너레이터함수, 이펙트에 대해 정리해보려 한다. 제너레이터함수는 협력적이고,run-to-completion이 아니며, 그렇다고 비동기도 아닌 그런 함수다. 그리고 이펙트는 Redux-Saga의 가장 중심이 되는 특징이다. 마치 Redux의 Action처럼 단순한, 일반적인 객체인데 개발자에겐 어마어마한 마법을 보여준다. 그리고 대부분의 서비스 로직을 이 이펙트로 작성한다. 이 두 가지를 이해한다면 이제 Redux-Saga는 뭔지 모르겠는데 엄청 대단해 보이는 것에서 엄청 대단한 건데 난 이해함ㅋ이 될거라 생각한다.","date":"2018.01.19","author":"이민규","tags":["Redux","React"],"thumbnail":"https://image.toast.com/aaaadh/alpha/2017/techblog/ReduxSagaLogoCompact_thumbnail.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20180119","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}