{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20200320","result":{"data":{"post":{"html":"<h1 id=\"새로운-마크다운-파서가-필요한-이유\" style=\"position:relative;\"><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%ED%8C%8C%EC%84%9C%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-label=\"새로운 마크다운 파서가 필요한 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>새로운 마크다운 파서가 필요한 이유</h1>\n<p>최근 개발자들이 가장 선호하는 문서 형식을 하나 꼽으라면 단연 마크다운일 것이다. 마크다운은 깃허브(GitHub), 깃랩(GitLab), Bitbucket등 업무나 이슈 관리를 지원하는 대부분의 서비스에서 기본 문서 형식으로 사용되고 있다. 또한 IntelliJ, VSCode, Vim, Emacs등 거의 모든 텍스트 편집 도구에서도 플러그인을 통해 마크다운 문서의 구문 강조나 미리보기 기능을 사용할 수 있다. </p>\n<p><a href=\"https://ui.toast.com/tui-editor/\">TOAST UI Editor</a>는 여기서 한 걸음 더 나아가 마크다운 에디터와 위지윅 에디터를 통합한 형태의 인터페이스를 제공한다. 위지윅 에디터를 사용하면 테이블 등의 복잡한 문법을 더 직관적이고 편리하게 편집할 수 있으며, 마크다운에 익숙하지 않은 사용자도 마크다운 기반의 문서를 손쉽게 편집할 수 있어 개발자와 비 개발자의 협업에 특히 유용하다. 이런 장점을 바탕으로 TOAST UI Editor의 사용자는 지난 몇 년간 꾸준히 증가했으며, 지난달에 깃허브 스타 10,000개라는 의미 있는 성과를 달성하기도 했다.</p>\n<p>TOAST UI Editor는 마크다운 에디터라는 정체성을 유지하면서 더 나은 사용자 경험을 제공하기 위해 계속해서 노력하고 있다. 최근에 릴리스한 <a href=\"https://ui.toast.com/weekly-pick/ko_20200318/\">2.0 버전</a>은 기존에 사용하던 마크다운 파서인 <a href=\"https://github.com/markdown-it/markdown-it\">markdown-it</a>을 제거하고 <a href=\"https://github.com/commonmark/commonmark.js/\">commonmark.js</a>를 기반으로 한 <a href=\"https://github.com/nhn/tui.editor/tree/master/libs/toastmark\">새로운 마크다운 파서</a>를 구현했는데, 이는 기존 버전이 갖고 있던 많은 문제점을 해결할 뿐만 아니라 앞으로의 더 큰 발전을 위한 초석이 될 중요한 변화이다.</p>\n<p>이 글에서는 TOAST UI Editor를 비롯한 기존 마크다운 에디터들이 가진 문제점과 한계를 짚어보고, 2.0에서 새롭게 구현한 마크다운 파서가 이러한 문제를 어떻게 해결할 수 있는지를 살펴볼 것이다. 또한 이 새로운 파서를 활용해서 마크다운 편집의 사용성을 얼마나 더 발전시킬 수 있는지도 함께 살펴보도록 하겠다.</p>\n<h2 id=\"마크다운-에디터의-기능과-문제점\" style=\"position:relative;\"><a href=\"#%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%97%90%EB%94%94%ED%84%B0%EC%9D%98-%EA%B8%B0%EB%8A%A5%EA%B3%BC-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"마크다운 에디터의 기능과 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마크다운 에디터의 기능과 문제점</h2>\n<p>TOAST UI Editor는 마크다운 에디터와 위지윅 에디터를 둘 다 지원하지만, 마크다운 에디터만으로도 다른 에디터에 못지않은 다양한 기능을 제공한다. 그중 구문 강조, 실시간 미리 보기, 도구 모음 버튼 등은 마크다운 에디터라면 필수적으로 갖춰야 할 기능이라 할 수 있다. 하지만 TOAST UI Editor뿐만 아니라 다른 에디터들도 기술적 어려움으로 인해 이 기능들을 완벽하게 구현하지는 못하고 있다. 이 단락에서는 각 기능에 대한 설명과 함께 문제점과 원인에 대해서도 자세히 알아보도록 하겠다.</p>\n<h3 id=\"구문-강조syntax-highlighting\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EB%AC%B8-%EA%B0%95%EC%A1%B0syntax-highlighting\" aria-label=\"구문 강조syntax highlighting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구문 강조(syntax highlighting)</h3>\n<p>마크다운 문서를 편집할 때 가장 먼저 필요한 것은 바로 구문 강조 기능이다. 개발자라면 당연히 알고 있겠지만, 구문 강조는 마크다운 문서를 분석하여 의미 있는 문법이 적용된 텍스트를 시각적으로 쉽게 구분할 수 있도록 스타일을 적용하는 것이다. 구문 강조를 지원하는 에디터에서는 실제 렌더링 된 화면을 보지 않아도 현재 작성하고 있는 문서에 마크다운 문법이 제대로 적용되었는지 확신할 수 있다. 반면 깃허브의 이슈 등록 폼과 같이 구문 강조를 지원하지 않는 환경에서는 글을 작성하면서 미리 보기를 자주 확인해야만 할 것이다.</p>\n<p>하지만 마크다운의 구문 강조를 완벽하게 지원하는 에디터는 거의 없다. 에디터마다 구문 강조를 위해 사용하는 모듈의 사용법이 달라서 기존에 존재하는 마크다운 파서를 사용할 수 없기 때문이다. 즉, 에디터마다 각자 다른 방법으로 구문 분석을 해야 하므로 실제 렌더링을 위해 사용하는 파서와 완벽하게 동일한 결과를 만들어 내기가 쉽지 않은 것이다.</p>\n<p>예를 들어 TOAST UI Editor는 HTML 변환을 위해 markdown-it을 사용하지만, 구문 강조를 위해서는 <a href=\"https://codemirror.net/\">CodeMirror</a>의 <a href=\"https://codemirror.net/mode/gfm/\">GFM 모드</a>를 사용하고 있다. CodeMirror의 모드 시스템은 구문 분석을 위한 <a href=\"https://codemirror.net/doc/manual.html#modeapi\">언어별 토크나이저(toeknizer)를 구현</a>해서 사용하는데, 완벽한 파서가 아니기 때문에 markdown-it이 분석한 결과만큼 정확하지 않다. 결국 아래의 그림에서 볼 수 있듯이 구문 강조와 미리 보기가 다르게 표시되는 경우를 자주 볼 수 있다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/77053972-7b5efe00-6a12-11ea-8ccc-c849cfb870a8.png\" alt=\"Syntax Highlighting in TOAST UI Editor\"></p>\n<p><a href=\"https://code.visualstudio.com/\">VSCode</a>의 <a href=\"https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one\">마크다운 플러그인</a>도 마찬가지로 HTML 변환을 위해 markdown-it을 사용하고 있는데, 구문 분석을 위해서는 다른 에디터에서 많이 사용되는 <a href=\"https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide#textmate-grammars\">TextMate 문법</a> 형식을 사용한다. 아래 그림을 보면 CodeMirror와는 또 다른 문제점이 발생하는 것을 볼 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/77053986-7e59ee80-6a12-11ea-8404-0da6ea395182.png\" alt=\"Syntax Highlighting in VSCode\"></p>\n<p>구문 강조의 또다른 문제는 성능이다. 에디터에서 텍스트를 변경할 때마다 매번 전체 문서를 다시 분석해서 구문 강조를 갱신해야 하므로 문서의 크기가 클수록 편집 속도가 느려지게 된다. CodeMirror의 모드 시스템은 이런 현상을 방지하기 위해 내부적으로 최적화를 하고 있어서 큰 문제가 없다. 하지만 VSCode와 같이 TextMate 문법 형식을 사용하는 에디터에서 큰 용량의 마크다운 문서를 편집하면 구문 강조로 인해 속도가 현저하게 느려지는 현상을 볼 수 있을 것이다.</p>\n<h3 id=\"실시간-미리-보기preview\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%AF%B8%EB%A6%AC-%EB%B3%B4%EA%B8%B0preview\" aria-label=\"실시간 미리 보기preview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실시간 미리 보기(Preview)</h3>\n<p>구문 강조만으로도 많은 도움이 되긴 하지만, 마크다운 문서가 변환된 결과를 완벽하게 예측할 수 있는 건 아니다. 특히 이미지나 테이블 같은 요소들은 눈으로 보지 않고서는 화면에 렌더링 될 결과를 정확하게 예측하기가 힘들다. 미리 보기는 글을 저장하기 전에 실제 렌더링 된 화면을 미리 확인할 수 있어 불필요한 시행착오를 줄여준다. 특히 TOAST UI Editor는 화면을 반으로 분할해서 에디터와 미리 보기 화면을 동시에 보여주기 때문에 편집과 동시에 렌더링될 결과를 확인할 수 있다. GitHub에서 이슈를 등록할 때 미리 보기 탭과 편집 탭을 전환하면서 긴 내용의 마크다운 문서를 작성해 본 사람이라면 이 기능이 얼마나 유용한지 잘 알 것이다. </p>\n<p>하지만 실시간 미리 보기도 구문 강조와 마찬가지로 성능 문제에서 벗어날 수 없다. 에디터의 텍스트가 수정될 때마다 매번 전체 문서를 변환해서 HTML을 생성해야 하므로 문서의 크기가 커질수록 편집 속도를 느리게 만든다. 또한 이미지와 같은 외부 리소스를 매번 다시 렌더링하기 때문에 깜빡이는 현상이 생길 수 있다. 특히 플러그인 등을 통해 문법을 확장해서 스크립트를 실행하는 경우에는 해당 스크립트가 매번 실행되게 만들어 문서 편집을 방해할 수 있다.</p>\n<p>TOAST UI Editor에서는 이를 해결하기 위해 이미 디바운스(debounce) 기법을 사용해서 일정 시간 이상 변경이 없을 때만 렌더링을 갱신하고 있는데, 이는 미리 보기의 반응 속도를 늦추어 사용성을 떨어뜨린다. 또한 변경과 관계 없는 부분까지 매번 렌더링하거나 스크립트가 재실행되는 문제는 여전히 해결하지 못한다. 아래 이미지는 TOAST UI Editor에서 미리 보기가 지연되어 갱신되는 현상과 차트 플러그인의 애니메이션이 매번 다시 실행되는 현상을 보여준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/77053993-7ef28500-6a12-11ea-939b-a99cf71b7130.gif\" alt=\"Preview Rerendering Issue\"></p>\n<p>또 다른 해결책으로는 기존 DOM 트리와 새롭게 렌더링 된 DOM 트리를 비교하여 변경된 부분만 갱신하도록 방법이 있지만, 이 방법은 DOM 트리 비교를 위한 추가 연산이 필요하므로 또 다른 성능 문제를 만들어낼 수도 있다. </p>\n<h3 id=\"도구-모음toolbar을-통한-문서-구조-변경\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EA%B5%AC-%EB%AA%A8%EC%9D%8Ctoolbar%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%AC%B8%EC%84%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%EA%B2%BD\" aria-label=\"도구 모음toolbar을 통한 문서 구조 변경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도구 모음(Toolbar)을 통한 문서 구조 변경</h3>\n<p>마크다운은 문서를 작성하기 위한 마크업 언어이기 때문에 프로그래밍 언어와는 다르게 텍스트의 일정 영역을 선택해서 스타일을 변경하는 등의 작업을 많이 하게 된다. 그래서 TOAST UI Editor와 같은 몇몇 마크다운 에디터에서는 볼드, 이탤릭, 목록 등의 스타일을 변환하거나 링크, 이미지, 테이블 등의 요소를 입력할 때 버튼 형식으로 쉽게 사용할 수 있도록 도구 모음을 제공한다. 하지만 마크다운 에디터에서 도구 모음을 구현하는 일은 다음의 두 가지 기능을 만족해야 해서 상당히 까다롭다.</p>\n<p>먼저, 에디터의 커서 위치와 선택 영역의 범위에 따라 버튼의 상태를 동기화하는 기능이 필요하다. 예를 들면, 커서가 목록 안에 있을 때는 목록 버튼이 활성화되고, 볼드 처리된 텍스트를 선택하면 \"볼드\" 버튼이 활성화되는 식인데, 구글 독스나 MS의 워드 등을 사용해본 적이 있다면 아마 익숙한 기능일 것이다. </p>\n<p>하지만 특정 위치의 텍스트에 실제 어떤 문법이 적용되었는지를 알아내는 것은 쉬운 일이 아니다. 이를 위해서는 결국 별도의 구문 분석 작업이 필요한데, 마크다운 문법의 특성상 단순히 커서가 위치한 줄만 분석해서는 안 되고, 문맥을 알아내기 위해 주변 줄까지 모두 분석해야 하기 때문이다. CodeMirror의 모드 시스템을 사용하면 구문 강조를 위해 분석했던 정보를 얻을 수 있긴 하지만, 앞서 언급했듯이 구문 강조를 위해 사용되는 분석기는 완벽하지 않기 때문에 얻을 수 있는 정보 또한 제한적이다. </p>\n<p>다음은 버튼을 클릭했을 때 커서의 위치에 원하는 요소를 입력하거나 선택된 영역에 적용된 스타일을 변경하는 기능이다. 사실 커서 위치에 이미지나 링크 등의 문법을 입력하는 것은 별로 어려운 일이 아니다. 하지만 여러 줄에 걸친 텍스트 영역의 스타일을 변경하는 것은 상당히 까다로운데, 이때도 버튼 상태를 동기화할 때와 마찬가지로 구문 분석이 필요하기 때문이다. </p>\n<p>예를 들어 목록 내의 특정 항목에 커서가 위치했을 때 \"순서 있는 목록(Ordered List)\" 버튼을 누르면, 이 목록 전체를 순서 있는 목록으로 변경하기 위해 커서 주변의 모든 줄을 순회하면서 같은 목록 내에 있는 모든 항목인지를 확인하고, 시작 기호(<code class=\"tui-language-text\">-</code> 혹은 <code class=\"tui-language-text\">*</code>)를 찾아서 숫자와 점으로 변경해야만 한다. TOAST UI Editor에는 이런 목록 처리를 위한 모듈이 별도로 존재하는데, 많은 양의 코드를 포함하고 있음에도 불구하고 아래 그림처럼 목록의 항목이 여러 줄에 걸쳐 있는 경우에는 제대로 처리하지 못하고 있다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/77054001-8023b200-6a12-11ea-858e-fca718fcc15c.gif\" alt=\"Toolbar Button Inconistency\"></p>\n<h2 id=\"통합-개발-환경ide에서-배울-수-있는-것들\" style=\"position:relative;\"><a href=\"#%ED%86%B5%ED%95%A9-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BDide%EC%97%90%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B2%83%EB%93%A4\" aria-label=\"통합 개발 환경ide에서 배울 수 있는 것들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통합 개발 환경(IDE)에서 배울 수 있는 것들</h2>\n<p>여기까지 읽었다면, 기존 마크다운 에디터의 문제점이 무엇인지 어느 정도 감이 올 것이다. 바로 마크다운 파서의 파편화이다. 즉, 구문 강조, HTML 변환, 도구 모음 등 모든 기능에서 구문 분석이 필요한데도 불구하고 각 모듈이 별도의 구문 분석을 하는 것이다. 당연한 이야기지만, 하나의 파서가 이 모든 것을 처리해 준다면 훨씬 더 정확하고 통일된 사용성을 보장할 수 있을뿐더러 기능 구현 로직도 단순해질 것이다. 그렇다면 왜 이런 낭비를 하고 있는 걸까? </p>\n<p>그 이유는 대부분의 마크다운 파서가 주로 마크다운 문법을 HTML로 변환하기 위한 목적으로만 만들어졌기 때문이다. 구문을 강조하거나 문서 구조를 변경하기 위해서는 소스 코드와 분석된 구문 트리 사이의 맵핑 정보가 필요한데, markdown-it과 같이 현재 널리 사용되는 마크다운 파서들은 이런 기능을 제공하지 않는다. 또한, 전체 마크다운 문서를 한 번에 변환하는 용도로 만들어졌기 때문에, 에디터처럼 실시간으로 내용을 변경해야 하는 상황에서는 만족스러운 성능을 보장해주지 못한다.</p>\n<p>그렇다면 이 문제를 해결할 방법은 없을까? 답은 가까운 곳에서 찾을 수 있다. 바로 개발자들이 사용하는 통합 개발 환경(IDE)이다. </p>\n<p>사실 마크다운 에디터의 문제는 개발자들이 사용하는 텍스트 에디터 혹은 통합 개발 환경(IDE)에서 똑같이 겪는 문제이다. 예를 들어 VSCode, SublimeText, Eclipse 등의 많은 에디터는 구문 분석을 위해 정규식 기반의 TextMate 문법 형식을 사용하는데, 앞서 설명했듯이 이는 구문의 의미를 완벽하게 분석하지 못하기 때문에 키워드의 색을 구분하는 수준에 머물러 있다. 게다가 자동 완성, 리팩토링, 정의 바로 가기(Go To Definition) 등을 처리하기 위해서는 또 다른 분석기가 필요한데, 이 또한 각 <a href=\"https://www.jetbrains.org/intellij/sdk/docs/reference_guide/custom_language_support.html\">에디터가 지원하는 언어와 API에 맞게 별도로 구현</a>해야 하므로 에디터에 따라 언어별 지원 수준이 각기 다른 상황이다.</p>\n<p>개발 환경에 관심이 많은 사람은 이미 알겠지만, 최근 이런 문제의 해결책으로 주목받는 기술 두 가지가 있다. 바로 <a href=\"https://tree-sitter.github.io/tree-sitter/\">트리시터</a>(Tree-Sitter)와 <a href=\"https://docs.microsoft.com/en-us/visualstudio/extensibility/language-server-protocol?view=vs-2017\">언어 서버 프로토콜</a>(Language Server Protocol: 이하 LSP)이다. </p>\n<h3 id=\"트리시터tree-sitter\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%A6%AC%EC%8B%9C%ED%84%B0tree-sitter\" aria-label=\"트리시터tree sitter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트리시터(Tree-Sitter)</h3>\n<p>트리시터는 정규식 기반 구문 분석의 한계를 벗어나 실제 전체 문서의 의미를 분석해서 구문 트리(Syntax Tree)를 만들어내는 시스템으로, <a href=\"https://atom.io/\">Atom</a> 에디터 내부 모듈로 시작해서 지금은 많은 에디터 환경에서 사용되고 있다. 트리시터 기반의 파서는 실시간 편집이 가능한 에디터 환경에서 사용하려는 목적으로 만들어졌기 때문에 일반적인 파서와는 다른 두 가지 특징을 갖는다. 하나는 소스 코드와의 1:1 맵핑 정보를 가진 <a href=\"https://en.wikipedia.org/wiki/Parse_tree\">구상 구문 트리(Concrete Syntax Tree)</a>를 만들어 낸다는 점이고, 또 하나는 점진적 분석(Incremental Parsing)을 지원한다는 점이다.</p>\n<p>구상 구문 트리는 <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">추상 구문 트리(Abstract Syntax Tree)</a>와는 다르게 소스 코드에서 생략되는 부분이 없이 모든 구문의 정보를 갖고 있다. 트리시터의 구문 트리는 여기에 더해서 구문마다 매칭되는 소스 코드의 시작 위치와 끝 위치를 저장하고 있기 때문에, 소스 코드의 특정 영역이 문법적으로 어떤 의미가 있는지를 정확하게 알 수 있다. Atom 에디터 블로그의 <a href=\"https://github.blog/2018-10-31-atoms-new-parsing-system/\">트리시터 소개 글</a>에서 이 정보를 어떻게 활용하고 있는지를 잘 보여주는데, 구문 강조 기능뿐만 아니라 코드 폴딩(folding), 문법에 따른 자동 영역 선택(Syntax-aware selection) 등의 기능도 완벽하게 개선된 것을 확인할 수 있을 것이다.</p>\n<p>점진적 분석은 전체 문서를 매번 분석하는 대신 변경된 부분만 분석해서 구문 트리를 갱신하는 기능이다. 즉 기존에 만들었던 구문 트리를 저장하고 있다가, 변경된 텍스트 정보를 받아서 필요한 부분만 다시 분석한 후 기존 트리를 일부만 업데이트하는 것이다. 이 기능은 에디터와 같이 계속해서 변경되는 문서를 실시간으로 분석해야 하는 용도에 최적화된 가장 큰 장점이라 볼 수 있다. 이 장점 덕분에 트리시터는 용량이 큰 소스 코드를 편집할 때도 성능 저하 없이 구문 트리 정보를 갱신할 수 있다.</p>\n<p>(<em>CodeMirror도 최근 메이저 업데이트인 CodeMirror 6을 준비하면서 동일한 고민을 했고, 트리시터에서 영감을 받은 새로운 파서인 <a href=\"https://lezer.codemirror.net/\">Lezer</a>를 만들었다. <a href=\"https://marijnhaverbeke.nl/blog/lezer.html\">개발자의 블로그 글</a>에 고민의 과정과 결과가 상세하게 정리되어 있으니 관심 있는 분들은 꼭 읽어보길 권한다.</em>)</p>\n<h3 id=\"언어-서버-프로토콜-lsp\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%96%B4-%EC%84%9C%EB%B2%84-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-lsp\" aria-label=\"언어 서버 프로토콜 lsp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언어 서버 프로토콜 (LSP)</h3>\n<p>LSP는 IDE 환경에서 자동 완성, 리팩토링 등의 기능을 지원하는 데 필요한 언어 서버의 스펙을 정의한 규약이다. LSP는 기존 IDE의 접근 방식과 다르게 클라이언트(에디터)에 독립적으로 사용 가능한 언어 서버를 만들어서 프로세스 간(inter-process) 통신을 하는 방식을 사용한다. 즉, 규약에 맞는 언어 서버를 구현하기만 하면 어떤 에디터에서든 동일한 IDE 기능을 사용할 수 있는 것이다. 마이크로소프트에서 처음 만들어 비주얼 스튜디오 코드 등의 에디터에서 사용하기 시작한 LSP는 현재 IntelliJ, Emacs, Vim 등 다양한 에디터에서 사용되고 있다. </p>\n<p>사실 웹에서 사용될 마크다운 에디터를 만들 때 클라이언트에 독립적인 구조나 프로세스 간 통신 등의 개념이 중요한 것은 아니다. 그보다 중요한 것은 언어 서버라는 개념인데, 아마 가장 친숙한 예로 타입스크립트의 <a href=\"https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29\">ts-server</a>를 들 수 있을 것이다. </p>\n<p>타입스크립트는 크게 tsc와 ts-server로 구성된다. tsc는 한 번에 전체 파일을 컴파일하는 용도로 주로 웹팩 등의 도구와 연결해서 번들링을 할 때 사용한다. 반면 ts-server는 에디터 내부에서 실행되어 텍스트가 변경될 때마다 실시간으로 구문 분석 결과를 갱신하며, 필요에 따라 자동 완성, 타입 에러 등의 결과를 반환한다. VSCode, IntelliJ 등의 에디터에서 타입스크립트 개발 도구에 감탄해 본 사람들은 모두 ts-server의 도움을 받고 있는 것이다.</p>\n<p><em>(참고로 ts-server는 아직 LSP를 지원하지 않으며, 대신 LSP용 <a href=\"https://github.com/theia-ide/typescript-language-server\">랩퍼 라이브러리</a>를 사용할 수 있다)</em></p>\n<p>언어 서버에서 또 하나 주목할 것은 리팩토링 기능이다. 타입스크립트를 개발할 때 \"함수 이름 변경\" 등의 리팩토링 기능을 사용한 적이 있을 것이다. 이는 언어 서버가 단순히 소스 코드를 분석해서 정보를 반환하는 역할을 넘어서서 직접 소스 코드를 수정하는 역할까지 수행한다는 의미이다. 즉, 내부에서 구문 분석 트리의 구조를 변경하고 변경된 구조에 맞게 소스 코드를 갱신한 후 변경된 내용을 반환하는 것이다. LSP에는 이를 위해서 <a href=\"https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction\">CodeAction 요청</a>이 정의되어 있는데, 이 기능은 앞서 \"도구 모음을 사용한 문서 구조 변경\"에서 살펴본 문제를 해결할 때 좋은 참고가 될 수 있다.</p>\n<p>사실 언어 서버는 트리시터가 하는 대부분의 일을 수행할 수 있으며, 실제로 LSP에는 구문 강조를 위한 API도 정의되어 있다. 하지만 언어 서버는 트리시터보다 훨씬 복잡한 기능을 수행하며 점진적 분석을 지원하기도 어렵기 때문에, 실시간으로 구문 강조나 코드 폴딩 등의 작업을 수행하기에는 비교적 무겁고 느리다. 즉, 트리시터와 LSP는 구현 방식과 용도가 다르므로 상호 보완적인 역할을 한다고 볼 수 있다.</p>\n<h2 id=\"새로운-마크다운-파서-toastmark\" style=\"position:relative;\"><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%ED%8C%8C%EC%84%9C-toastmark\" aria-label=\"새로운 마크다운 파서 toastmark permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>새로운 마크다운 파서: ToastMark</h2>\n<p>앞서 살펴본 내용을 모두 종합한 결과 우리는 트리시터와 언어 서버의 장점을 모두 갖춘 새로운 마크다운 파서가 기존 에디터의 문제를 해결해 줄 수 있다고 결론지었다. 하지만 새로운 마크다운 파서를 만드는 일은 어마어마한 노력이 드는 작업이기에 이미 잘 만들어진 오픈소스를 개선하기로 했고 며칠간의 분석과 논의를 거쳐 <a href=\"https://github.com/commonmark/commonmark.js/\">commonmark.js</a>가 최종 선택되었다. </p>\n<p>commonmark.js는 <a href=\"https://spec.commonmark.org/\">CommonMark 명세</a>의 레퍼런스 구현체로서, CommonMark 명세를 완벽하게 준수하는 유일한 자바스크립트 라이브러리이다. 레퍼런스 구현체이기 때문에 코드를 분석하고 확장하기가 쉬우며, 이후에 CommonMark 명세가 변경될 때에도 변경 사항을 비교해서 적용하기가 가장 용이하다고 판단했다.</p>\n<p>한 달여 간의 개선 작업 끝에 마침내 새로운 마크다운 파서인 <a href=\"https://github.com/nhn/tui.editor/tree/master/libs/toastmark\">ToastMark</a>가 탄생했다. ToastMark는 다음과 같은 세 가지의 특징을 갖는다.</p>\n<h3 id=\"1-소스-맵핑-정보를-갖는-추상-구문-트리ast-생성\" style=\"position:relative;\"><a href=\"#1-%EC%86%8C%EC%8A%A4-%EB%A7%B5%ED%95%91-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B0%96%EB%8A%94-%EC%B6%94%EC%83%81-%EA%B5%AC%EB%AC%B8-%ED%8A%B8%EB%A6%ACast-%EC%83%9D%EC%84%B1\" aria-label=\"1 소스 맵핑 정보를 갖는 추상 구문 트리ast 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 소스 맵핑 정보를 갖는 추상 구문 트리(AST) 생성</h3>\n<p>ToastMark는 마크다운 문서의 추상 구문 트리(Abstract Syntax Tree)를 만들고, 각 노드에 매칭되는 소스 코드 시작 위치와 끝 위치를 저장한다. 저장된 소스 코드의 위치 정보는 구문 강조, 도구 모음 버튼 동기화, 실시간 미리 보기의 스크롤 동기화 등 다양한 용도로 사용된다. 트리시터와 다르게 추상 구문 트리를 선택한 이유는 이 파서가 구문 강조 외에도 다양한 용도로 사용되기 때문이다. 구문 강조를 위해서는 구상 구문 트리가 더 유리하지만, 문서의 특정 요소를 탐색하거나 문서 구조를 변경할 때에는 추상 구문 트리가 훨씬 유리하다. 또한 마크다운은 각 요소를 구성하는 토큰의 형식이 단순해서 추상 구문 트리에 몇 가지 정보를 추가하는 것만으로도 구문 강조를 문제없이 구현할 수 있다.</p>\n<p>commonmark.js는 이미 추상 구문 트리 정보를 반환하는 API가 있고 블록 요소에 대한 소스 코드 위치 정보도 이미 갖고 있었기 때문에, 인라인 요소에 대한 소스 코드 위치 정보를 추가하는 것만으로 어렵지 않게 구현할 수 있었다. </p>\n<h3 id=\"2-문서-변경에-따른-점진적-분석\" style=\"position:relative;\"><a href=\"#2-%EB%AC%B8%EC%84%9C-%EB%B3%80%EA%B2%BD%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%A0%90%EC%A7%84%EC%A0%81-%EB%B6%84%EC%84%9D\" aria-label=\"2 문서 변경에 따른 점진적 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 문서 변경에 따른 점진적 분석</h3>\n<p>ToastMark는 트리시터와 같은 점진적 분석을 지원한다. 즉, 기존에 분석한 구문 트리를 저장하고 있다가 변경된 내용에 따라 구문 트리를 일부만 변경하는 것이다. 에디터에서 변경된 사항이 생기면 ToastMark에 변경 소스 코드의 위치와 텍스트 정보를 전달하고, ToastMark는 구문 트리를 일부 갱신한 다음 변경된 노드의 정보를 반환한다. 사용법을 간단하게 살펴보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> toastMark <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ToastMark</span><span class=\"token punctuation\">(</span><span class=\"token string\">'# Hello World'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 첫 문자인 #를 -로 변경</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> toastMark<span class=\"token punctuation\">.</span><span class=\"token function\">editMarkdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> removedNodeRange<span class=\"token punctuation\">,</span> newNodes <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 마크다운 에디터 구문 강조 갱신</span>\n<span class=\"token function\">refreshSyntaxHighlighting</span><span class=\"token punctuation\">(</span>newNodes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 미리보기 DOM 갱신</span>\n<span class=\"token function\">refreshPreview</span><span class=\"token punctuation\">(</span>removedNodeRange<span class=\"token punctuation\">,</span> newNodes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>변경된 노드의 정보는 구문 강조의 스타일과 실시간 미리 보기의 DOM 노드를 갱신하는 데 사용된다. 삭제된 노드의 아이디와 추가된 노드의 배열을 반환해 주기 때문에 구문 강조와 실시간 미리 보기에서도 정확히 변경된 부분만 갱신할 수 있다. 이 덕분에 큰 용량의 마크다운 문서를 편집할 때에도 성능 저하 없이 구문 강조와 미리 보기를 실시간으로 갱신하여 사용성을 크게 개선할 수 있다.</p>\n<h3 id=\"3-구문-트리-탐색-및-변경\" style=\"position:relative;\"><a href=\"#3-%EA%B5%AC%EB%AC%B8-%ED%8A%B8%EB%A6%AC-%ED%83%90%EC%83%89-%EB%B0%8F-%EB%B3%80%EA%B2%BD\" aria-label=\"3 구문 트리 탐색 및 변경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 구문 트리 탐색 및 변경</h3>\n<p>도구 모음 버튼의 상태를 동기화하기 위해서는 커서의 위치가 변경될 때마다 해당 위치의 소스 코드가 어떤 마크다운 요소와 매치되는지를 알아야 한다. 이를 위해서는 문서가 변경되지 않아도 위치에 따른 노드 정보를 알아낼 수 있어야 한다. 또한 미리 보기에 있는 DOM과 매치되는 노드의 정보를 가져오기 위해서는 각 노드에 아이디를 부여하고 해당 아이디를 통해서 노드를 가져올 수도 있어야 한다. 이러한 용도를 위해 ToastMark는 다음과 같은 몇 가지 메소드를 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// 3번째 줄의 1번째 노드 반환</span>\ntoastMark<span class=\"token punctuation\">.</span><span class=\"token function\">findFirstNodeAtLine</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">// 2번째 줄의 5번째 글자에 매치되는 노드 반환</span>\ntoastMark<span class=\"token punctuation\">.</span><span class=\"token function\">findNodeAtPosition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 아이디가 10인 노드 반환</span>\ntoastMark<span class=\"token punctuation\">.</span><span class=\"token function\">findNodeById</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>도구 모음의 버튼을 클릭했을 때는 문서의 구조를 변경해야 한다. 예를 들면 문단을 목록으로 변경하거나, 순서 없는 목록을 순서 있는 목록으로 변경하는 등의 작업이다. 이는 구문 트리를 변경한 후 및 실제 마크다운 소스 코드를 생성해서 반환하는 기능까지 포함한다. 현재는 초기 버전이라 아직 구현되어 있지 않지만, 이어지는 업데이트에서 이 기능을 위한 API도 추가될 예정이다.</p>\n<h2 id=\"toast-ui-editor-20에서-개선된-점\" style=\"position:relative;\"><a href=\"#toast-ui-editor-20%EC%97%90%EC%84%9C-%EA%B0%9C%EC%84%A0%EB%90%9C-%EC%A0%90\" aria-label=\"toast ui editor 20에서 개선된 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TOAST UI Editor 2.0에서 개선된 점</h2>\n<p>TOAST UI Editor 2.0은 마크다운 파서를 안정적으로 변경하고, 모듈 및 번들 구조를 변경하는 것에 초점을 맞추었기 때문에 특별하게 추가된 기능은 없다. 하지만 파서를 ToastMark로 변경한 것만으로도 기존 마크다운 에디터 기능들의 정확도와 안정성이 대폭 향상되었다.</p>\n<h3 id=\"구문-강조-정확도-개선\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EB%AC%B8-%EA%B0%95%EC%A1%B0-%EC%A0%95%ED%99%95%EB%8F%84-%EA%B0%9C%EC%84%A0\" aria-label=\"구문 강조 정확도 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구문 강조 정확도 개선</h3>\n<p>기존에 사용하던 CodeMirror의 마크다운 모드를 제거하고, CodeMirror API를 사용해 특정 구문에 직접 스타일을 추가하는 방식으로 변경되었다. 이제 미리 보기와 구문 강조 모두 ToastMark의 구문 트리에 의존하고 있으므로, 아래와 그림과 같이 두 결과가 완벽하게 동일한 것을 확인할 수 있을 것이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/77054006-81ed7580-6a12-11ea-94c8-5e39211b2725.png\" alt=\"Improved Syntax Highlighting in TOAST UI Editor\"></p>\n<h3 id=\"실시간-미리-보기-성능-및-스크롤-위치-동기화-개선\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%AF%B8%EB%A6%AC-%EB%B3%B4%EA%B8%B0-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%9C%84%EC%B9%98-%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B0%9C%EC%84%A0\" aria-label=\"실시간 미리 보기 성능 및 스크롤 위치 동기화 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실시간 미리 보기 성능 및 스크롤 위치 동기화 개선</h3>\n<p>앞서 언급했듯이 기존의 실시간 미리 보기는 전체 문서를 파싱하고 전체 DOM을 갱신하는 데 드는 비용 때문에 입력이 일정 시간 이상 멈추었을 때만 갱신되었고, 그때마다 차트 등의 확장 플러그인이 매번 새로 실행되는 문제도 있었다. 하지만 2.0 버전부터는 ToastMark의 점진적 분석 기능을 사용해서 변경된 내용만 분석하고 갱신하기 때문에, 불필요한 지연이나 플러그인 재실행이 없이 미리보기를 글자 그대로 \"<strong>실시간으로</strong>\" 확인할 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/77054010-81ed7580-6a12-11ea-869f-a34c275d4d54.gif\" alt=\"Improved Live Preview in TOAST UI Editor\"></p>\n<p>그뿐만 아니라 마크다운 에디터와 실시간 미리 보기의 스크롤 위치를 동기화하는 기능도 ToastMark의 정확한 맵핑 정보를 사용해서 더 정밀하게 동작하도록 개선되었다.</p>\n<h3 id=\"커서-위치에-따른-버튼-상태-동기화-개선\" style=\"position:relative;\"><a href=\"#%EC%BB%A4%EC%84%9C-%EC%9C%84%EC%B9%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EB%B2%84%ED%8A%BC-%EC%83%81%ED%83%9C-%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B0%9C%EC%84%A0\" aria-label=\"커서 위치에 따른 버튼 상태 동기화 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>커서 위치에 따른 버튼 상태 동기화 개선</h3>\n<p>도구 모음 버튼의 상태 동기화 문제는 예전부터 꾸준히 개선이 요구되는 이슈이다. 기존에도 볼드, 이탤릭, 취소선 등의 몇 가지 요소에 대해서는 동작하고 있었지만, 목록이나 테이블 등의 요소에 대해서는 제대로 동작하지 않았다. 비록 CodeMirror의 마크다운 모드에서 토크나이저가 분석한 정보를 사용할 수는 있었지만, 그 정보 자체가 완벽하지 않았기 때문에, 제대로 된 동기화를 위해서는 추가적인 분석이 필요했기 때문이다.</p>\n<p>하지만 ToastMark에서는 커서 위치에 따른 정확한 마크다운 노드 정보를 받을 수 있어, 약간의 코드만으로 기능이 대폭 개선되었다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/12269489/77054003-80bc4880-6a12-11ea-911e-a08335a9198f.gif\" alt=\"Improved Toolbar Button Status\"></p>\n<h2 id=\"2x에서-개선될-점\" style=\"position:relative;\"><a href=\"#2x%EC%97%90%EC%84%9C-%EA%B0%9C%EC%84%A0%EB%90%A0-%EC%A0%90\" aria-label=\"2x에서 개선될 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.X에서 개선될 점</h2>\n<p>이외에도 ToastMark를 사용해서 개선할 수 있는 기능은 많다. 사실 기존에도 구현할 수 없는 건 아니었지만 별도의 구문 분석 작업이 필요하다는 이유로 보류된 기능들이다. 이제 정확한 구문 분석 정보를 마음껏 사용할 수 있기 때문에 다양한 기능들을 어렵지 않게 구현할 수 있게 되었다. 그래서 2.0 이후의 마이너 업데이트에서는 ToastMark로 할 수 있는 다양한 시도를 하면서 마크다운 에디터와 미리 보기의 사용성을 개선하는 데에 집중할 예정이다.</p>\n<p>가장 먼저 할 일은 도구 모음 버튼의 사용성을 더 개선하는 일이다. 현재는 커서 위치와 버튼의 상태를 동기화하는 수준의 개선에서 그쳤지만, 더 나은 사용성을 위해서는 선택 영역에 따라서 버튼의 상태를 동기화하거나, 실행 불가능한 버튼의 상태를 비활성화하는 등의 개선이 더 필요하다. 또한 실제 버튼을 클릭했을 때도 커서뿐만 아니라 선택 영역의 상태를 고려해서 동작하도록 개선할 수 있으며, 기존에 추가로 구문을 분석하던 로직을 제거하고 코드를 단순화할 수도 있다.</p>\n<p>이 외에도 섹션별 코드 접기(folding), 코드 포매팅, 테이블 열/행 추가, 미리 보기의 변경된 영역 강조 등 다양한 기능을 추가할 수 있다. 이런 기능들은 아직 가능성으로만 남아있지만, 추후 사용성이나 우선순위를 고려해서 꾸준히 추가할 예정이다. 만약 제안할 만한 더 좋은 기능이 있다면 이슈로 남겨주기 바란다.</p>\n<h2 id=\"toastmark의-미래\" style=\"position:relative;\"><a href=\"#toastmark%EC%9D%98-%EB%AF%B8%EB%9E%98\" aria-label=\"toastmark의 미래 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ToastMark의 미래</h2>\n<p>ToastMark는 이제 막 첫발을 내디뎠기 때문에 아직 개선될 여지가 많이 남아 있다. 또한 TOAST UI Editor 내부에서만 사용되는 라이브러리이기 때문에 별도의 npm 패키지로 등록하지 않았으며, API도 에디터의 요구 사항에 따라 계속해서 변경될 예정이다. 즉, 아직 외부에서 사용할 용도로는 적합하지 않다는 의미이다. </p>\n<p>하지만 TOAST UI Editor의 발전과 함께 ToastMark도 계속해서 발전할 것이며, 충분한 안정성을 확보한 후에 외부에 정식으로 배포, 공개할 계획이다. <a href=\"https://github.com/nhn/tui.editor/tree/master/libs/toastmark\">깃허브 저장소</a>에 ToastMark의 특징과 몇 가지 API를 정리해 두었으니 관심 있는 개발자들은 꼭 살펴보길 바라며, 좋은 의견이 있다면 꼭 <a href=\"https://github.com/nhn/tui.editor/issues\">깃허브 이슈</a>로 남겨주길 바란다. </p>\n<h2 id=\"toast-ui-editor의-미래\" style=\"position:relative;\"><a href=\"#toast-ui-editor%EC%9D%98-%EB%AF%B8%EB%9E%98\" aria-label=\"toast ui editor의 미래 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TOAST UI Editor의 미래</h2>\n<p>지금까지 새로운 마크다운 파서인 ToastMark를 만들게 된 이유와 이를 사용해서 개선된 점들을 모두 살펴보았다. ToastMark는 마크다운 에디터 사용성을 개선하는 데 큰 도움을 주었으며, 앞으로도 다양한 개선을 이끌 잠재력을 갖고 있다. 하지만 ToastMark의 역할은 여기서 끝이 아니다. 사실 ToastMark는 마크다운 에디터와 위지윅 에디터를 진정으로 통합할 수 있는 길을 열어줄 중요한 출발점이다.</p>\n<p>현재 마크다운 에디터의 구조에서는 CodeMirror와 ToastMark가 각각 텍스트 정보를 관리하며 변경 정보를 서로 동기화하며 상호작용하고 있다. 여기서 한발 더 나아가면 ToastMark에서만 텍스트 정보를 관리하고, 에디터에서는 단순히 커서의 움직임과 이벤트 처리만 담당할 수도 있다. 마치 리덕스와 리액트의 관계처럼 ToastMark가 상태 관리자가 되고, 에디터는 단순히 뷰의 역할을 하게 되는 것이다. 그러면 CodeMirror의 의존성이 없이 더 가볍고 통일된 구조의 마크다운 에디터를 만들 수 있을 것이다. </p>\n<p>여기서 또 한발 더 나아가면, 위지윅 에디터에도 동일한 구조를 적용할 수 있다. 즉, ToastMark가 하나의 상태 관리자가 되고, 마크다운 에디터와 위지윅 에디터 모두 뷰의 역할만 담당하게 되는 것이다. 이게 가능하다면 현재 위지윅 에디터 구현을 위해 사용하는 <a href=\"https://github.com/neilj/Squire\">Squire</a>의 의존성도 제거할 수 있고, 결과적으로 더 가볍고 통일성 있는 위지윅 에디터를 만들 수 있다. </p>\n<p>예를 들어, 기존 구조에서는 위지윅 에디터가 HTML(DOM)을 편집하고, 마크다운 에디터는 마크다운 텍스트를 편집하기 때문에 에디터 간 전환이 일어날 때마다 전체 데이터를 마크다운→HTML, HTML→마크다운으로 변환하는 작업이 필요했고, 이 과정에서 기존 데이터가 의도치 않게 변경되는 문제가 자주 발생했다. 하지만 새로운 구조에서는 두 에디터가 ToastMark가 관리하는 AST 하나에 의존하기 때문에, 불필요한 데이터 변환 작업으로 인한 문제가 모두 사라지고 에디터 간 전환도 더 매끄러워진다.</p>\n<p>물론 현재 단계에서는 고려해야 할 기술적인 난관들이 많이 남아있기 때문에, 실제로 적용하기 전까지 많은 연구와 프로토타이핑이 필요하다. 더 자세한 이야기는 이후 다른 글에서 상세하게 다루도록 하겠다. 지금은 먼 미래보다는 새롭게 릴리즈된 2.0 버전에 많은 관심을 두길 바라며, 업데이트를 통해 꾸준히 개선되는 마크다운 에디터의 사용성을 지켜봐 주기 바란다.</p>\n<h2 id=\"참고-링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EB%A7%81%ED%81%AC\" aria-label=\"참고 링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 링크</h2>\n<h3 id=\"textmate-문법\" style=\"position:relative;\"><a href=\"#textmate-%EB%AC%B8%EB%B2%95\" aria-label=\"textmate 문법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TextMate 문법</h3>\n<ul>\n<li><a href=\"https://macromates.com/manual/en/language_grammars.html\">TextMate: 문법 파일 생성</a> </li>\n<li><a href=\"https://flight-manual.atom.io/hacking-atom/sections/creating-a-legacy-textmate-grammar/\">Atom: 구문 강조 가이드</a></li>\n<li><a href=\"https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide\">VSCode: 구문 강조 가이드</a></li>\n</ul>\n<h3 id=\"language-server-protocol\" style=\"position:relative;\"><a href=\"#language-server-protocol\" aria-label=\"language server protocol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Language Server Protocol</h3>\n<ul>\n<li><a href=\"https://microsoft.github.io/language-server-protocol/\">공식 페이지</a> </li>\n<li><a href=\"https://docs.microsoft.com/en-us/visualstudio/extensibility/language-server-protocol?view=vs-2017\">Visual Studio: LSP 소개</a></li>\n<li><a href=\"https://github.com/microsoft/vscode-languageserver-node/pull/367\">VSCode: LSP 구문 강조 지원 PR</a></li>\n</ul>\n<h3 id=\"트리시터tree-sitter-1\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%A6%AC%EC%8B%9C%ED%84%B0tree-sitter-1\" aria-label=\"트리시터tree sitter 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트리시터(Tree-Sitter)</h3>\n<ul>\n<li><a href=\"https://tree-sitter.github.io/tree-sitter/\">공식 페이지</a></li>\n<li><a href=\"https://flight-manual.atom.io/hacking-atom/sections/creating-a-grammar/\">Atom: 문법 파일 생성</a></li>\n<li><a href=\"https://github.blog/2018-10-31-atoms-new-parsing-system/\">Atom: 트리시터 소개</a></li>\n<li><a href=\"https://github.com/github/semantic/blob/master/docs/why-tree-sitter.md\">깃허브: 트리시터 사용</a></li>\n<li><a href=\"https://marijnhaverbeke.nl/blog/lezer.html\">Lezer: CodeMirror의 새로운 파싱 시스템</a></li>\n</ul>","frontmatter":{"id":"ko_20200320","title":"새로운 마크다운 파서가 필요한 이유","description":"최근 개발자들이 가장 선호하는 문서 형식을 하나 꼽으라면 단연 마크다운일 것이다. 마크다운은 깃허브(GitHub), 깃랩(GitLab), Bitbucket등 업무나 이슈 관리를 지원하는 대부분의 서비스에서 기본 문서 형식으로 사용되고 있다. 또한 IntelliJ, VSCode, Vim, Emacs등 거의 모든 텍스트 편집 도구에서도 플러그인을 통해 마크다운 문서의 구문 강조나 미리보기 기능을 사용할 수 있다.","date":"2020.03.20","author":"김동우","tags":["opensource"],"thumbnail":"https://user-images.githubusercontent.com/12269489/77146020-6004f900-6acd-11ea-959b-3900c00c2d8d.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20200320","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}