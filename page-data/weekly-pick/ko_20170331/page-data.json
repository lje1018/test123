{"componentChunkName":"component---src-templates-weekly-pick-post-tsx","path":"/weekly-pick/ko_20170331","result":{"data":{"post":{"html":"<h1 id=\"redux-분석하기\" style=\"position:relative;\"><a href=\"#redux-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0\" aria-label=\"redux 분석하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux 분석하기</h1>\n<p>Redux는 <a href=\"https://martinfowler.com/eaaDev/EventSourcing.html\">Event Sourcing</a>패턴과 <a href=\"https://en.wikipedia.org/wiki/Functional_programming\">Functional programming</a>을 결합하여 라이브러리 형태로 구현한 컨테이너다. 이 컨테이너는 애플리케이션의 상태를 저장하고, 쉽게 예측할 수 있도록 하여 일관된 구현을 유지할 수 있도록 하고, 테스트, 유지보수, 디버깅 등을 손쉽게 처리할 수 있도록 한다.</p>\n<p>Redux는 \"Flux의 구현체다/아니다\"로 많은 이야기가 있었지만, 결론적으로 말하면 Redux는 Flux의 영향을 받아 새로 구현한 컨테이너 라이브러리이며, \"Flux의 구현체다/아니다\"는 크게 중요하지 않다(엄밀하게 보면 Redux는 Flux가 아니다). 즉, Flux의 구조에 따라 Redux가 어떤식으로 구현되었다라는 것이 중요한게 아니라, \"Flux의 큰 특징들이 Redux에 잘 녹아있다.\"라는 것을 알아야 한다. 조금 더 자세한 내용은 Redux 문서의 <a href=\"http://redux.js.org/docs/introduction/PriorArt.html#flux\">Prior Art - flux</a>에서 잘 설명하고 있다.</p>\n<p>그리고 Redux는 React와 직접적인 관련이 없다. 단지 잘 어울릴 뿐이며, 잘 어울리도록 만든 라이브러리는 <a href=\"https://github.com/reactjs/react-redux\">react-redux</a>이다. 이 글은 redux의 구조를 다루고자 하며 Redux의 사용 예시나, React-Redux의 튜토리얼을 설명하지 않는다. 해당 내용은 <a href=\"http://redux.js.org/\">Redux 문서</a>와 Redux 개발자의 <a href=\"https://egghead.io/series/getting-started-with-redux\">동영상 강의</a>에서 잘 설명하고 있다.</p>\n<h2 id=\"3가지-원칙\" style=\"position:relative;\"><a href=\"#3%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99\" aria-label=\"3가지 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3가지 원칙</h2>\n<p>Redux의 3가지 기본 원칙을 보자. (<a href=\"http://redux.js.org/docs/introduction/ThreePrinciples.html\">Redux 3-principles</a>)</p>\n<ol>\n<li>Sinlge source of truth (SSOT)</li>\n<li>Read-only state</li>\n<li>Changes from pure functions</li>\n</ol>\n<p>이 원칙들을 통해 Redux가 관리하는 상태가 읽기 전용의 SSOT이며, 순수 함수를 통해 변화시킬 수 있다는 것을 알 수 있다.</p>\n<p>여기에서 의문이 하나 생길 수 있는데, 읽기 전용의 상태를 순수 함수로 변경을 시킨다는게 모순처럼 보일 수 있다는 것이다. 이는 사실 <a href=\"https://facebook.github.io/react/docs/rendering-elements.html\">React의 엘리먼트</a>와 유사한 형태로, 모든 변화에 새로운 상태를 만들고 이것으로 교체하는 것이다. <a href=\"https://github.com/reactjs/redux/blob/master/src/createStore.js\">Redux의 <code class=\"tui-language-text\">createStore</code> 코드</a>를 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">// Redux - v3.6.0</span>\n\n<span class=\"token comment\">// Reducer는 순수 함수이며 `(state, action) => state`의 형태로,</span>\n<span class=\"token comment\">// 상태 변화를 일으키려는 액션에 따라 참조가 다른 새로운 상태를 반환한다.</span>\ncurrentState <span class=\"token operator\">=</span> <span class=\"token function\">currentReducer</span><span class=\"token punctuation\">(</span>currentState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/24623100/4af29832-18e2-11e7-868d-1e42ea6dea16.png\" alt=\"redux-1\"></p>\n<h2 id=\"기본-개념\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\" aria-label=\"기본 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 개념</h2>\n<p>Redux의 구조를 분석하기 전에 다음 기본 개념들을 숙지해야 한다. 링크된 Redux 문서에서 자세한 내용을 확인하길 바란다.</p>\n<ol>\n<li><a href=\"http://redux.js.org/docs/basics/Actions.html\">액션(Action)</a>(<a href=\"http://dobbit.github.io/redux/basics/Actions.html\">ko</a>): 애플리케이션의 상태를 어떻게 변경시킬지 추상화한 표현이다. 단순 객체(Plain object)로 <code class=\"tui-language-text\">type</code> 프로퍼티를 꼭 가지고 있어야 한다.</li>\n<li><a href=\"http://redux.js.org/docs/basics/Reducers.html\">리듀서(Reducer)</a>(<a href=\"http://dobbit.github.io/redux/basics/Reducers.html\">ko</a>): 애플리케이션의 다음 상태를 반환하는 함수이다. 이전 상태와 액션을 받아 처리하고 다음 상태를 반환한다.</li>\n<li><a href=\"http://redux.js.org/docs/basics/Store.html\">스토어(Store)</a>(<a href=\"http://dobbit.github.io/redux/basics/Store.html\">ko</a>): 애플리케이션의 상태를 저장하고 읽을 수 있게 하며 액션을 보내거나 상태의 변화를 감지할 수 있도록 API를 제공하는 객체이다.</li>\n<li><a href=\"http://redux.js.org/docs/Glossary.html\">Redux 용어 사전</a>(<a href=\"http://dobbit.github.io/redux/Glossary.html%5D\">ko</a>): Redux에서 사용하는 용어 정의</li>\n</ol>\n<p>Redux는 애플리케이션의 상태 관리를 스토어라는 개념으로 추상화하고, 상태 트리를 내부적으로 관리한다. 애플리케이션은 변화를 표현하는 액션을 스토어에 전달하고 스토어는 리듀서를 통해 상태 트리를 형상화하여 변경한다. 그리고 스토어는 다시 애플리케이션에게 상태 트리의 변경을 알린다. 애플리케이션은 상태 트리의 변경을 인지하고 이에 따른 UI 변경이나 다른 서비스 로직을 수행한다.</p>\n<h2 id=\"스토어\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%86%A0%EC%96%B4\" aria-label=\"스토어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스토어</h2>\n<p>스토어는 내부적으로 리듀서와 애플리케이션 상태, 이벤트 리스너 그리고 현재 디스패칭(Dispatching) 여부를 나타내는 값(<code class=\"tui-language-text\">isDispatching: boolean</code>)을 관리한다. 외부적으로는 <code class=\"tui-language-text\">dispatch</code>, <code class=\"tui-language-text\">subscribe</code>, <code class=\"tui-language-text\">getState</code>, <code class=\"tui-language-text\">replaceReducer</code> <a href=\"http://redux.js.org/docs/api/Store.html\">API</a>를 노출한다.</p>\n<p>Redux는 다음과 같은 단방향 데이터 흐름을 가지고 있다. (참고: <a href=\"http://redux.js.org/docs/basics/DataFlow.html\">Redux 데이터 흐름</a>(<a href=\"http://dobbit.github.io/redux/basics/DataFlow.html\">ko</a>))</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/24623103/4d891508-18e2-11e7-93cc-0c412df75dca.png\" alt=\"redux-2\"></p>\n<p>다음은 스토어(<code class=\"tui-language-text\">createStore</code>)의 간단한 구현을 표현한다. 단방향 데이터 흐름을 이해하고 보면 아래 구현은 크게 어렵지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token comment\">/**\n * createStore API 내부\n *   (root)리듀서와 초기 상태를 인자로 받는다.\n **/</span>\n\n<span class=\"token comment\">// 모듈 패턴 - private 변수</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span><span class=\"token punctuation\">)</span> currentState<span class=\"token operator\">:</span> Object<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span><span class=\"token punctuation\">)</span> currentReducer<span class=\"token operator\">:</span> Function <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> state<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span><span class=\"token punctuation\">)</span> listeners<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span>Function<span class=\"token operator\">></span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span><span class=\"token punctuation\">)</span> isDispatching<span class=\"token operator\">:</span> Boolean\n\n<span class=\"token comment\">// API:</span>\n<span class=\"token comment\">//   현재 상태를 반환</span>\n<span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> currentState<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// API:</span>\n<span class=\"token comment\">//  Change listener를 등록</span>\n<span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">listener</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  listeners<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> index <span class=\"token operator\">=</span> listeners<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    listeners<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// API:</span>\n<span class=\"token comment\">//  액션을 받아 리듀서로 처리한다. 다음 3가지의 동작으로 분리해볼 수 있다.</span>\n<span class=\"token comment\">//    1. 전처리: Action의 유효성, 현재 Dispatching 여부</span>\n<span class=\"token comment\">//    2. 리듀서: currentReducer에서 반환하는 다음 상태를 적용</span>\n<span class=\"token comment\">//    3. 이벤트: 등록된 리스너들을 순서대로 수행</span>\n<span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isPlainObject</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> Error\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> action<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> Error\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isDispatching<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> Error\n\n  <span class=\"token comment\">// isDispatching은 리듀서에서 다시 dispatch를 호출하는 경우를 막기위해 사용한다.</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    isDispatching <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    currentState <span class=\"token operator\">=</span> <span class=\"token function\">currentReducer</span><span class=\"token punctuation\">(</span>currentState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    isDispatching <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// `slice`는 리스너에서 subscribe와 unsubscribe API를 사용하는 경우,</span>\n  <span class=\"token comment\">// 현재 리스너 수행에 영향을 주지 않기 위함이다.</span>\n  <span class=\"token comment\">//</span>\n  <span class=\"token comment\">// 하지만 `slice` 비용은 비싸기 때문에 실제 구현은 조금 다르며, 동작 자체는 같다.</span>\n  listeners<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">listener</span> <span class=\"token operator\">=></span> <span class=\"token function\">listener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> action<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// API:</span>\n<span class=\"token comment\">//   코드 분리(Code splitting), 핫-리로딩(hot reloading) 등의 기법이나,</span>\n<span class=\"token comment\">//   리듀서 자체를 동적으로 사용할 때 필요할 수 있다.</span>\n<span class=\"token function\">replaceReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  currentReducer <span class=\"token operator\">=</span> reducer<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>type<span class=\"token operator\">:</span> <span class=\"token constant\">INIT</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 상태 초기화 코드 수행</span>\n<span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>type<span class=\"token operator\">:</span> <span class=\"token constant\">INIT</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// API 반환</span>\n<span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n  getState<span class=\"token punctuation\">,</span>\n  subscribe<span class=\"token punctuation\">,</span>\n  dispatch<span class=\"token punctuation\">,</span>\n  replaceReducer\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>스토어는 <code class=\"tui-language-text\">nextListeners</code>와 <code class=\"tui-language-text\">currentListeners</code>로 리스너 목록의 변경에 대한 상태를 분리해서 <code class=\"tui-language-text\">slice</code>에 대한 비용을 줄였다. <a href=\"https://github.com/reactjs/redux/commit/c031c0a8d900e0e95a4915ecc0f96c6fe2d6e92b\">구현 코드(commit)</a>를 통해 확인해 볼 수 있다.</p>\n<p>Redux의 스토어는 결국 이 <code class=\"tui-language-text\">createStore</code> 함수를 기반으로 동작하기 때문에 <a href=\"https://en.wikipedia.org/wiki/Higher-order_function\">고차 함수(High order function)</a>를 적용할 수 있다(Redux에서는 enhancer라 부른다). 그래서 아래와 같은 적용이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">enhancer</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">createStore</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//.. enhance logics</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">createStore</span><span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">,</span> enhancer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> createStoreEnhanced <span class=\"token operator\">=</span> <span class=\"token function\">enhancer</span><span class=\"token punctuation\">(</span>createStore<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> enhancedStore <span class=\"token operator\">=</span> <span class=\"token function\">createStoreEnhanced</span><span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 또는 아래처럼 enhancer를 인자로 사용할 수도 있다.</span>\n\n<span class=\"token keyword\">const</span> enhancedStore <span class=\"token operator\">=</span> <span class=\"token function\">createStore</span><span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">,</span> enhancer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그리고 Redux는 기본적으로 <code class=\"tui-language-text\">applyMiddleware</code>라는 enhancer를 제공한다. 다음 미들웨어를 알아보자.</p>\n<h2 id=\"미들웨어\" style=\"position:relative;\"><a href=\"#%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4\" aria-label=\"미들웨어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>미들웨어</h2>\n<p>Redux의 <a href=\"http://redux.js.org/docs/advanced/Middleware.html\">미들웨어</a>는 dispatching 과정에서 액션이 리듀서에 도달하기 전 애플리케이션의 로직이 끼어들 수 있는 틈을 만들어준다.</p>\n<h3 id=\"compose\" style=\"position:relative;\"><a href=\"#compose\" aria-label=\"compose permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>compose</h3>\n<p>미들웨어를 분석하기 위해서 먼저 <a href=\"https://en.wikipedia.org/wiki/Function_composition_(computer_science)\">함수 중첩(<code class=\"tui-language-text\">compose</code>)</a>을 이해해야 한다. Redux는 이 <code class=\"tui-language-text\">compose</code>를 메인 API로 노출하고 있지만 Redux와는 독립적인 유틸성에 가까운 함수로 앞서 설명한 고차 함수를 구현할 수 있도록 도와준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">f, g, h라는 함수가 있고, f와 g는 앞선 함수의 반환 값을 인자로 받도록 정의되어 있을 때,\n아래와 같은 형태를 생각해볼 수 있다.\n\n   x = h(...args)\n   y = g(x) = g(h(...args))\n   z = f(y) = f(g(x)) = f(g(h(...args)))\n\n최종적으로 (...args)를 가지고 f, g, h를 적절히 조합하여 z 결과값을 얻어야 할때,\nf(y)를 쉽게 표현하기 위해 compose라는 함수를 사용한다.\n\ncompose(f, g, h) = (...args) =&gt; f(g(h(...args)))</code></pre></div>\n<h3 id=\"원리\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EB%A6%AC\" aria-label=\"원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원리</h3>\n<p>이제 미들웨어를 살펴보자. 미들웨어는 외부에서 생성된 액션이 리듀서에 도달하기전에 먼저 수신하여 시스템에 알맞게 특정 작업들을 미리 처리할 수 있도록 한다. 액션을 검증하거나 필터링, 모니터링, 외부 API와의 연동, 비동기 처리 등을 추가적으로 수행할 수 있도록 한다. 미들웨어가 없다면 이런 작업들을 모두 액션 생성자에서 처리하거나 dispatch를 <a href=\"https://en.wikipedia.org/wiki/Monkey_patch\">몽키패치</a>하여 처리해야하는데 이 경우 중복, 복잡도, 비 순수함수 등의 유지 보수가 어려운 많은 문제들이 발생한다. 미들웨어는 이런 문제들을 쉽게 풀어내면서 <strong>더 강력해진 dispatch 함수를 만든다.</strong></p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/24623107/5099f7c6-18e2-11e7-80ed-df7b4ded4e6b.png\" alt=\"redux-3\"></p>\n<p>Redux는 미들웨어의 개입이 없는 <a href=\"http://redux.js.org/docs/api/Store.html#dispatch\">기본 dispatch 함수</a>와 미들웨어로 인해 고차 함수가 된 <a href=\"http://redux.js.org/docs/Glossary.html#dispatching-function\">dispatching 함수</a>를 구분하고 있다. 이런 고차 함수는 앞서 살펴본 <code class=\"tui-language-text\">compose</code>를 활용해 구현한다. 앞으로는 이 글에서 <code class=\"tui-language-text\">baseDispatch</code>와 <code class=\"tui-language-text\">dispatch</code>를 구분하여 사용한다.</p>\n<p>미들웨어는 store API인 <code class=\"tui-language-text\">{getState, dispatch}</code>를 인자로 받는다. 그리고 <code class=\"tui-language-text\">next</code>라는 체이닝 함수를 전달받는 새로운 <code class=\"tui-language-text\">wrapDispatch</code> 함수를 반환한다. 즉, 미들웨어는 3개의 중첩된 함수를 구현하고 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">middleware</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>getState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">wrapDispatch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">dispatchToSomething</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// do something...</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>상당히 복잡해 보이지만 arrow-syntax를 사용하면 조금은 더 보기 편한 표현이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">middleware</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> getState<span class=\"token punctuation\">,</span> dispatch <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">next</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">action</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// do something...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/24623109/53c43664-18e2-11e7-8eee-a892f6b98f3b.png\" alt=\"redux-4\"></p>\n<p><code class=\"tui-language-text\">next</code> 함수는 현재 체이닝에서 처음으로 돌아가지 않고 계속 연결되는 disptach 과정을 수행하기 위해 필요하다. 스토어에 여러 미들웨어가 중첩되어 있을 때 바로 다음 미들웨어의 dispatching 함수에 진입하기 위해 필요한 함수이다. 주의할 점은 <code class=\"tui-language-text\">next</code>가 아닌 store API의 dispatch를 호출하면 액션이 다시 처음으로 돌아가는 상황이 발생한다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/24623115/562ccbdc-18e2-11e7-98e2-35b153ac8035.png\" alt=\"redux-5\"></p>\n<p>이제 <code class=\"tui-language-text\">applyMiddleware</code> API를 살펴보자. 참고로 <code class=\"tui-language-text\">applyMiddleware</code>는 <code class=\"tui-language-text\">createStore</code> 자체를 감싸는 고차 함수다. <code class=\"tui-language-text\">applyMiddleware</code>와 <code class=\"tui-language-text\">middleware</code>는 정확히 구분해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">applyMiddleware</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>middlewares</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// applyMiddleware는 기존 createStore의 고차 함수를 반환한다.</span>\n  <span class=\"token keyword\">return</span> <span class=\"token parameter\">createStore</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> preloadedState<span class=\"token punctuation\">,</span> enhancer</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token function\">createStore</span><span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">,</span> preloadedState<span class=\"token punctuation\">,</span> enhancer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> dispatch <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>dispatch<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> chain <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 미들웨어들에게 인자로 전달되는 객체이다.</span>\n    <span class=\"token comment\">// dispatch가 단순히 store.dispatch의 참조를 전단하는 것이 아니라,</span>\n    <span class=\"token comment\">// 함수를 한번 더 감싸 사용하는 점을 기억하자.</span>\n    <span class=\"token keyword\">const</span> middlewareAPI <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      getState<span class=\"token operator\">:</span> store<span class=\"token punctuation\">.</span>getState<span class=\"token punctuation\">,</span>\n      <span class=\"token function-variable function\">dispatch</span><span class=\"token operator\">:</span> <span class=\"token parameter\">action</span> <span class=\"token operator\">=></span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 미들웨어들이 반환하는 체인 함수들(= wrapDispatch)을 가져온다.</span>\n    chain <span class=\"token operator\">=</span> middlewares<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">middleware</span> <span class=\"token operator\">=></span> <span class=\"token function\">middleware</span><span class=\"token punctuation\">(</span>middlewareAPI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 미들웨어가 반환하는 체인 함수들을 중첩시킨 후 새로운 dispatch 함수를 만든다.</span>\n    dispatch <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>chain<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>dispatch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// applyMiddleware를 통해 반환된 createStore 고차 함수는</span>\n    <span class=\"token comment\">//  기존 스토어와 동일한 API, 그리고 새로 만들어진 dispatch 함수를 반환한다.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>store<span class=\"token punctuation\">,</span>\n      dispatch\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>흥미로운 점이 하나 있는데 바로 <code class=\"tui-language-text\">middlewareAPI</code> 부분이다. <code class=\"tui-language-text\">dispatch</code>함수를 한번 더 감싸고 있다. 그냥 단순히 아래와 같이 표현하면 무엇이 문제일지 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> dispatch <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>dispatch<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> middlewareAPI <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  getState<span class=\"token operator\">:</span> store<span class=\"token punctuation\">.</span>getState<span class=\"token punctuation\">,</span>\n  dispatch\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같이 구현된다면 미들웨어에서 항상 <code class=\"tui-language-text\">baseDispatch</code>만을 바라보게 된다. 하지만 비동기 액션/미들웨어의 경우 <a href=\"http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators\">액션이 다시 처음 미들웨어 체인으로 돌아가야할 필요</a>가 있다. 즉 <code class=\"tui-language-text\">next(action)</code>이 아닌 <code class=\"tui-language-text\">store.dispatch(action)</code>이 필요한 경우가 있다는 것이다. 이런 경우에는 클로저 변수로 전체 미들웨어가 연결된(= <code class=\"tui-language-text\">dispatch = compose(...chain)(store.dispatch)</code>) <code class=\"tui-language-text\">dispatch</code>를 참조하고 있어야한다. 아직 헷갈린다면 아래 코드의 차이를 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">foo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">foo</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function-variable function\">foo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"new foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\na<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// foo</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// new foo</span></code></pre></div>\n<p>미들웨어의 간단한 사용 예시로 <a href=\"https://github.com/gaearon/redux-thunk\">redux-thunk</a> 라이브러리를 참고해보자. 액션이 일반 객체(plain object)가 아닌 함수인 경우 그 함수를 실행해줌으로서 비동기 로직이나 외부 API연동과 같은 동작을 가능하게 한다.</p>\n<h2 id=\"리듀서\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%93%80%EC%84%9C\" aria-label=\"리듀서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리듀서</h2>\n<p>Redux라는 이름은 Reducer + Flux 이다. 그런만큼 Redux에서는 리듀서가 핵심 개념이고 우리는 이 리듀서에 대해 자세히 알아야 한다.</p>\n<p>지금까지 액션이 dispatch되고 미들웨어를 통과하는 과정까지 모두 파악하였다. 외부에서 들어온 액션은 스토어의 상태(state)와 함께 리듀서에 전달되고 스토어는 리듀서로부터 새로운 상태를 받는다. 그래서 리듀서는 이전 상태와 액션을 받아 새로운 상태를 반환하는 순수함수로 정의한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">reducer: (previousState, action) =&gt; newState</code></pre></div>\n<h3 id=\"의미\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EB%AF%B8\" aria-label=\"의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의미</h3>\n<p>어느 애플리케이션이 되었든 단일 리듀서를 가지고 구성하기란 매우 어렵다. 애플리케이션의 상태는 수십 수백가지의 값을 갖는데 이 모든 상태를 전부 하나의 리듀서로 관리하기는 거의 불가능한 것이다. 만약 단일 리듀서로 애플리케이션을 설계할 수 있다면 처음부터 리듀서라고 부르지 않았을 것이다. 리듀서는 기본적으로 단위 상태에 대한 단위 리듀서들의 조합을 구성할 수 있다. 애플리케이션 개발자는 작은 단위의 리듀서들을 정의하고 마지막에 <code class=\"tui-language-text\">combineReducers</code> API 를 통해 각 리듀서들을 조합하여 하나의 큰 루트 리듀서를 만들 수 있다.</p>\n<p><code class=\"tui-language-text\">combineReducers</code>를 간단히 나타내면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">combineReducers</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducers</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>reducers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result<span class=\"token punctuation\">,</span> key</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> reducer <span class=\"token operator\">=</span> reducers<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> prevState <span class=\"token operator\">=</span> state<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      result<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>prevState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nreducers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token operator\">:</span> aReducer<span class=\"token punctuation\">,</span>\n  b<span class=\"token operator\">:</span> bReducer<span class=\"token punctuation\">,</span>\n  c<span class=\"token operator\">:</span> cReducer\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> combinedReducer <span class=\"token operator\">=</span> <span class=\"token function\">combinReducers</span><span class=\"token punctuation\">(</span>reducers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\n\n조합된 최종 리듀서(combinedReducer)는 다음과 같다.\n\nfunction(state, action) {\n  return {\n    a: aReducer(state.a, action),\n    b: bReducer(state.b, action),\n    c: cReducer(state.c, action)\n  }\n}\n\ncombinedReducer를 호출하면 aReducer, bReducer, cReducer가 모두 호출되고 새로운 객체를 반환한다.\n\n*/</span></code></pre></div>\n<p>각 리듀서가 combineReducer에서 <code class=\"tui-language-text\">Array.prototype.reduce</code> API에 전달되는 형태처럼 사용되기 때문에 리듀서라고 부른다. 사실 실제 구현 코드는 <code class=\"tui-language-text\">reduce</code>를 직접 사용하지 않지만 개념적으로도 역시 여러 분산된 상태를 하나의 상태로 감소시킨다는 의미와 부합한다.</p>\n<p>코드를 보면 알겠지만, <code class=\"tui-language-text\">combineReducer</code>는 기본적으로 1dpeth의 상태를 가지고 처리한다. 하지만 <code class=\"tui-language-text\">combineReudcer</code>를 재귀적으로 조합하면 n-depth의 상태를 구현할 수 있다. 때문에 애플리케이션 개발자는 애플리케이션의 상태가 깊어도 각각 단위 상태만을 처리하는 단위 리듀서를 작성하고 이들을 조합하여 전체 루트 리듀서를 만들어 애플리케이션의 전체 상태를 관리할 수 있는 것이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12269563/24623118/5855e416-18e2-11e7-8b49-c13af520da7e.png\" alt=\"redux-6\"></p>\n<h3 id=\"액션에-따른-상태-변화-여부\" style=\"position:relative;\"><a href=\"#%EC%95%A1%EC%85%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94-%EC%97%AC%EB%B6%80\" aria-label=\"액션에 따른 상태 변화 여부 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>액션에 따른 상태 변화 여부</h3>\n<p>앞서 간단히 구현한 <code class=\"tui-language-text\">combinedReducer</code> 상태의 변화 유무와 상관 없이 항상 새로운 객체를 반환한다. 만약 이벤트 리스너가 수행되고 실제 상태 변경이 없었다면 그것을 애플리케이션 개발자는 어떻게 알 수 있을까? 각 프로퍼티별로 하나씩 깊은 비교를 할 수 밖에 없다. 따라서 리듀서는 변화가 없는 경우에는 항상 참조가 같은 기존 상태를 반환해야 하고 이는 <code class=\"tui-language-text\">combineReducer</code> API역시 마찬가지다. 다음은 실제 구현된 코드의 일부이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> hasChanged <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> nextState <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> finalReducerKeys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> finalReducerKeys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> reducer <span class=\"token operator\">=</span> finalReducers<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> previousStateForKey <span class=\"token operator\">=</span> state<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextStateForKey <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>previousStateForKey<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  nextState<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nextStateForKey<span class=\"token punctuation\">;</span>\n  hasChanged <span class=\"token operator\">=</span> hasChanged <span class=\"token operator\">||</span> nextStateForKey <span class=\"token operator\">!==</span> previousStateForKey<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> hasChanged <span class=\"token operator\">?</span> nextState <span class=\"token operator\">:</span> state<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"tui-language-text\">combineReducer</code>에서 반환하는 리듀서 역시 상태의 모든 프로퍼티에 대해 <code class=\"tui-language-text\">hasChanged = hasChanged || nextStateForKey !== previousStateForKey</code> 구문을 수행하고, 마지막에 <code class=\"tui-language-text\">hasChanged</code> 여부에 따라 새로운 상태 또는 기존 상태 반환 여부를 결정한다. 애플리케이션 개발자역시 단위 리듀서에서 상태 변화가 있는 경우에만 새로운 참조를 가진 객체를 반환을 하고 그렇지 않은 경우는 이전 상태를 그대로 반환하는 규칙을 지켜주어야 한다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>Redux는 정말 간단한 라이브러리면서도 매우 중요한 개념을 포함하며, 기술적으로도 세련된 기법들을 사용하고 있다. 이번에 Redux를 분석하며 단방향 데이터 흐름, Event-Sourcing 패턴, 함수 중첩, 리듀서 등을 어떤식으로 활용하고 어떻게 조합하였는지, 배울점이 정말 많았다. 특히 리듀서를 순수 함수로 구현하면서 이들을 조합해 하나의 상태 트리를 구성하는 것은, 어느 누군가는 한번쯤 해볼만한 생각이긴 하지만 과연 이렇게 깔끔하게 구현할 수 있었을까 하는 의문이 들 정도였다.</p>\n<p>만약 시간에 여유가 있다면 Redux의 코드를 한번 읽어보길 추천한다. 2kb도 정도의 짧은 코드이고, TC도 67개 정도로 정말 작으면서도 탄탄하고 많은 것을 내포한 라이브러리이다.</p>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"http://redux.js.org/\">Redux 문서</a></li>\n<li><a href=\"https://github.com/reactjs/redux\">Redux Github</a></li>\n</ul>","frontmatter":{"id":"ko_20170331","title":"Redux 분석하기","description":"Redux는 Event Sourcing패턴과 Functional programming을 결합하여 라이브러리 형태로 구현한 컨테이너다. 이 컨테이너는 애플리케이션의 상태를 저장하고, 쉽게 예측할 수 있도록 하여 일관된 구현을 유지할 수 있도록 하고, 테스트, 유지보수, 디버깅 등을 손쉽게 처리할 수 있도록 한다.","date":"2017.03.31","author":"이민규","tags":["Redux","React"],"thumbnail":"https://cloud.githubusercontent.com/assets/12269563/24623100/4af29832-18e2-11e7-868d-1e42ea6dea16.png"}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_20170331","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}