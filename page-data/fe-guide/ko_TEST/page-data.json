{"componentChunkName":"component---src-templates-fe-guide-detail-tsx","path":"/fe-guide/ko_TEST","result":{"data":{"post":{"html":"<h1 id=\"테스트\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트</h1>\n<p>자바스크립트는 최근 몇 년간 비약적인 발전을 통해 사용 범위를 넓혀오고 있으며, 프론트엔드 환경에서 요구하는 애플리케이션의 수준도 나날이 복잡해지고 있다. 이와 더불어 자바스크립트의 테스트 환경도 짧은 기간 동안 많은 변화를 겪었는데, 특히 <a href=\"https://nodejs.org/en/\">Node.js</a>의 등장 이후 무수히 많은 도구가 쏟아져 나오며 빠른 속도로 발전해오고 있다. </p>\n<p>프론트엔드 코드는 사용자에 따라 다양한 환경(브라우저, 기기, 운영체제 등)에서 실행되기 때문에 테스트할 때 많은 변수들을 고려해야 한다. 이 때문에 자바스크립트는 테스트를 위한 환경과 테스트 도구들을 얼마나 잘 이해하고 있는지가 중요한 요소이며, 프로젝트의 성격에 맞게 테스트의 범위나 테스트 대상을 결정하는 등의 전략을 세울 때에도 많은 노하우가 필요하다.</p>\n<p>이 문서에서는 프론트엔드 자바스크립트 테스트에 사용되는 다양한 도구들과 사용법을 소개하고, 프로젝트 상황에 맞는 최적의 도구를 선택할 수 있도록 가이드를 제시한다.</p>\n<p><em>(프로젝트 상황에 맞는 테스트 전략을 세우고 효율적인 테스트 코드를 작성하는 방법에 대해서는 별도의 가이드에서 상세하게 다룰 예정이다.)</em></p>\n<h2 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h2>\n<ul>\n<li>\n<p><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%9D%98%EB%AF%B8%EC%99%80-%EC%A2%85%EB%A5%98\">테스트의 의미와 종류</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%9E%80\">테스트란?</a></li>\n<li><a href=\"#%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8\">단위 테스트</a></li>\n<li><a href=\"#%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8\">통합 테스트</a></li>\n<li><a href=\"#e2e-%ED%85%8C%EC%8A%A4%ED%8A%B8\">E2E 테스트</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC\">자바스크립트 테스트 도구</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%9F%AC%EB%84%88\">테스트 러너</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\">테스트 프레임워크</a></li>\n<li><a href=\"#%EB%8B%A8%EC%96%B8assertion-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\">단언(Assertion) 라이브러리</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94-test-double-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\">테스트 더블 (Test Double) 라이브러리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%ED%99%98%EA%B2%BD\">테스트 실행 환경</a></p>\n<ul>\n<li><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80\">브라우저</a></li>\n<li><a href=\"#nodejs\">Node.js</a></li>\n<li><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-vs-nodejs\">브라우저 vs Node.js</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#jasmine\">Jasmine</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AA%85%EC%84%B8-%EC%9E%91%EC%84%B1\">테스트 명세 작성</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AA%85%EC%84%B8-%EA%B7%B8%EB%A3%B9%ED%99%94\">테스트 명세 그룹화</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B4%88%EA%B8%B0%ED%99%94\">테스트 초기화</a></li>\n<li><a href=\"#%EC%8A%A4%ED%8C%8C%EC%9D%B4spy\">스파이(spy)</a></li>\n<li><a href=\"#%ED%83%80%EC%9D%B4%EB%A8%B8-%EC%A0%9C%EC%96%B4\">타이머 제어</a></li>\n<li><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%85%8C%EC%8A%A4%ED%8A%B8\">비동기 테스트</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#karma-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%9F%AC%EB%84%88\">Karma 테스트 러너</a></p>\n<ul>\n<li><a href=\"#%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%A4%ED%96%89\">설치 및 실행</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%B8%A1%EC%A0%95\">테스트 커버리지 측정</a></li>\n<li><a href=\"#%ED%81%AC%EB%A1%9C%EC%8A%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95-%ED%85%8C%EC%8A%A4%ED%8A%B8\">크로스 브라우징 테스트</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#jest\">Jest</a></p>\n<ul>\n<li><a href=\"#%EC%89%AC%EC%9A%B4-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%A4%ED%96%89\">쉬운 설치 및 실행</a></li>\n<li><a href=\"#%EC%89%AC%EC%9A%B4-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%B8%A1%EC%A0%95\">쉬운 커버리지 측정</a></li>\n<li><a href=\"#jsdom-%EB%82%B4%EC%9E%A5\">jsdom 내장</a></li>\n<li><a href=\"#%EC%8A%A4%EB%83%85%EC%83%B7-%ED%85%8C%EC%8A%A4%ED%8A%B8\">스냅샷 테스트</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%ED%95%84%ED%84%B0%EB%A7%81\">테스트 파일 필터링</a></li>\n<li><a href=\"#%EC%83%8C%EB%93%9C%EB%B0%95%EC%8A%A4-%EB%B3%91%EB%A0%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8\">샌드박스 병렬 테스트</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#e2e-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC\">E2E 테스트 도구</a></p>\n<ul>\n<li><a href=\"#selenium-webdriver\">Selenium Webdriver</a></li>\n<li><a href=\"#cypress\">Cypress</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#cypress-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%A4%ED%96%89\">Cypress 설치 및 실행</a></p>\n<ul>\n<li><a href=\"#%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%84%A4%EC%A0%95\">설치 및 설정</a></li>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%EB%9E%99%ED%8B%B0%EB%B8%8C-%EB%AA%A8%EB%93%9C-%EC%8B%A4%ED%96%89\">인터랙티브 모드 실행</a></li>\n<li><a href=\"#%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89\">백그라운드 실행</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#cypress-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1\">Cypress 테스트 코드 작성</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%8B%A4%ED%96%89\">테스트 파일 생성 및 실행</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\">테스트 코드 작성하기</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%A7%BA%EC%9D%8C%EB%A7%90\">맺음말</a></li>\n</ul>\n<h2 id=\"테스트의-의미와-종류\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%9D%98%EB%AF%B8%EC%99%80-%EC%A2%85%EB%A5%98\" aria-label=\"테스트의 의미와 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트의 의미와 종류</h2>\n<h3 id=\"테스트란\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%9E%80\" aria-label=\"테스트란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트란?</h3>\n<p>테스트라는 용어는 범용적으로 사용되기 때문에 분야에 따라 다양한 의미를 갖는다. 테스트를 소프트웨어의 관점에서 정의하자면 \"애플리케이션이 요구 사항에 맞게 동작하는지를 검증하는 행위\"라고 할 수 있다. 보통 개발과는 별도의 전문 영역으로 분류되며, 일정 규모 이상의 회사에서는 QA(Quality assuarance) 조직에 속한 전문 테스터들이 이 역할을 수행하는 것이 일반적이다.</p>\n<p>하지만 2000년대 이후 애자일 방법론이 널리 퍼지기 시작하고 <a href=\"https://en.wikipedia.org/wiki/Extreme_programming\">익스트림 프로그래밍(Extreme programming)</a> 등에서 강조하는 <a href=\"https://en.wikipedia.org/wiki/Test-driven_development\">테스트 주도 개발(Test Driven Development)</a> 등이 대중화되면서, 테스트는 점점 더 개발 단계의 일부로 받아들여지고 있다. 여기서 말하는 테스트란 주로 코드로 작성된 자동화 테스트를 말한다. 개발자가 테스트 코드를 직접 작성하게 되면 더 적극적으로 리팩토링 등의 코드 개선을 할 수 있어 코드 품질이 향상되며, 개발 단계에서의 제품 품질이 향상되어 테스터와의 불필요한 커뮤니케이션 비용이 감소하게 된다.</p>\n<p><em>(이 가이드에서는 테스트라는 용어를 \"개발자가 작성하는 자동화 테스트\"라는 의미로 사용하고 있으며, 이 범위를 벗어나는 내용은 다루지 않는다.)</em></p>\n<p>테스트에는 다양한 종류가 있으며, 개발자의 관점에서는 보통 범위에 따른 구분을 많이 사용한다. 범위에 따라서는 크게 단위 테스트, 통합 테스트, E2E(End to End) 테스트로 구분할 수 있다. 흔히 개발자가 작성하는 테스트는 모두 단위 테스트라고 생각하는 경우가 많은데, 각 테스트 방식마다 고유한 장단점이 있기 때문에 이들을 잘 구분해서 상황에 따라 적절한 방식을 선택하는 것이 중요하다. 이를 위해 각각의 테스트 방식에 대해 좀 더 자세히 살펴보겠다.</p>\n<h3 id=\"단위-테스트\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"단위 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단위 테스트</h3>\n<p>단위 테스트는 작은 단위(주로 모듈 단위)를 전체 애플리케이션에서 떼어 내어 분리된 환경에서 테스트하는 것을 말한다. 분리된 상태의 테스트이기 때문에 하나의 모듈이나 클래스에 대해 세밀한 부분까지 테스트할 수 있고 더 넓은 범위에서 테스트할 때보다 훨씬 빠르게 실행할 수 있다. 하지만 단위 테스트는 의존성이 있는 모듈을 제어하기 위해 필연적으로 모의 객체(Mocking)을 사용할 수밖에 없으며, 이 경우 각 모듈이 실제로 잘 연결되어 상호 작용하는지에 대해서는 검증하지 못한다. 또한 각 모듈의 사소한 API 변경에도 영향을 받기 때문에 작은 단위의 리팩토링에도 쉽게 깨지는 문제가 있다. </p>\n<h3 id=\"통합-테스트\" style=\"position:relative;\"><a href=\"#%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"통합 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통합 테스트</h3>\n<p>통합 테스트는 단위 테스트보다 좀 더 넓은 범위의 테스트를 말하며 보통 두 개 이상의 모듈이 실제로 연결된 상태를 테스트한다. 여러 개의 모듈이 동시에 상호 작용하는 것을 테스트하기 때문에 단위 테스트에 비해 모의 객체의 사용이 적으며, 모듈 간의 연결에서 발생하는 에러를 검증할 수 있다. 또한 비교적 넓은 범위에서의 API 변경에만 영향을 받기 때문에 단위 테스트와 비교해 리팩토링을 할 때 쉽게 깨지지 않는 장점이 있다. 하지만 단일 모듈이 복잡한 알고리즘이나 분기문을 갖고 있을 때 단위 테스트에 비해 테스트가 번거롭고, 테스트 중복이 발생할 확률이 높다는 단점이 있다. </p>\n<h3 id=\"e2e-테스트\" style=\"position:relative;\"><a href=\"#e2e-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"e2e 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>E2E 테스트</h3>\n<p>단위 테스트나 통합 테스트는 모두 내부 구조를 알고 있는 개발자의 관점에서 제품 일부분만을 선별해서 테스트하는 방식이다. E2E 테스트는 이와 다르게 실제 사용자의 관점에서 테스트를 진행하며, 그런 의미에서 기능(Functional) 테스트 혹은 UI(User Interface) 테스트라고 불리기도 한다. E2E 테스트는 사용자의 실행 환경과 거의 동일한 환경에서 테스트를 진행하기 때문에 실제 상황에서 발생할 수 있는 에러를 사전에 발견할 수 있다는 장점이 있다. 특히 브라우저를 외부에서 직접 제어할 수 있어 자바스크립트의 API만으로는 제어할 수 없는 행위(브라우저 크기 변경, 실제 키보드 입력 등)를 테스트할 수도 있다. 또한 테스트 코드가 실제 코드 내부 구조에 영향을 받지 않기 때문에 큰 범위의 리팩토링에도 깨지지 않으며, 이를 통해 개발자들이 좀 더 자신감 있게 코드를 개선할 수 있도록 도와준다.</p>\n<p>반면 단위 테스트나 통합 테스트에 비해 테스트의 실행 속도가 느리기 때문에 개발 단계에서 빠른 피드백을 받기가 어려우며, 세부 모듈들이 갖는 다양한 상황들의 조합을 고려해야 하기 때문에 테스트를 작성하기가 쉽지 않다는 단점이 있다. 또한 큰 단위의 기능을 작은 기능으로 나누어 테스트할 수가 없기 때문에 필연적으로 테스트 사이에 중복이 발생할 수밖에 없다. 게다가 통제된 샌드박스 환경에서의 테스트가 아니기 때문에 테스트 실행 환경의 예상하지 못한 문제들(네트워크 오류, 프로세스 대기로 인한 타임아웃 등)로 인해 테스트가 가끔 실패하는 일이 발생하며, 이 때문에 테스트를 100% 신뢰할 수 없는 문제가 발생하기도 한다.</p>\n<h2 id=\"자바스크립트-테스트-도구\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC\" aria-label=\"자바스크립트 테스트 도구 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트 테스트 도구</h2>\n<p><em>(이 장에서는 주로 단위/통합 테스트의 관점에서 테스트 도구들을 설명한다. E2E 테스트 도구의 경우 테스트를 바라보는 관점이 달라 이 장에서 다루는 분류와는 맞지 않는 경우도 있기 때문에 별도의 장에서 다루도록 하겠다.)</em></p>\n<p>최근의 자바스크립트 테스트 도구들은 테스트를 위한 다양한 기능을 통합하여 제공하고 있으며, 각 도구가 지원하는 기능도 각기 다르다. 이들을 제대로 비교하고 선택하기 위해선 먼저 자바스크립트 테스트를 위해 어떤 기능들이 필요한지를 아는 것이 도움이 된다. 이들을 분류하는 정확한 기준은 없지만, 기본적으로는 테스트를 구동할 수 있는 환경을 제공하는 <strong>테스트 러너</strong>와 테스트 코드 작성을 위한 기반을 만들어주는 <strong>테스트 프레임워크</strong>로 나눌 수 있다. 이 외에도 테스트 코드를 좀 더 편리하게 작성할 수 있도록 도와주는 <strong>단언(assertion) 라이브러리</strong>, <strong>테스트 더블 라이브러리</strong> 등을 사용하기도 한다.</p>\n<h3 id=\"테스트-러너\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%9F%AC%EB%84%88\" aria-label=\"테스트 러너 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 러너</h3>\n<p>테스트 러너는 테스트 파일을 읽어들여 작성한 코드를 실행하고, 그 결과를 특정한 형식으로 출력해준다. 테스트의 수행 결과는 리포터(Reporter)를 지정해서 원하는 형태로 출력할 수 있다. 부가적으로 테스트 코드나 소스 코드가 변경된 경우 영향을 받는 테스트를 자동으로 재실행해주는 왓쳐(Watcher) 등의 기능도 제공한다. </p>\n<p>이전에는 자바스크립트를 실행할 수 있는 환경이 브라우저에 한정되어 있었기 때문에, 작성된 테스트 코드를 직접 브라우저에서 실행한 후 웹페이지나 브라우저 콘솔을 통해서만 결과를 확인할 수 있었다. 하지만 Node.js의 등장으로 브라우저 없이도 자바스크립트 코드를 손쉽게 실행할 수 있게 되었으며, 덕분에 테스트 러너와 같은 도구를 사용해 이러한 과정을 자동화할 수 있게 되었다.</p>\n<p>테스트 러너는 크게 <a href=\"https://karma-runner.github.io/3.0/index.html\">Karma</a>와 같이 브라우저에서 직접 코드를 실행하는 러너와, <a href=\"https://jestjs.io/\">Jest</a>와 같이 Node.js 환경에서 코드를 실행하는 러너로 나눌 수 있다. 이 중 Node.js 기반의 테스트 러너들은 굳이 러너의 실행 환경과 코드의 실행 환경을 구분할 필요가 없기 때문에 대부분 테스트 프레임워크와 통합된 형태로 제공된다.</p>\n<h3 id=\"테스트-프레임워크\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-label=\"테스트 프레임워크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 프레임워크</h3>\n<p>사용자가 테스트 코드를 작성할 수 있는 기반을 제공해주는 자바스크립트 도구이다. 프레임워크가 제공하는 함수들을 사용해서 테스트 코드를 작성하면, 프레임워크가 테스트 코드를 자동으로 실행한 후 성공 및 실패에 대한 결과를 반환해준다. 대표적인 테스트 프레임워크로는 <a href=\"https://mochajs.org/\">Mocha</a>, <a href=\"https://jasmine.github.io/\">Jasmine</a>, <a href=\"https://github.com/avajs/ava\">AVA</a> 등이 있으며, 최근에는 <a href=\"https://jestjs.io/\">Jest</a>가 빠른 속도로 점유율을 높여가고 있다. </p>\n<p>아래는 Jasmine으로 작성된 테스트 코드의 예이다. <code class=\"tui-language-text\">describe</code>, <code class=\"tui-language-text\">beforeEach</code>, <code class=\"tui-language-text\">it</code>, <code class=\"tui-language-text\">expect</code> 등의 함수는 모두 Jasmine이 제공하는 전역 함수이며, 좀 더 상세한 내용은 이 글의 후반부에서 설명하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'calculations'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">beforeEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    b <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sum two number'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBe</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'multiply two number'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">*</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBe</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"단언assertion-라이브러리\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%96%B8assertion-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\" aria-label=\"단언assertion 라이브러리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단언(assertion) 라이브러리</h3>\n<p>테스트 코드는 주로 테스트를 위한 초기화와 단언으로 이루어지며, 단언은 개별 테스트가 통과하기 위한 조건을 명확하게 기술하기 위해 사용된다. 보통은 테스트 프레임워크에서 다양한 방식의 단언 API를 기본 제공하고 있으며, Mocha의 경우에만 <a href=\"https://www.chaijs.com/\">Chai</a>와 같은 별도의 단언 라이브러리를 사용하도록 권장하고 있다. </p>\n<p>초기의 단언 라이브러리들은 <a href=\"https://junit.org/junit5/\">JUnit</a>과 유사한 방식의 API를 많이 따랐지만, 최근에 가장 많이 사용되는 Chai, Jasmine 등에서는 좀 더 자연어에 가까운 <a href=\"https://en.wikipedia.org/wiki/Behavior-driven_development\">BDD(Behavior-driven development</a> 방식의 API가 사용된다. 또한 대부분의 단언 라이브러리들은 사용자들이 필요에 따라 자신만의 단언을 추가해서 사용할 수 있는 플러그인 확장 기능을 제공한다.</p>\n<p>아래 예제는 Jasmine으로 작성된 테스트 코드이다. <code class=\"tui-language-text\">expect()</code> 와 함께 <code class=\"tui-language-text\">toBeNull()</code>, <code class=\"tui-language-text\">toEqual()</code>, <code class=\"tui-language-text\">toHaveBeenCalled()</code> 등의 다양한 단언들이 사용되는 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>not<span class=\"token punctuation\">.</span><span class=\"token function\">toBeNull</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'Kim'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">30</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBe</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBeTruthy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>spy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"테스트-더블test-double-라이브러리\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94test-double-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\" aria-label=\"테스트 더블test double 라이브러리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 더블(test double) 라이브러리</h3>\n<p><a href=\"https://martinfowler.com/bliki/TestDouble.html\">테스트 더블</a>이란 실제 객체 대신 테스트를 위해 동작하는 객체를 말하며, 주로 분리된(isloated) 단위 테스트를 위해 외부 의존성을 임의로 주입하기 위해서 사용한다. 필요에 따라 스파이(spy), 스텁(stub), 목(mock) 등의 다양한 테스트 더블을 사용할 수 있으며, 이들을 쉽게 만들 수 있도록 도와주는 라이브러리를 테스트 더블 라이브러리라고 한다. 단언과 마찬가지로 테스트 더블을 위한 함수들도 테스트 프레임워크에서 기본 제공되는 경우가 대부분이며, Mocha의 경우에만 <a href=\"https://sinonjs.org/\">Sinon.JS</a> 등의 별도 라이브러리를 사용하도록 권장하고 있다. </p>\n<p>테스트 더블은 일반적으로 자바스크립트 객체 혹은 함수를 직접 변경하거나 생성하는 형태로 사용되며, Jest에서는 모듈 단위로 사용할 수 있는 기능도 제공한다. 또한 Jasmine의 <a href=\"https://jasmine.github.io/api/edge/Clock.html\">Clock</a>이나 Sinon.JS의 <a href=\"https://github.com/sinonjs/lolex\">Lolex</a>와 같은 도구를 사용하면 자바스크립트의 타이머 API도 직접 제어하며 테스트할 수 있다. 이 외에도 <a href=\"https://github.com/axios/axios\">Axios</a>와 같은 유명 라이브러리의 경우 <a href=\"https://github.com/ctimmerm/axios-mock-adapter\">별도로 구현된 Mock 라이브러리</a>를 쉽게 찾을 수 있는 경우가 많으므로, 먼저 해당 관련된 라이브러리가 있는지 검색해 보길 권장한다.</p>\n<p>다음은 Jasmine에서 제공하는 <code class=\"tui-language-text\">spyOn</code> 함수를 사용하여 테스트 더블을 만드는 예제이다. 스파이를 사용해 객체의 특정 메서드가 호출된 적이 있는지, 호출될 때 어떤 인자가 넘어왔는지를 검증하는 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'Kim'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test spy'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">spyOn</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> <span class=\"token string\">'setName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">spyOn</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> <span class=\"token string\">'getName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>and<span class=\"token punctuation\">.</span><span class=\"token function\">callThrough</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  person<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Lee'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>setName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalledWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Lee'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>getName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Kim'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"테스트-실행-환경\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%ED%99%98%EA%B2%BD\" aria-label=\"테스트 실행 환경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 실행 환경</h2>\n<p>테스트 러너 항목에서 언급했듯이, 자바스크립트의 테스트는 브라우저 환경과 Node.js 환경 모두에서 실행할 수 있다. 하지만 두 환경 모두 뚜렷한 장단점이 있기 때문에 상황에 맞게 적절한 테스트 러너를 선택해야 한다. 이 단락에서는 두 환경의 장단점을 알아보고, 각 실행 환경에서 권장하는 테스트 방식을 간략하게 설명하겠다.</p>\n<h3 id=\"브라우저\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80\" aria-label=\"브라우저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저</h3>\n<p>실제 브라우저를 실행해서 테스트 코드를 실행하는 방식을 의미하며, E2E 테스트 도구들을 제외한다면 현재로서는 Karma를 사용하는 것이 유일한 방법이라 할 수 있다. Karma는 테스트 러너의 역할만 하기 때문에 별도의 테스트 프레임워크가 추가로 필요하며, 보통 <a href=\"https://jasmine.github.io\">Jasmine</a>을 사용하기를 권장한다. </p>\n<p>커맨드 라인에서 Karma를 실행하면 먼저 자체 웹서버를 구동한 후 테스트 실행을 위한 HTML 페이지를 만들고, 작성된 테스트 코드 및 소스 코드 전부를 해당 페이지에 로드한다. 이후 브라우저를 직접 실행해서 해당 웹페이지에 접속하면 로드된 코드가 실행되고 테스트의 실행 결과는 브라우저 콘솔에 출력된다. Karma는 이 정보를 받아와 지정된 리포터를 사용해 결과를 정리한 후 커맨드 라인에 보여준다.</p>\n<p>이 방식의 가장 큰 장점은 실제 브라우저 환경에서 테스트하기 때문에 브라우저의 모든 기능(네트워크 IO, 렌더링 엔진 등)을 활용해서 테스트할 수 있다는 점이다. 또한 <a href=\"https://www.seleniumhq.org/\">Selenium</a> 등의 도구를 사용하면 동일한 테스트 코드를 다양한 환경(운영체제, 브라우저) 테스트를 실행할 수 있기 때문에, 브라우저 호환성 및 기기 환경에 대한 테스트도 진행할 수 있다. </p>\n<p>하지만 브라우저의 프로세스가 Node.js의 프로세스보다 무겁기 때문에 테스트의 초기 구동 속도가 더 느리다는 단점이 있다. 또한 브라우저라는 별도의 애플리케이션을 추가로 실행해야 하기 때문에 실행을 위한 <a href=\"http://karma-runner.github.io/3.0/config/browsers.html\">브라우저 런처(launcher)</a> 등을 추가로 설치해 주어야 하는 번거로움이 있으며, 크로스 브라우징 테스트 등을 위해서 별도의 환경을 구축하고 유지보수 하는 비용도 결코 무시할 수 없다. </p>\n<p>이러한 단점을 극복하기 위해서 보통 개발 단계에서는 <a href=\"https://en.wikipedia.org/wiki/Headless_browser\">헤드리스 브라우저</a>를 사용해서 빠른 피드백을 얻을 수 있도록 하고, 개발 완료 혹은 배포 시에만 CI 서버와 통합하여 크로스 브라우징 테스트를 하는 방식을 권장한다. 또한 <a href=\"https://www.browserstack.com/\">Browser Stack</a>이나 <a href=\"https://saucelabs.com/\">Sauce Lab</a> 등의 외부 서비스를 사용하면 크로스 브라우징을 위한 환경을 직접 구축할 필요 없이 Karma와 손쉽게 연동하여 사용할 수 있다.</p>\n<h3 id=\"nodejs\" style=\"position:relative;\"><a href=\"#nodejs\" aria-label=\"nodejs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js</h3>\n<p>Node.js 환경에서 테스트 코드를 실행하는 방식을 의미하며, 최근 가장 많이 쓰이는 도구는 Mocha와 Jest이다. 위에서 언급한 것처럼 테스트 러너와 테스트 프레임워크가 통합되어 있어 설치 및 실행이 비교적 간단하다. 이 방식의 가장 큰 장점은 역시 속도인데, Node.js의 프로세스가 브라우저의 프로세스에 비해 훨씬 가볍기 때문에 실행 속도가 빠르다. 또한 브라우저에서는 아직 모듈 단위의 테스트를 실행하기가 어려워 webpack 등의 번들러를 사용해야 하는 제약이 있는 반면 Node.js 환경에서는 개별 프로세스에서 원하는 모듈만 가져와서(import) 테스트할 수 있기 때문에 훨씬 간단하고 안전한 방식으로 테스트를 할 수 있다.</p>\n<p>반면 이 방식의 중요한 단점은 브라우저의 모든 API를 제대로 활용할 수 없다는 것이다. Node.js에는 브라우저가 제공하는 <a href=\"https://en.wikipedia.org/wiki/Document_Object_Model\">DOM(Document Object Model)</a>이나 <a href=\"https://en.wikipedia.org/wiki/Browser_Object_Model\">BOM(Browser Object Model)</a> 등의 API가 없기 때문이다. 이 문제를 해결하기 위해 <a href=\"https://github.com/jsdom/jsdom\">jsdom</a>과 같은 라이브러리를 사용해서 브라우저 환경을 가상으로 구현하는 방식을 사용하고 있지만, 실제 브라우저의 동작을 100% 구현하지는 못하기 때문에 많은 제약이 있다. 예를 들어 렌더링 엔진을 갖고 있지 않기 때문에 UI 요소의 레이아웃에 대한 테스트를 할 수 없고, 내비게이션 관련 동작도 사용할 수 없다. 그뿐만 아니라 브라우저에서 실행할 수가 없기 때문에 크로스 브라우징에 대한 테스트도 할 수 없다. </p>\n<h3 id=\"브라우저-vs-nodejs\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-vs-nodejs\" aria-label=\"브라우저 vs nodejs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 vs Node.js</h3>\n<p>위의 설명을 보고도 아직 어떤 환경을 선택해야 할지 고민된다면 다음의 가이드를 따르기를 권장한다.</p>\n<ol>\n<li>크로스 브라우징 테스트가 \"반드시\" 필요한 경우 브라우저 환경을 사용한다.</li>\n<li>브라우저의 실제 동작(렌더링, 네트워크 IO, 내비게이션 등)에 대한 테스트가 필요한 경우 브라우저 환경을 사용한다.</li>\n<li>그 외의 경우 Node.js 환경을 사용한다.</li>\n</ol>\n<p>1번에서 크로스 브라우징 테스트가 \"반드시\" 필요한 경우라고 강조한 이유는 최근에 크로스 브라우징 테스트의 필요성이 많이 감소했기 때문이다. 우선 최신 브라우저들은 표준 명세의 구현에 있어 과거에 비해 브라우저 간의 차이가 거의 없어졌다. 또한 최신 자바스크립트 문법에 대한 호환성 지원은 <a href=\"https://babeljs.io/\">Babel</a> 등의 트랜스파일러 도구가 대신해주고, DOM을 직접 조작하는 일도 React(<a href=\"https://reactjs.org\">https://reactjs.org</a>), Vue(<a href=\"https://vuejs.org\">https://vuejs.org</a>) 등의 프레임워크가 대신해 주는 경우가 많다. 프로젝트가 지원해야 하는 브라우저 범위나 사용하는 도구 등에 따라 크로스 브라우징 테스트가 정말로 필요한 지 다시 한 번 검토해 볼 필요가 있을 것이다.</p>\n<p><em>([QA(Quality assurance)](<a href=\"https://en.wikipedia.org/wiki/Quality\">https://en.wikipedia.org/wiki/Quality</a></em>assurance)의 관점에서는 당연히 애플리케이션이 모든 환경에서 문제없이 실행되는 것을 보장해야 한다. 이 가이드에서는 QA의 관점이 아닌 개발자의 관점에서 작성하는 자동화 테스트에 대해서 설명하고 있으며, 이 경우 크로스 브라우징 테스트를 작성하고 유지 보수하는 비용과 이를 통해 얻을 수 있는 효과를 잘 따져보는 것이 중요하다.)_</p>\n<p>현재 널리 많이 쓰이고 있으며 이 가이드에서도 권장하고 있는 도구들은 다음과 같다.</p>\n<ul>\n<li>브라우저 : Karma + Jasmine</li>\n<li>Node.js : Jest </li>\n</ul>\n<p>이어지는 장에서는 각 도구들의 특징과 사용법을 좀 더 자세하게 설명하겠다.</p>\n<h2 id=\"jasmine\" style=\"position:relative;\"><a href=\"#jasmine\" aria-label=\"jasmine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jasmine</h2>\n<p>Jasmine은 BDD 스타일의 단언 API를 사용하는 통합 테스트 프레임워크이며, Node.js와 브라우저 환경 모두에서 사용 가능하다. Mocha의 경우 단언 라이브러리는 Chai, 테스트 더블은 Sinon을 사용해야 하는 반면, Jasmine은 모든 기능을 통합해서 제공하기 때문에 라이브러리를 추가로 설치하고 설정할 필요 없이 쉽게 사용할 수 있다.</p>\n<h3 id=\"테스트-명세-작성\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AA%85%EC%84%B8-%EC%9E%91%EC%84%B1\" aria-label=\"테스트 명세 작성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 명세 작성</h3>\n<p>Jasmine의 모든 테스트 명세는 <code class=\"tui-language-text\">it()</code> 함수를 사용해서 작성해야 한다. <code class=\"tui-language-text\">it()</code> 함수의 첫 번째 인자로 명세의 제목을, 두 번째 인자로 명세를 실행할 함수를 넘겨주면 된다. 명세를 실행할 함수 내에서 검증을 위한 단언은 <code class=\"tui-language-text\">expect()</code> 문을 사용하면 된다. 설명을 위해 두 개의 숫자를 더하는 간단한 함수를 만들어보자. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수를 테스트하기 위한 명세는 다음과 같이 작성하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sum() 함수는 두 인자의 합을 반환한다.'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBe</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"테스트-명세-그룹화\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AA%85%EC%84%B8-%EA%B7%B8%EB%A3%B9%ED%99%94\" aria-label=\"테스트 명세 그룹화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 명세 그룹화</h3>\n<p>테스트 대상이나 목적에 따라 관련된 테스트를 그룹으로 묶어주면 테스트 명세가 늘어날 경우에도 쉽게 관리할 수 있으며, 테스트 결과도 그룹별로 정리해서 보여줄 수 있다. Jasmine에서는 <code class=\"tui-language-text\">describe()</code>를 사용해서 그룹화를 할 수 있으며, 중첩해서 사용하면 두 단계 이상의 하위 그룹을 구성할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"tui-language-javascript\"><code class=\"tui-language-javascript\"><span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사칙 연산'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sum()'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'인자가 하나인 경우 에러를 반환한다.'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// ...</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'인자가 두 개인 경우 두 인자의 합을 반환한다.'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBe</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'multiply()'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"테스트-초기화\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B4%88%EA%B8%B0%ED%99%94\" aria-label=\"테스트 초기화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 초기화</h3>\n<p>테스트를 작성할 때 반복적인 초기화 작업이 필요한 경우가 있다. 이러한 경우 <code class=\"tui-language-text\">beforeEach()</code>와 <code class=\"tui-language-text\">afterEach()</code>을 사용하면 각 테스트 명세가 실행되기 전에 필요한 로직과 실행된 후에 필요한 로직을 분리해서 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> uploader<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">beforeEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  uploader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uploader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    url<span class=\"token operator\">:</span> <span class=\"token string\">'http://test.url'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">afterEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  uploader<span class=\"token punctuation\">.</span><span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Uploader'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'파일 업로드 요청'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'업로드 대기중인 파일 목록 받아오기'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"스파이spy\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8C%8C%EC%9D%B4spy\" aria-label=\"스파이spy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스파이(spy)</h3>\n<p>스파이는 자바스크립트에서 모의 객체를 사용할 때 가장 유용하게 사용되는 테스트 더블 중의 하나이다. 스파이는 단순히 객체를 대신하는 역할을 할 뿐만 아니라 실제 함수가 몇 번 호출되었는지, 어떤 인자를 넘겨주었는지 등의 정보를 모두 저장하고 있기 때문에 이러한 정보를 검증에 활용할 수 있다. Jasmine이 제공하는 <code class=\"tui-language-text\">createSpy()</code>나 <code class=\"tui-language-text\">spyOn()</code> 함수를 사용하면 간단하게 스파이를 만들 수 있으며, <code class=\"tui-language-text\">toHaveBeenCalledWith()</code> 등의 단언을 사용해서 다양한 방식으로 결과를 검증할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">let</span> counter<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">beforeEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  counter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">spyOn</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">,</span> <span class=\"token string\">'inc'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  counter<span class=\"token punctuation\">.</span><span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  counter<span class=\"token punctuation\">.</span><span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'inc() 호출 여부 확인'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>inc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'inc() 호출 횟수 확인'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>inc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalledTimes</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'inc() 호출 인자 확인'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>inc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalledWith</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>inc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalledWith</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"타이머-제어\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9D%B4%EB%A8%B8-%EC%A0%9C%EC%96%B4\" aria-label=\"타이머 제어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타이머 제어</h3>\n<p>Jasmine은 자바스크립트 타이머 API를 임의로 변경하여 시간을 직접 제어할 수 있도록 해 준다. 단, 타이머를 제어할 때 전역 객체에 있는 <code class=\"tui-language-text\">setTimeout</code> 함수나 <code class=\"tui-language-text\">Date</code> 등을 내부적으로 변경하기 때문에, 타이머가 필요한 테스트가 종료되면 꼭 제어를 해제해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">beforeEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    jasmine<span class=\"token punctuation\">.</span><span class=\"token function\">clock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">install</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 타이머 제어 시작</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">afterEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    jasmine<span class=\"token punctuation\">.</span><span class=\"token function\">clock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">uninstall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 타이머 제어 해제</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout() 함수는 주어진 밀리세컨 만큼 시간이 지난 후에 콜백 함수를 실행한다'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> callback <span class=\"token operator\">=</span> jasmine<span class=\"token punctuation\">.</span><span class=\"token function\">createSpy</span><span class=\"token punctuation\">(</span><span class=\"token string\">'callback'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>not<span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 아직 callback이 실행되지 않음</span>\n  jasmine<span class=\"token punctuation\">.</span><span class=\"token function\">clock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 시간을 100ms 뒤로 변경</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// callback이 실행됨</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"비동기-테스트\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"비동기 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 테스트</h3>\n<h4 id=\"콜백-함수-사용\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9\" aria-label=\"콜백 함수 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백 함수 사용</h4>\n<p>테스트를 하려는 코드가 비동기로 수행되는 경우, 테스트 명세의 실행을 종료하기 전에 모든 비동기 코드가 끝날 때까지 기다려야 한다. 이 경우 <code class=\"tui-language-text\">it</code>의 내용을 담는 콜백 함수에서 별도의 파라미터(주로 <code class=\"tui-language-text\">done</code>이라는 이름을 사용)를 사용할 수 있다. 해당 콜백 함수에 <code class=\"tui-language-text\">done</code> 파라미터를 선언하게 되면 <code class=\"tui-language-text\">done</code> 함수가 실행될 때까지 테스트 명세가 종료되지 않고 대기하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetchData: API 호출 후 비동기로 콜백 함수를 실행한다.'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">done</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  api<span class=\"token punctuation\">.</span><span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      success<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 이 함수가 실행될때까지 테스트를 종료하지 않고 대기</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4 id=\"프라미스-사용\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%9D%BC%EB%AF%B8%EC%8A%A4-%EC%82%AC%EC%9A%A9\" aria-label=\"프라미스 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프라미스 사용</h4>\n<p>Jasmine은 <code class=\"tui-language-text\">it</code>의 내용을 담는 콜백 함수가 프라미스를 반환하는 경우 해당 프라미스가 해결될 때까지 자동으로 대기해준다. 위의 예제에서 <code class=\"tui-language-text\">fetchData</code> 함수가 콜백을 사용하는 대신 프라미스를 반환한다면 테스트 명세를 다음과 같이 작성할 수 있다. 이 경우 <code class=\"tui-language-text\">fetchData()</code>의 결괏값인 프라미스를 <code class=\"tui-language-text\">it</code> 함수의 반환값으로 넘겼기 때문에, 해당 프라미스가 해결될 때까지 테스트가 종료되지 않고 대기하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetchData: 프라미스를 반환한다'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      success<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4 id=\"asyncawait-사용\" style=\"position:relative;\"><a href=\"#asyncawait-%EC%82%AC%EC%9A%A9\" aria-label=\"asyncawait 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>async/await 사용</h4>\n<p>ES2017 명세에 추가된 <code class=\"tui-language-text\">async/await</code>를 지원하는 환경의 경우 다음과 같이 <code class=\"tui-language-text\">it</code>의 콜백 함수로 <code class=\"tui-language-text\">async</code> 함수를 직접 넘길 수 있다. <code class=\"tui-language-text\">async</code> 함수는 종료된 때 자동으로 프라미스를 리턴하기 때문에 별도의 반환문이 없이도 위의 프라미스 예제와 동일한 결과를 가질 수 있으며, 프라미스보다 더 직관적인 테스트 명세를 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetchData: 프라미스를 반환한다.'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    success<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"karma-테스트-러너\" style=\"position:relative;\"><a href=\"#karma-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%9F%AC%EB%84%88\" aria-label=\"karma 테스트 러너 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Karma 테스트 러너</h2>\n<p>앞서 Jasmine으로 작성한 테스트 코드를 브라우저 환경에서 실행하기 위해서는 별도의 페이지를 생성하고, 소스 코드 및 테스트 코드 등을 모두 로드하는 등의 작업이 추가로 필요하다. 또한 테스트 결과를 확인하기 위해서는 UI를 추가하거나 브라우저 개발자 도구의 콘솔 창을 사용할 수밖에 없다. Karma는 브라우저 환경에서 테스트를 할 때 이러한 일련의 작업을 대신해 주는 도구로서, 아래와 같은 기능을 제공한다. </p>\n<ul>\n<li>로컬 웹서버를 구동한 후 테스트에 필요한 소스 코드 및 리소스를 모두 로드하는 HTML 페이지를 생성한다.</li>\n<li>지정된 브라우저 프로세스를 자동으로 실행한 후 앞서 생성한 웹페이지의 URL에 접속한다.</li>\n<li>브라우저에서 실행된 결과를 받아와서 지정된 리포터를 사용해 다양한 형식으로 출력한다.</li>\n</ul>\n<h3 id=\"설치-및-실행\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%A4%ED%96%89\" aria-label=\"설치 및 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설치 및 실행</h3>\n<p>다음은 Karma를 실제로 설치해서 설정한 후 실행하기까지의 간단한 과정을 소개한다.</p>\n<h4 id=\"karma-설치\" style=\"position:relative;\"><a href=\"#karma-%EC%84%A4%EC%B9%98\" aria-label=\"karma 설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Karma 설치</h4>\n<p>npm을 사용하면 간단하게 바이너리를 설치할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm install --save-dev karma</code></pre></div>\n<h4 id=\"jasmine-플러그인-설치\" style=\"position:relative;\"><a href=\"#jasmine-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%84%A4%EC%B9%98\" aria-label=\"jasmine 플러그인 설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jasmine 플러그인 설치</h4>\n<p>Karma에서 Jasmine을 사용하기 위해서는 설정 파일을 통해 Jasmine의 소스 코드를 직접 페이지에 로드해야 한다. 플러그인을 사용하면 이러한 과정이 필요 없이 손쉽게 Jasmine을 사용할 수 있다. (Jasmine은 이미 설치되어 있다고 가정한다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm install --save-dev karma-jasmine</code></pre></div>\n<h4 id=\"크롬-런처-설치\" style=\"position:relative;\"><a href=\"#%ED%81%AC%EB%A1%AC-%EB%9F%B0%EC%B2%98-%EC%84%A4%EC%B9%98\" aria-label=\"크롬 런처 설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>크롬 런처 설치</h4>\n<p>브라우저를 자동으로 실행하려면 각 브라우저에 맞는 런처를 별도로 설치해야 한다. 예를 들어 크롬 브라우저를 실행하기 위해서는  <code class=\"tui-language-text\">karma-chrome-launcher</code>를 설치해야 한다. 크롬 외에도 다양한 브라우저 런처를 제공하며, 지원 브라우저의 목록은 <a href=\"http://karma-runner.github.io/3.0/config/browsers.html\">공식 홈페이지</a>에서 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm install --save-dev karma-chrome-launcher</code></pre></div>\n<h4 id=\"설정-파일\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC\" aria-label=\"설정 파일 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설정 파일</h4>\n<p>Karma는 프로젝트의 최상위 폴더에 있는 <code class=\"tui-language-text\">karma.config.js</code> 파일로 설정 파일을 관리한다. 아래는 최소한의 내용만을 포함하는 간단한 설정 파일의 예시이며, 옵션에 대한 좀 더 상세한 설명은 <a href=\"http://karma-runner.github.io/3.0/config/configuration-file.html\">공식 홈페이지</a>에서 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">module<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">exports</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">config</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  config<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    frameworks<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'jasmine'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// Jasmine 테스트 프레임워크 사용</span>\n    files<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'src/**/*.js'</span><span class=\"token punctuation\">,</span>      <span class=\"token comment\">// 소스 파일 경로</span>\n      <span class=\"token string\">'test/**/*.spec.js'</span>  <span class=\"token comment\">// 테스트 파일 경로</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    reporters<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'dots'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\">// 리포터 지정 (점 형태로 결과 출력)</span>\n    browsers<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Chrome'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 크롬 브라우저를 자동 실행을 위한 런처 지정</span>\n    singleRun<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>         <span class=\"token comment\">// 테스트 1회 실행 후 Karma 종료</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4 id=\"테스트-실행\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89\" aria-label=\"테스트 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 실행</h4>\n<p>먼저 <code class=\"tui-language-text\">package.json</code>에 다음과 같이 npm 스크립트를 등록한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token string\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"test\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"karma start\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제, 커맨드 라인에서 아래와 같이 편리하게 실행할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm test</code></pre></div>\n<p>karma가 실행되면 먼저 브라우저가 열리고 테스트가 수행된 다음 아래와 같이 콘솔에 결과가 출력된다. 테스트가 완료되면 브라우저는 자동으로 닫힌다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731228-3be76380-9280-11e9-969e-34c84cd5250e.png\" alt=\"Screen Shot 2018-10-23 at 12 55 52 PM\"></p>\n<h3 id=\"테스트-커버리지-측정\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%B8%A1%EC%A0%95\" aria-label=\"테스트 커버리지 측정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 커버리지 측정</h3>\n<p>작성한 테스트 코드의 커버리지는 <a href=\"http://gotwarlost.github.io/istanbul/\">Istanbul</a> 라이브러리를 사용해 측정할 수 있다. Istanbul은 소스 코드를 분석해서 모든 줄마다 실행 횟수를 측정할 수 있는 코드를 삽입하는 방식으로 커버리지를 측정한다. 코드 실행 후에는 실행 결과를 HTML, LCOV, Cobertura 등의 다양한 포맷으로 출력해 주며, CI 서버에 연동해서 사용할 수도 있다. </p>\n<p>Istanbul을 커맨드 라인에서 직접 실행할 수도 있지만, 일반적으로는 테스트 러너가 플러그인 형태로 제공하는 것을 사용한다. Karma의 경우 <a href=\"https://github.com/karma-runner/karma-coverage\">karma-coverage</a> 플러그인을 사용하면 istanbul을 사용한 커버리지 측정 결과를 손쉽게 확인할 수 있다.</p>\n<h4 id=\"karma-coverage-플러그인-설치\" style=\"position:relative;\"><a href=\"#karma-coverage-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%84%A4%EC%B9%98\" aria-label=\"karma coverage 플러그인 설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>karma-coverage 플러그인 설치</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm install --save-dev karma-coverage</code></pre></div>\n<h4 id=\"설정-파일-수정\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-%EC%88%98%EC%A0%95\" aria-label=\"설정 파일 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설정 파일 수정</h4>\n<p>설치가 완료되면, 설정 파일을 수정해야 한다. 위의 설정 파일 예제에서 <code class=\"tui-language-text\">reporters</code>에 <code class=\"tui-language-text\">&#39;coverage&#39;</code>를 추가하고, <code class=\"tui-language-text\">preprocessors</code> 항목에도 커버리지 측정을 원하는 소스 파일에 대해 <code class=\"tui-language-text\">&#39;coverage&#39;</code>를 추가해 준다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">module<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">exports</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">config</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  config<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    frameworks<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'jasmine'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    files<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'src/**/*.js'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'test/**/*.spec.js'</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    reporters<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'dots'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'coverage'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 커버리지 리포터 추가</span>\n    coverageReporter<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'html'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 커버리지 출력 형식 지정</span>\n      dir<span class=\"token operator\">:</span> <span class=\"token string\">'coverage'</span> <span class=\"token comment\">// 커버리지 결과가 저장될 폴더를 지정</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    browsers<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Chrome'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n    singleRun<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    preprocessors<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>   \n      <span class=\"token string\">'src/**/*.js'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'coverage'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 전체 소스 코드에 대해 커버리지 측정을 위한 전처리 지정</span>\n    <span class=\"token punctuation\">}</span>    \n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4 id=\"실행-및-결과-확인\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%ED%96%89-%EB%B0%8F-%EA%B2%B0%EA%B3%BC-%ED%99%95%EC%9D%B8\" aria-label=\"실행 및 결과 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실행 및 결과 확인</h4>\n<p>이제 다시 Karma를 실행해보면 다음과 같이 <code class=\"tui-language-text\">coverage</code>라는 폴더 내부에, 실행된 브라우저 및 운영체제의 버전이 명시된 <code class=\"tui-language-text\">Chrome 69.0.3497 (Mac OX X 10.14.0)</code> 폴더가 생성된 것을 확인할 수 있다. (만약 다수의 브라우저 런처를 사용했다면, 각 브라우저 별로 고유한 폴더가 생성된다.)</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731229-3be76380-9280-11e9-8da3-3c01844ca8ab.png\" alt=\"Screen Shot 2018-10-23 at 12 57 53 PM\"></p>\n<p><code class=\"tui-language-text\">src</code> 폴더 안에 있는 <code class=\"tui-language-text\">index.html</code> 파일을 브라우저에서 열어 보면 다음과 같이 커버리지 측정 결과가 파일별로 정리되어 있는 것을 확인할 수 있다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731231-3c7ffa00-9280-11e9-933f-fba52684412e.png\" alt=\"Screen Shot 2018-10-23 at 12 58 56 PM\"></p>\n<p>파일명을 클릭하면 개별 파일의 커버리지 측정 결과도 확인할 수 있다. 다음은 <code class=\"tui-language-text\">calc.js</code> 파일에 대한 줄 단위의 커버리지 결과이다. 좌측 줄번호 옆의 <code class=\"tui-language-text\">1x</code> 표시는 해당 줄이 전체 테스트가 진행되는 동안 한 번 실행되었다는 의미이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731230-3c7ffa00-9280-11e9-8eeb-d94428c80a88.png\" alt=\"Screen Shot 2018-10-23 at 12 58 43 PM\"></p>\n<h3 id=\"크로스-브라우징-테스트\" style=\"position:relative;\"><a href=\"#%ED%81%AC%EB%A1%9C%EC%8A%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"크로스 브라우징 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>크로스 브라우징 테스트</h3>\n<p>지금까지는 주로 개발자의 로컬 PC에서 이루어지는 테스트에 대해서 알아보았다. Karma의 브라우저 런처 플러그인을 사용하면 개발자의 로컬 PC에서도 다양한 브라우저에 대한 테스트를 동시에 실행할 수 있다. 하지만, 더 많은 기기를 지원해야 하는 프로젝트에서는 개발자 PC에서만 테스트를 하기가 불가능한 경우도 있다. 예를 들어 인터넷 익스플로러는 윈도우가 설치된 하나의 PC에 하나의 버전만 설치할 수 있기 때문에, 여러 버전의 인터넷 익스플로러를 테스트해야 하는 경우 여러 개의 PC 혹은 가상 머신을 사용할 수 밖에 없다. </p>\n<p>이런 경우 karma와 <a href=\"https://www.seleniumhq.org/\">Selenium WebDriver</a>를 연결하여 사용하면 원격 PC를 사용해 테스트를 실행하고, 결과를 한 곳에 모아 출력할 수 있다. 간단히 설명하면 위의 예제에서 사용한 Chrome 런처 대신를 <a href=\"https://github.com/karma-runner/karma-webdriver-launcher\">karma-webdriver-launcher</a>로 변경해 주기만 하면 된다. 그러면 다음 그림과 같이 Hub의 역할을 하는 기기를 통해 연결된 원격 PC가 로컬 Karma 서버에 접근하도록 만들어 테스트를 실행하게 된다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731220-3ab63680-9280-11e9-9b81-24bd36846f44.png\" alt=\"31878040-9e9691a2-b813-11e7-8413-e54dfafc9781\"></p>\n<p>Selenium WebDriver에 대한 소개는 이 가이드 후반부의 \"E2E 테스트 도구\" 장에서 다루고 있지만, 직접 설치하고 테스트 환경을 구축하는 내용까지 다루지는 않는다. 설치와 관련된 내용은 <a href=\"/test123/weekly-pick/ko_20171020/\">멀티 브라우저 테스트 환경 구축하기</a>를 참고하기 바란다.</p>\n<h2 id=\"jest\" style=\"position:relative;\"><a href=\"#jest\" aria-label=\"jest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jest</h2>\n<p><a href=\"https://jestjs.io/\">Jest</a>는 페이스북에서 만든 오픈소스 테스트 프레임워크이며, 최근 프론트엔드 개발에서 가장 활발하게 사용되는 테스트 도구이다. 꽤 오랜 기간 동안 개발되어 왔음에도 불구하고 한동안 관심을 받지 못하다가, 최근에 안정성 및 성능이 눈에 띄게 좋아지면서 많은 인기를 끌고 있다. Karma와는 다르게 Node.js 환경에서 실행되며, 내부적으로 Jasmine 스타일의 단언 API를 사용하기 때문에 기존에 Jasmine을 사용하고 있던 사용자들도 쉽게 적응할 수 있다.</p>\n<p>이 가이드에서 Jest의 상세한 사용법은 다루지 않지만, Jest만이 갖고 있는 장점과 유용한 기능들을 간단히 소개하도록 하겠다.</p>\n<h3 id=\"쉬운-설치-및-실행\" style=\"position:relative;\"><a href=\"#%EC%89%AC%EC%9A%B4-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%A4%ED%96%89\" aria-label=\"쉬운 설치 및 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쉬운 설치 및 실행</h3>\n<p>Jest의 가장 큰 장점은 쉬운 설치 및 사용 방법이라 할 수 있다. Jest는 테스트 러너의 기능뿐 아니라, 단언, 테스트 더블, 코드 커버리지 등 테스트에 필요한 모든 기능을 지원하기 때문에 별다른 추가 설치가 필요 없다. 또한 특별한 설정 없이 디폴트 설정 만으로도 실행할 수 있기 때문에, 처음 사용하는 사람도 손쉽게 테스트를 작성하고 실행해 볼 수 있다. </p>\n<p>아주 간단한 예제를 통해 얼마나 쉽게 실행할 수 있는지를 알아보자. 우선 npm 명령을 사용해 간단히 설치할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm install --save-dev jest</code></pre></div>\n<p>실행을 돕기 위해 <code class=\"tui-language-text\">package.json</code> 에 <code class=\"tui-language-text\">test</code> 스크립트를 등록한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n  <span class=\"token string\">\"test\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"jest\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 테스트 파일이 <code class=\"tui-language-text\">*.spec.js</code> 형식을 따른다면 추가 설정이 필요 없이 바로 실행할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm test</code></pre></div>\n<p>그러면 다음과 같이 결과가 터미널에 출력되는 것을 볼 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731223-3b4ecd00-9280-11e9-8979-2f1de249a923.png\" alt=\"Screen Shot 2018-10-23 at 3 18 03 PM\"></p>\n<p>물론 숙련된 사용자들을 위한 다양한 설정 옵션도 제공한다. 별도의 설정 파일인 <code class=\"tui-language-text\">jest.conf.js</code> 파일을 생성해서 설정 옵션들을 설정할 수 있으며, <code class=\"tui-language-text\">package.json</code> 파일 내부에도 <code class=\"tui-language-text\">jest</code> 프라퍼티를 사용해서 옵션을 설정할 수 있다. 예를 들어 테스트 파일의 경로를 지정하고 싶다면 <code class=\"tui-language-text\">package.json</code> 파일 내부에 다음과 같이 <code class=\"tui-language-text\">testMatch</code> 옵션을 설정하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">{\n  &quot;name&quot;: &quot;my-project&quot;,\n  &quot;jest&quot;: {\n    &quot;testMatch&quot;: [&quot;&lt;rootDir&gt;/test/**/*.spec.js&quot;]\n  }\n}</code></pre></div>\n<p>각 옵션에 대한 좀 더 상세한 설명은 <a href=\"https://jestjs.io/docs/en/configuration\">공식 홈페이지</a>에서 확인할 수 있다.</p>\n<h3 id=\"쉬운-커버리지-측정\" style=\"position:relative;\"><a href=\"#%EC%89%AC%EC%9A%B4-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%B8%A1%EC%A0%95\" aria-label=\"쉬운 커버리지 측정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쉬운 커버리지 측정</h3>\n<p>Jest의 커버리지 측정 역시 Karma와 마찬가지로 istanbul을 사용한다. 하지만, Jest에서는 이 기능 또한 통합된 형태로 제공되기 때문에 사용자는 별도의 설치나 추가 설정 없이 바로 사용할 수 있다. 위의 예제에서 커버리지를 확인하기 위해서는 커맨드 라인에서 실행할 때 <code class=\"tui-language-text\">--coverage</code> 옵션만 추가하면 된다.</p>\n<p>npm 스크립트를 실행할 때 옵션을 추가하기 위해선 <code class=\"tui-language-text\">--</code> 를 사용하면 된다. 다음과 같이 실행해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm test -- --coverage</code></pre></div>\n<p>실행이 완료되면 다음과 같이 커맨드 라인에 커버리지 측정 결과가 출력되고, 프로젝트 폴더에는 <code class=\"tui-language-text\">coverage</code> 폴더가 자동으로 생성된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731224-3b4ecd00-9280-11e9-9bba-04c04d8637eb.png\" alt=\"Screen Shot 2018-10-23 at 3 25 57 PM\">\n<img src=\"https://user-images.githubusercontent.com/35218826/59731226-3be76380-9280-11e9-9d3b-488fbd9cb36b.png\" alt=\"Screen Shot 2018-10-23 at 3 30 20 PM\"></p>\n<p> <code class=\"tui-language-text\">lcov-report</code> 폴더의 <code class=\"tui-language-text\">index.html</code> 파일을 브라우저에서 열어 보면 위의 Karma 예제에서와 동일한 화면을 확인할 수 있다. </p>\n<h3 id=\"jsdom-내장\" style=\"position:relative;\"><a href=\"#jsdom-%EB%82%B4%EC%9E%A5\" aria-label=\"jsdom 내장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>jsdom 내장</h3>\n<p>앞서 언급했듯이 Node.js 환경에서는 브라우저에서 제공하는 <a href=\"https://developer.mozilla.org/en-US/docs/Gecko_DOM_Reference\">DOM</a>이나 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window\">window 객체</a>의 API를 사용할 수 없다. 그래서 프론트엔드 코드를 테스트하기 위해서는 이러한 API를 가상으로 구현한 환경이 추가로 필요한데, 그중 가장 완성도가 높고 널리 쓰이는 라이브러리가 바로 <a href=\"https://github.com/jsdom/jsdom\">jsdom</a>이다. 하지만 jsdom은 라이브러리 형태로 제공되기 때문에 실제 사용하기 위해서는 테스트를 실행할 때마다 초기화 관련 코드를 실행해 주어야 하며, 이는 브라우저 환경에서 직접 실행하는 것에 비해 번거로울 수밖에 없다. </p>\n<p>Jest에서는 jsdom을 내장하여 테스트 실행할 때마다 필요한 환경을 자동으로 설정해서 제공하기 때문에, 별다른 추가 작업 없이 마치 브라우저 환경인 것 처럼 테스트를 작성할 수 있다. </p>\n<h3 id=\"스냅샷-테스트\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%83%85%EC%83%B7-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"스냅샷 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스냅샷 테스트</h3>\n<p>스냅샷 테스트는 Jest의 상징과 같은 기능이라고 볼 수 있다. 간단히 말해, 스냅샷 테스트는 객체 내부의 상태를 그대로 파일로 저장해 놓고, 다음 테스트에서 객체의 현재 상태가 이전에 저장된 상태와 다른지를 비교하는 테스트를 말한다. 일종의 회귀 테스트라고 볼 수 있는데, 해당 객체 내부의 상태가 복잡한 경우 모든 상태에 대한 기댓값을 일일이 다 코드로 작성할 필요 없이 눈으로만 확인할 수 있어 테스트 작성이 쉬워진다는 장점이 있다. </p>\n<p>스냅샷 테스트는 주로 리액트의 가상 DOM 구조를 비교하기 위해 사용되는데, 테스트를 작성할 때 다음과 같이 <code class=\"tui-language-text\">toMatchSnapshot()</code> 함수만을 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> Link <span class=\"token keyword\">from</span> <span class=\"token string\">'./Link'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> renderer <span class=\"token keyword\">from</span> <span class=\"token string\">'react-test-renderer'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'렌더링 확인'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> tree <span class=\"token operator\">=</span> renderer\n    <span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>Link page<span class=\"token operator\">=</span><span class=\"token string\">\"http://ui.toast.com\"</span><span class=\"token operator\">></span><span class=\"token constant\">TOAST</span> <span class=\"token constant\">UI</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Link<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">toJSON</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMatchSnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>테스트를 실행하고 나면 자동으로 스냅샷 파일이 만들어지는데, 이 파일의 내용을 살펴보면 다음과 같이 해당 컴포넌트가 렌더링한 DOM의 구조가 그대로 저장된 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\">exports<span class=\"token punctuation\">[</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">렌더링 확인 1</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n&lt;a\n  className=\"normal\"\n  href=\"http://ui.toast.com\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  TOAST UI\n&lt;/a>\n</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 스냅샷 파일이 생성되고 나면, 이후에 컴포넌트가 반환하는 DOM 구조가 변경되었을 때 테스트가 실패하게 된다. 사용자는 달라진 내용을 확인하고 의도된 수정이면 스냅샷을 갱신하고, 아닌 경우 문제를 해결하면 된다. </p>\n<p>이러한 방식은 리액트가 아니더라도 복잡한 데이터 구조에 대한 테스트를 작성할 때는 언제든 활용할 수 있다. 다만, 스냅샷 테스트를 작성하는 경우 테스트 코드에서 테스트의 의도가 명확하게 드러나지 않는다는 단점이 있다. 특히 원하는 기댓값에 대한 고민 없이 의미 없는 테스트를 만들거나  테스트가 실패했을 때 세부 내용을 면밀히 살펴보지 않고 스냅샷을 갱신하는 등의 잘못된 테스트 습관을 만들 수도 있으므로 꼭 필요한 경우에만 주의해서 사용해야 한다.</p>\n<h3 id=\"테스트-파일-필터링\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%ED%95%84%ED%84%B0%EB%A7%81\" aria-label=\"테스트 파일 필터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 파일 필터링</h3>\n<p>Jest는 테스트할 대상 파일을 구체적으로 지정할 수 있는 기능을 제공한다. 우선 Jest는 기본적으로 Git과 같은 버전 관리 도구와 연동하여 마지막 커밋 이후에 변경 사항이 있는 파일만을 테스트 대상에 포함한다. 이를 통해 이미 검증된 파일에 대해서 불필요한 테스트를 매번 실행하는 것을 방지할 수 있다.</p>\n<p>커맨드 라인 인터페이스를 사용하면 파일을 더 구체적으로 선별할 수 있다. 한 번 실행한 이후에는 추가로 명령할 수 없는 보통의 러너들과는 달리, Jest는 인터랙티브한 커맨드 라인 인터페이스를 제공해서 실행 이후에도 키 입력을 통해 테스트 대상 파일들을 변경할 수 있는 기능을 지원한다. 이를 통해 현재 진행 중인 테스트를 취소하거나, 특정 파일명과 매치되는 테스트만 필터링해서 실행하도록 명령할 수 있다. 또한 스냅샷 테스트가 실패한 경우 <a href=\"https://jestjs.io/docs/en/snapshot-testing#interactive-snapshot-mode\">결과를 확인한 후에 바로 스냅샷을 갱신</a>하도록 만들 수도 있다. </p>\n<p>다음 스크린샷 영상은 <code class=\"tui-language-text\">a</code> 키를 통해 전체 파일을 테스트하도록 명령한 다음 <code class=\"tui-language-text\">q</code> 키를 눌러서 취소하고, <code class=\"tui-language-text\">p</code> 키를 눌러서 원하는 패턴의 파일만을 테스트하는 일련의 과정을 보여준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731221-3b4ecd00-9280-11e9-8b95-fc4b0e193f8f.gif\" alt=\"Screen Recording 2018-10-23 at 3 36 57 PM 2018-10-23 15_41_40\"></p>\n<h3 id=\"샌드박스-병렬-테스트\" style=\"position:relative;\"><a href=\"#%EC%83%8C%EB%93%9C%EB%B0%95%EC%8A%A4-%EB%B3%91%EB%A0%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"샌드박스 병렬 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>샌드박스 병렬 테스트</h3>\n<p>Node.js 환경에서 테스트를 하는 것의 가장 큰 장점은 바로 \"속도\"이다. Node.js의 프로세스는 브라우저의 프로세스보다 훨씬 가볍기 때문에 초기 구동 속도가 빠를 수밖에 없다. Jest는 이러한 특징을 이용해서 각각의 테스트 파일을 독립된 프로세스에서 실행한다. 이 경우 각각의 테스트가 사용하는 전역 객체나 모듈의 상태가 서로에게 영향을 미치지 않고 마치 샌드박스 내부에 있는 것처럼 실행되기 때문에 훨씬 안전하게 테스트를 할 수 있다.</p>\n<p>단, 테스트를 순차적으로 실행하면서 개별 테스트마다 새로운 자식 프로세스를 생성하게 되면 단일 프로세스에서 실행하는 것보다 느려지게 된다. 이 문제를 해결하기 위해 Jest는 <a href=\"https://jestjs.io/docs/en/jest-platform#jest-worker\">다수의 프로세스를 병렬로 실행</a>하는 방식을 사용해 속도를 향상시키며, 내부적으로 CPU 코어의 수 등을 고려해 동시에 실행되는 프로세스의 개수를 적절하게 조절하여 최적화된 속도를 유지할 수 있도록 한다. 또한 앞서 설명한 \"테스트 파일 필터링\" 기능을 사용하면 불필요한 테스트 실행을 방지해서 속도를 향상시킬 수 있다. </p>\n<p>Jest는 이러한 방식으로 테스트 실행 속도를 높은 수준으로 유지하면서도 훨씬 더 안전한 테스트 환경을 제공해 준다.</p>\n<h2 id=\"e2e-테스트-도구\" style=\"position:relative;\"><a href=\"#e2e-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC\" aria-label=\"e2e 테스트 도구 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>E2E 테스트 도구</h2>\n<p>지금까지 살펴본 Karma, Jest 등의 도구들은 모두 단위 테스트나 통합 테스트를 위한 도구라고 볼 수 있다. 사실 E2E 테스트는 작성이 번거롭고 실행 속도가 느리며 통제된 환경에서 테스트를 할 수 없다는 단점 때문에 개발자들이 개발 과정에 사용하기에는 어려움이 많았다. 하지만 프론트엔드 개발의 경우 UI/UX 관련 기능을 실제 사용자 환경과 분리된 상태에서 테스트하기에는 한계가 있었기 때문에, 사용자의 관점에서 테스트를 할 수 있는 E2E 테스트에 대한 필요성이 꾸준히 요구되어 왔다. </p>\n<p>이러한 흐름에서 최근 <a href=\"https://www.cypress.io\">Cypress</a>나 <a href=\"https://devexpress.github.io/testcafe/\">TestCafe</a> 등의 새로운 도구들이 등장했는데, 이들은 기존 E2E 도구들이 갖던 단점을 최소화하여 E2E 테스트의 장점을 최대한 활용할 수 있도록 도와준다. 이 장에서는 기존에 가장 널리 사용되던 도구인 <a href=\"https://www.seleniumhq.org/projects/webdriver/\">Selenium Webdriver</a>와 최근 가장 인기 있는 도구인 Cypress를 비교해 보며, E2E 도구가 어떻게 발전하고 있는지를 살펴보도록 하겠다.</p>\n<h3 id=\"selenium-webdriver\" style=\"position:relative;\"><a href=\"#selenium-webdriver\" aria-label=\"selenium webdriver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Selenium WebDriver</h3>\n<p>Selenium WebDriver는 흔히 Selenium, 혹은 WebDriver라고도 부르는데, 정확하게는 Selenium 2.0부터 새롭게 도입된 <a href=\"https://www.w3.org/TR/webdriver/\">WebDriver API</a>와 Selenium을 묶어서 부르는 이름이다. 이전 버전인 Selenium 1.0(Selenium RC)에서는 자바스크립트를 브라우저 내부에 삽입하는 방식을 사용한 반면, 2.0부터는 브라우저를 외부에서 제어하는 방식을 사용하기 때문에 더 구체적인 행위까지 제어할 수 있게 되었다. 또한 <a href=\"https://github.com/SeleniumHQ/selenium/wiki/Grid2\">Selenium Grid</a>를 사용해서 동일한 테스트를 다양한 기기에서 동시에 실행할 있는 기능도 제공한다.</p>\n<p>WebDriver는 통일된 API를 기반으로 브라우저를 제어하기 위해 만든 HTTP 기반의 프로토콜이며, 독자적인 명세로 시작했지만 현재는 W3C에서 관리되고 있는 표준이 되었다. WebDriver는 기본적으로 브라우저가 서버 역할을 하고 제어를 요청하는 기기(개발자 PC 혹은 CI 서버)가 클라이언트의 역할을 하는 서버-클라이언트 구조라고 할 수 있으며, 브라우저용 드라이버와 개발자용 클라이언트를 설치해서 사용하게 된다. </p>\n<p>예를 들어 브라우저가 클라이언트의 응답을 처리하기 위해서는 별도의 드라이버를 설치해야 하는데, <a href=\"https://www.seleniumhq.org/download/\">홈페이지</a>에서 크롬, 인터넷 익스플로러, 파이어폭스, 사파리 등 다양한 브라우저를 지원하는 다양한 드라이버를 다운로드할 수 있다. 또한 WebDriver는 HTTP를 사용한 JSON 기반의 프로토콜이기 때문에 테스트 코드를 작성할 때 언어의 제약을 받지 않으며, 현재 자바스크립트뿐만 아니라 Java, C#, Ruby, Python 등의 언어를 지원하는 클라인언트를 다운로드할 수 있다.</p>\n<p>특히 자바스크립트에는 WebDriver API를 사용한 Node.js 기반의 테스트 프레임워크가 이미 다양하게 존재하는데, 여기서 그중 몇 가지를 소개하겠다.</p>\n<ul>\n<li><a href=\"http://www.protractortest.org/\">Protractor</a> : Angular 프로젝트를 위한 테스트 프레임워크 </li>\n<li><a href=\"https://github.com/SeleniumHQ/selenium/wiki/WebDriverJs\">WebdriverJS</a> : Selenium Webdriver의 정식 Node.js 구현체이며, 낮은 수준(Low-level)의 API를 제공한다.</li>\n<li><a href=\"http://nightwatchjs.org/\">NightWatch</a> : Mocha 기반의 테스트 러너와 직관적인 API, CI 서버 통합 등의 다양한 기능을 지원한다.</li>\n<li><a href=\"http://webdriver.io/\">WebdriverIO</a> : 테스트 러너, 정적 웹 서버, CI 서버 통합, REPL 인터페이스 등 다양한 기능을 지원하며 커뮤니티가 가장 잘 활성화되어 있다.</li>\n</ul>\n<p>WebDriver는 현존하는 E2E 테스트 도구 중 가장 널리 쓰이는 도구라고 할 수 있다. 개발자와 전문 테스터 모두가 사용할 수 있으며 테스트뿐만 아니라 브라우저를 사용한 다양한 자동화 작업에 사용된다. 하지만 WebDriver는 앞서 설명한 E2E 테스트의 단점을 그대로 갖고 있기 때문에 테스트를 작성하거나 유지 보수하는데 많은 비용이 들며, 이로 인해 개발자들이 개발 단계에서 사용하는 테스트 도구로써는 사실상 널리 활용되지 못하고 있다.</p>\n<h3 id=\"cypress\" style=\"position:relative;\"><a href=\"#cypress\" aria-label=\"cypress permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cypress</h3>\n<p>Cypress는 TestCafe와 함께 최근 가장 각광받고 있는 E2E 도구이며, WebDriver와는 다르게 실제 애플리케이션과 테스트 코드를 동일한 브라우저에서 실행하는 방식을 취하고 있다. 이 방식은 HTTP 등을 사용한 프로세스 사이의 통신이 필요 없이 동일한 프로세스 내부에서 테스트를 실행하기 때문에 테스트를 훨씬 빠르고 안정적으로 실행할 수 있다. 또한 브라우저 기반의 GUI를 사용하여 테스트의 실행 상태를 확인하고 디버깅할 수 있는 다양한 편의 기능을 제공한다. </p>\n<p>예를 들면, 실행된 모든 테스트 명령과 각 명령이 실행될 때의 UI 상태를 스냅샷 형태로 모두 저장하고 있어, 특정 시점의 UI 상태를 눈으로 확인할 수 있다. 또한 전체 테스트 진행 과정을 동영상으로 저장하거나 테스트가 실패했을 때 자동으로 스크린샷을 남길 수 있어 테스트가 실패했을 때 원인을 파악하기가 매우 쉽다. 게다가 브라우저에서 실행되기 때문에 필요한 경우 크롬 개발자 도구를 사용해 디버깅을 할 수도 있다. </p>\n<p>하지만 브라우저 내부에서 실행되는 방식에는 단점 또한 존재하며, <a href=\"https://docs.cypress.io/guides/references/trade-offs.html\">Cypress의 공식 문서</a>에 잘 정리되어 있다. 예를 들면, 브라우저의 새 탭 혹은 새 창을 열 수 없으며, 동일 출처(Same-origin) 정책을 벗어나는 페이지로는 이동을 할 수가 없다. 또한 브라우저가 실행할 수 있는 언어는 자바스크립트가 유일하기 때문에 다른 언어로 테스트를 작성할 수 없는 제약이 있다.</p>\n<p>하지만 이러한 단점들은 범용 E2E 도구로써 사용할 때의 단점일 뿐 개발 단계에서 자바스크립트 코드를 테스트할 때는 크게 문제가 되지 않는다. Cypress는 Selenium WebDriver와는 전혀 다른 목적을 갖는 도구이며, 정확히 프론트엔드 개발자들이 개발 단계에서 사용하기에 최적화된 도구라고 할 수 있다. 특히 기존 E2E 도구의 가장 큰 단점이던 테스트 작성 비용과 테스트 실행 시간을 대폭 줄여주었기 때문에, 개발자들은 단위 테스트나 통합 테스트를 작성할 때와 비슷한 비용으로 E2E 테스트를 작성할 수 있게 되었다. E2E 테스트가 주는 많은 이점들을 생각해 볼 때, Cypress와 같은 도구가 발전할수록 개발자들은 점점 더 많은 E2E 테스트를 작성하게 될 것이다.</p>\n<h2 id=\"cypress-설치-및-실행\" style=\"position:relative;\"><a href=\"#cypress-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%8B%A4%ED%96%89\" aria-label=\"cypress 설치 및 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cypress 설치 및 실행</h2>\n<p>이제 실제로 Cypress를 설치하고, 간단한 TodoMVC 애플리케이션을 테스트하는 코드를 작성해보자.</p>\n<h3 id=\"설치-및-설정\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%84%A4%EC%A0%95\" aria-label=\"설치 및 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설치 및 설정</h3>\n<p>Cypress는 npm 명령으로 간단하게 설치할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm install cypress --save-dev</code></pre></div>\n<p>Cypress는 별다른 설정 없이 바로 실행할 수 있지만, npm 스크립트를 등록하면 더 편하게 실행할 수 있다. <code class=\"tui-language-text\">package.json</code> 파일에 아래의 스크립트를 입력하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"cypress:open\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"cypress open\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"인터랙티브-모드-실행\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9E%99%ED%8B%B0%EB%B8%8C-%EB%AA%A8%EB%93%9C-%EC%8B%A4%ED%96%89\" aria-label=\"인터랙티브 모드 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터랙티브 모드 실행</h3>\n<p>아래 명령을 커맨드 라인에 입력하면 Cypress가 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm run cypress:open</code></pre></div>\n<p>처음 Cypress를 실행하면 프로젝트 폴더에 <code class=\"tui-language-text\">cypress</code>라는 폴더가 생성된다. 해당 폴더에는 처음 사용하는 사용자들을 위한 다양한 샘플 파일들이 포함되어 있다. 특히 <code class=\"tui-language-text\">integration/examples</code> 폴더 내부에는 다양한 상황에서 어떤 식으로 테스트를 작성해야 하는지를 알려주는 테스트 명세가 포함되어 있어, 처음 Cypress의 사용 방법을 익히는 데에 큰 도움이 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731232-3c7ffa00-9280-11e9-8eca-8e01ebefa4a1.png\" alt=\"Screen Shot 2018-12-03 at 3 58 39 PM\"></p>\n<p>Cypress가 실행되면 가장 먼저 위의 그림과 같이 <a href=\"https://electronjs.org\">Electron</a>으로 만들어진 GUI 애플리케이션을 볼 수 있다. <strong>Tests</strong> 탭에 현재 작성된 테스트 명세 파일들이 표시되는데, 아직 테스트를 작성하지는 않았지만 <code class=\"tui-language-text\">integration/examples</code> 폴더 내부에 포함된 샘플 파일들을 볼 수 있다. 이 중 <code class=\"tui-language-text\">actions.spec.js</code>를 선택해서 실제로 테스트를 실행해보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731234-3d189080-9280-11e9-90ce-ecf38034d524.png\" alt=\"Screen Shot 2018-12-03 at 4 14 30 PM\"></p>\n<p>테스트를 선택하면 위의 그림과 같이 테스트 러너가 실행된 후에 개별 테스트가 순차적으로 실행되는 것을 눈으로 확인할 수 있다. 테스트 러너의 각 화면에 대한 간략한 설명은 다음과 같으며, 좀 더 상세한 설명은 <a href=\"https://docs.cypress.io/guides/core-concepts/test-runner.html\">공식 홈페이지</a>에서 확인할 수 있다.</p>\n<p><strong>(1) 테스트 상태 메뉴</strong>\n- 현재 성공 및 실패한 테스트의 개수와 소요된 시간 등을 표시하는 영역이다.\n<strong>(2) URL 프리뷰 영역</strong>\n- 현재 실행 중인 애플리케이션의 URL이 표시되는 영역이다.\n<strong>(3) 명령(command) 로그 영역</strong>\n- 테스트 명세 내에서 실행된 모든 명령의 로그가 표시되는 영역이다.\n- 마우스를 올리거나 클릭하면 해당 명령이 실행될 시점의 애플리케이션 상태를 확인할 수 있다.\n<strong>(4) 앱 프리뷰 영역</strong>\n- 실제 실행 중인 애플리케이션 화면이 표시되는 영역이다.</p>\n<p>위의 그림에서 명령 로그 영역에 보라색으로 표시된 부분(A)이 현재 클릭된 명령이며, 이 경우 앱 프리뷰 영역에서 해당 명령에 영향을 받는 DOM 엘리먼트를 하이라이팅 처리(B) 해 준다. 또한 앱 프리뷰 영역의 하단에 있는 레이어(C)를 통해 명령이 실행되기 직전과 직후의 모습을 비교해볼 수 있다. </p>\n<h3 id=\"백그라운드-실행\" style=\"position:relative;\"><a href=\"#%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89\" aria-label=\"백그라운드 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>백그라운드 실행</h3>\n<p>Cypress를 <code class=\"tui-language-text\">open</code> 명령을 통해 실행하게 되면 위와 같이 GUI 화면과 함께 인터랙티브 모드로 실행된다. 이 기능은 개발할 때에는 유용하지만 CI 서버와 같은 환경에서는 불필요한데, 이 경우 <code class=\"tui-language-text\">run</code> 명령을 통해 실행하면 GUI 없이 백그라운드로 실행할 수 있다. <code class=\"tui-language-text\">package.json</code> 파일에 다음과 같이 스크립트를 추가한 다음 npm 명령어를 실행해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"cypress:run\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"cypress run\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"tui-language-text\"><code class=\"tui-language-text\">$ npm run cypress:run</code></pre></div>\n<p>아무런 옵션 없이 <code class=\"tui-language-text\">run</code> 명령을 실행하면 모든 테스트를 실행하기 때문에 시간이 좀 오래 걸릴 것이다. 테스트가 진행되면서 다음과 같이 개별 테스트에 대한 결과가 화면에 표시되는 것을 볼 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731240-3e49bd80-9280-11e9-98dd-01daec1fa884.png\" alt=\"Screen Shot 2018-12-03 at 5 08 56 PM\"></p>\n<p>마지막 테스트까지 실행되고 나면 다음과 같이 전체 테스트에 대한 결과를 정리해서 보여준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731235-3d189080-9280-11e9-88cd-d5278cdc295d.png\" alt=\"Screen Shot 2018-12-03 at 5 08 26 PM\"></p>\n<p>테스트의 전체 진행 상황은 동영상으로 자동으로 저장되며, <code class=\"tui-language-text\">cypress/videos/examples</code> 폴더에 가면 테스트 파일별로 별도의 <code class=\"tui-language-text\">mp4</code> 형식의 동영상 파일이 생성된 것을 확인할 수 있다.</p>\n<h2 id=\"cypress-테스트-코드-작성\" style=\"position:relative;\"><a href=\"#cypress-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1\" aria-label=\"cypress 테스트 코드 작성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cypress 테스트 코드 작성</h2>\n<p>이제 <a href=\"http://todomvc.com\">Todo MVC</a> 애플리케이션을 사용해 아주 간단한 테스트를 작성하면서 실제로 Cypress의 API를 경험해 보도록 하자. Todo MVC의 예제는 홈페이지를 통해 쉽게 구할 수 있으며 어떤 프레임워크를 사용하든 상관없기 때문에 애플리케이션 설치 과정은 따로 다루지 않겠다. 이 가이드에서는 <code class=\"tui-language-text\">http://localhost:8888</code>에 Todo MVC 애플리케이션이 실행되어 있다고 가정한다.</p>\n<h3 id=\"테스트-파일-생성-및-실행\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%8B%A4%ED%96%89\" aria-label=\"테스트 파일 생성 및 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 파일 생성 및 실행</h3>\n<p>가장 먼저 해야 할 일은 테스트 파일을 추가하는 일이다. <code class=\"tui-language-text\">cypress/integration</code> 폴더에 <code class=\"tui-language-text\">todo.spec.js</code> 파일을 추가한 후에 다음과 같이 입력하자. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Todo MVC'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beforeEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    cy<span class=\"token punctuation\">.</span><span class=\"token function\">visit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://localhost:8888'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Cypress는 내부적으로 Mocha의 API를 사용하는데, <code class=\"tui-language-text\">describe</code>, <code class=\"tui-language-text\">beforeEach</code> 등의 함수명이 앞서 살펴본 Jasmine의 API와 거의 유사한 것을 볼 수 있다. 유일한 다른 점은 전역 객체인 <code class=\"tui-language-text\">cy</code>인데, Cypress에서는 모든 명령을 이 <code class=\"tui-language-text\">cy</code> 객체를 통해서 실행한다고 생각하면 된다. 위의 코드에서 <code class=\"tui-language-text\">cy.visit</code>은 인자로 넘겨진 URL로 접속해서 페이지를 로드하기 위한 명령이다.</p>\n<h3 id=\"테스트-코드-작성하기\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"테스트 코드 작성하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 코드 작성하기</h3>\n<p>이제 커맨드 라인에 <code class=\"tui-language-text\">npm run cypress:open</code>을 입력해 Cypress를 실행한 다음 테스트 러너에서 <code class=\"tui-language-text\">todo.spec.js</code>를 클릭해서 해당 테스트 파일을 실행해보자. 아직은 테스트를 작성하지 않았기 때문에 명령 로그 영역에 \"No tests found in file\"이라는 메시지가 표시될 것이다. 이제 실제로 테스트를 작성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"tui-language-js\"><code class=\"tui-language-js\"><span class=\"token function\">describe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Todo MVC'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beforeEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    cy<span class=\"token punctuation\">.</span><span class=\"token function\">visit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://localhost:8888'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">it</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Todo 입력하기'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 클래스가 new-todo인 엘리먼트에 \"Cypress 실습\"을 입력한 후 엔터키 입력</span>\n    cy<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.new-todo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Cypress 실습{enter}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n    <span class=\"token comment\">// 클래스가 new-todo인 엘리먼트의 value가 빈 문자열이어야 한다.</span>\n    cy<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.new-todo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">should</span><span class=\"token punctuation\">(</span><span class=\"token string\">'have.value'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 클래스가 todo-list인 엘리먼트의 첫번째 자식 li는 \"Cypress 실습\" 이라는 텍스트를 포함한다.</span>\n    cy<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.todo-list li'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">eq</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">should</span><span class=\"token punctuation\">(</span><span class=\"token string\">'contain'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Cypress 실습'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 클래스가 todo-count인 엘리먼트는 \"1 item left\" 라는 텍스트를 포함한다.</span>\n    cy<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.todo-count'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">should</span><span class=\"token punctuation\">(</span><span class=\"token string\">'contain'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1 item left'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 코드에서 볼 수 있듯이 <code class=\"tui-language-text\">cy</code> 객체에서 실행되는 대부분의 함수들은 <code class=\"tui-language-text\">cy</code> 객체를 다시 반환하기 때문에 체이닝(Chaining) 형태로 호출할 수 있다. 여기서 <code class=\"tui-language-text\">cy</code> 객체의 모든 API에 대해 소개할 수는 없기 때문에 좀 더 자세한 내용은 <a href=\"https://docs.cypress.io/api/api/table-of-contents.html\">공식 API 문서</a>를 참고하길 바라며, 대신 이해를 돕기 위해 각각의 코드 위에 한글로 주석을 달아놓았다. 하지만 <code class=\"tui-language-text\">get</code>, <code class=\"tui-language-text\">type</code>, <code class=\"tui-language-text\">should</code> 등의 API가 아주 직관적이고 단순하게 설계되어 있기 때문에 굳이 설명이 없어도 테스트가 검증하려고 하는 것들이 무엇인지 한눈에 알 수 있을 것이다.</p>\n<p>위의 코드를 저장하면 Cypress가 코드 변경을 감지한 후 테스트 러너가 재실행되고, 실제 테스트가 진행되는 것을 볼 수 있다. 테스트가 완료된 후에는 아래와 같은 화면을 볼 수 있을 것이다. 좌측 명령 로그 영역에는 위에서 작성한 모든 명령들이 기록되어 있으며, 각 명령들에 마우스를 올리거나 클릭하면 해당 명령이 실행될 때의 화면 상태를 모두 확인할 수 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35218826/59731241-3ee25400-9280-11e9-9085-6817830bf8a8.png\" alt=\"Screen Shot 2018-12-03 at 9 08 26 PM\"></p>\n<p>이상으로 Cypress를 사용한 간단한 테스트까지 작성해보았다. Cypress는 이 외에도 E2E 테스트 작성을 도와주는 수많은 기능을 제공하고 있다. Cypress의 <a href=\"https://docs.cypress.io/\">공식 가이드</a>에는 튜토리얼 및 테스트 작성 가이드, API 등 모든 문서가 아주 친절하고 자세하게 작성되어 있으므로, 더 깊은 내용을 알고 싶다면 꼭 홈페이지에 있는 문서를 하나하나 꼼꼼하게 읽어보길 바란다.</p>\n<h2 id=\"맺음말\" style=\"position:relative;\"><a href=\"#%EB%A7%BA%EC%9D%8C%EB%A7%90\" aria-label=\"맺음말 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>맺음말</h2>\n<p>지금까지 Jasmine, Karma, Jest, Selenium WebDriver, Cypress등 프론트엔드 환경에서 사용되는 다양한 테스트 도구들에 대해 살펴보았다. 이토록 다양한 테스트 도구가 만들어진 이유는 자바스크립트가 그만큼 많은 영역에서 사용된다는 의미이며, 동시에 자바스크립트의 발전과 더불어 개발 도구들도 끊임없이 발전하고 있다는 반증일 것이다. 이 문서를 통해 각각의 도구들이 갖는 장단점을 잘 이해하고, 프로젝트의 성격에 맞는 도구를 잘 활용해서 제품의 품질과 코드의 품질을 모두 높일 수 있게 되길 바란다.</p>\n<hr>\n<p>이 문서의 내용과 연관된 FE개발랩 사내 교육은 아래와 같다. 추가로 교육을 수강할 것을 권장 한다.</p>\n<ul>\n<li>테스트</li>\n<li>웹팩을 이용한 자바스크립트 실전 개발</li>\n</ul>\n<hr>\n<p>이 문서는 NHN의 FE개발랩에서 작성하고 관리하는 공식 웹 프론트 개발 가이드이다.\n가이드 적용 관련 문의나 문서의 오류, 개선 제안은 공식 문의 채널(<a href=\"mailto:dl_javascript@nhn.com\">dl_javascript@nhn.com</a>)을 통해 할 수 있다.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Last Modified</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">2019. 03. 29</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"id":"ko_TEST","title":"테스트","description":"자바스크립트는 최근 몇 년간 비약적인 발전을 통해 사용 범위를 넓혀오고 있으며, 프론트엔드 환경에서 요구하는 애플리케이션의 수준도 나날이 복잡해지고 있다. 이와 더불어 자바스크립트의 테스트 환경도 짧은 기간 동안 많은 변화를 겪었는데, 특히 Node.js의 등장 이후 무수히 많은 도구가 쏟아져 나오며 빠른 속도로 발전해오고 있다.","date":null}},"allProductsJson":{"edges":[{"node":{"id":"tui-chart","packageName":null,"name":"Chart","type":"application","description":"The Chart makes your data pop, and it is easy to use. It provides you with multiple charts like Bar, Column, Line, and more.","detailDesc":"Chart makes your data pop. Its numerous charts like Line, Bar, Pie, and more are easy to use, and you can export your data to excel or even as images.","link":"","logo":null}},{"node":{"id":"tui-editor","packageName":"@toast-ui/editor","name":"Editor","type":"application","description":"The Editor allows you to edit your Markdown documents using text or WYSIWYG and comes with Syntax Highlighting, Scroll-Sync, Live Preview, and Chart features.","detailDesc":"Editor allows you to interact with their Markdown documents through both text and WYSIWYG. With Syntax Highlighting, Scroll-Sync, Live Preview, Charts, and much more diverse features and UI, it takes your word processing to the next level.","link":"https://nhn.github.io/tui.editor/latest","logo":null}},{"node":{"id":"tui-grid","packageName":null,"name":"Grid","type":"application","description":"The Grid is a powerful library with features like data editing, filtering, sorting, and more, and can be used to customize the editor or the renderer to your desired format.","detailDesc":"Grid is a powerful grid library with data editing, filtering, sorting, pagination features, and more. Furthermore, you can customize the editor and the renderer to your desired format and visualize your data however you like.","link":"https://nhn.github.io/tui.grid/latest/","logo":null}},{"node":{"id":"tui-calendar","packageName":null,"name":"Calendar","type":"application","description":"The Calendar supports monthly, weekly, daily views and more, and you can create or edit your schedule with a simple dragging motion.","detailDesc":"Calendar provides monthly, weekly, multi-weekly, daily views, and more, as well as a basic pop-up UI you can use to add/edit/delete your schedules. You can manage your schedule simply by dragging the schedules around. Managing your calendar has never been easier.","link":"","logo":null}},{"node":{"id":"tui-image-editor","packageName":null,"name":"Image-editor","type":"application","description":"With the UI that is the perfect combination of simple and beautiful, the Image Editor is a Full-Featured one that is perfect for everyday use.","detailDesc":"With the UI that is the perfect combination of simple and beautiful, Image Editor is a Full-Featured image editor that provides you with editing, drawing, and typing capabilities as well as a collection of great image filters that you can apply all at once.","link":"https://nhn.github.io/tui.image-editor/latest/","logo":null}},{"node":{"id":"tui-app-loader","packageName":null,"name":"App Loader","type":"component","description":"AppLoader is a library that you can use to load or install a certain app on the mobile device.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-auto-complete","packageName":null,"name":"Auto Complete","type":"component","description":"AutoComplete component can suggest and even fill in the rest of the word and sentences given the inputted text.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-color-picker","packageName":null,"name":"Color Picker","type":"component","description":"ColorPicker is a simple and efficient color picker, true to its name.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-context-menu","packageName":null,"name":"Context Menu","type":"component","description":"ContextMenu displays the menu items that you can access via the right click.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-date-picker","packageName":null,"name":"Date Picker","type":"component","description":"DatePicker allows you to pick a date using a pop-up calendar.\n\n","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-pagination","packageName":null,"name":"Pagination","type":"component","description":"Pagination component can show you the current page within a multi-page document and also provides links for included pages.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-rolling","packageName":null,"name":"Rolling","type":"component","description":"Rolling is a slider component that lets you view multiple contents in a selected area.","detailDesc":"","link":"","logo":null}},{"node":{"id":"select-box","packageName":"@toast-ui/select-box","name":"Select Box","type":"component","description":"SelectBox is a dropdown list component that you can use to select multiple menus easily.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-time-picker","packageName":null,"name":"Time Picker","type":"component","description":"TimePicker component allows you to use the SelectBox or the SpinBox to select the time.","detailDesc":"","link":"","logo":null}},{"node":{"id":"tui-tree","packageName":null,"name":"Tree","type":"component","description":"Tree component displays the data structure of the hierarchy and allows you to view and edit the node names.","detailDesc":"","link":"","logo":null}},{"node":{"id":"@toast-ui/doc","packageName":null,"name":"TOAST UI Doc","type":"tool","description":"Documentation generator that creates the example page and the API document by parsing the JSDoc comments.","detailDesc":"","link":"https://github.com/nhn/toast-ui.doc","logo":null}},{"node":{"id":"tui-eslint-config","packageName":null,"name":"ESLint Config","type":"tool","description":"ESLint configuration used with TOAST UI products to help find and fix problems in JavaScript code.","detailDesc":"","link":"https://github.com/nhn/tui.eslint.config","logo":null}},{"node":{"id":"tui-release-notes","packageName":null,"name":"Release Note","type":"tool","description":"Github release note generator to automatically summarize and classify the updates based on the commit logs.","detailDesc":"","link":"https://github.com/nhn/toast-ui.release-notes","logo":null}},{"node":{"id":"toast","packageName":null,"name":"TOAST Cloud","type":"references","description":"references is TOAST Cloud","detailDesc":"","link":"https://www.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-nhntoast.png"}},{"node":{"id":"toastfile","packageName":null,"name":"TOAST File","type":"references","description":"references is TOAST File","detailDesc":"","link":"https://file.toast.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastfile.png"}},{"node":{"id":"dooray","packageName":null,"name":"Dooray","type":"references","description":"references is Dooray","detailDesc":"","link":"https://dooray.com/home","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-toastdooray.png"}},{"node":{"id":"ncp","packageName":null,"name":"NCP","type":"references","description":"references is NCP","detailDesc":"","link":"https://www.e-ncp.com/","logo":"https://uicdn.toast.com/toastui/img/toast-ui-bi-ncp.png"}}]}},"pageContext":{"id":"ko_TEST","lang":"ko"}},"staticQueryHashes":["2997033868","414700122","542722004"]}